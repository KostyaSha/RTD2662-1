C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE ADJUST_CUSTOMER
OBJECT MODULE PLACED IN .\Output\Adjust_customer.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Core\code\Adjust_customer.c LARGE OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Output\Adjust_customer.lst) OBJECT(.\Output\Adjust_customer.obj)

stmt level    source

   1          /*===========================================================
   2           * Copyright (c)      Realtek Semiconductor Corporation, 2005
   3           * All rights reserved.
   4           * ========================================================== */
   5          
   6          /*==================== File Description ===================== */
   7          /**
   8           * @file
   9           *  This file is osd control declaration related functions.
  10           *
  11           * @author  $Author: forster $
  12           * @date    $Date: 2006-03-21 20:24:23 +0800 (?Ÿæ?äº? 21 ä¸‰æ? 2006) $
  13           * @version     $Revision: 451 $
  14           * @ingroup Auto
  15           */
  16          
  17          /**
  18           * @addtogroup Auto
  19           * @{
  20           */
  21          
  22          #define _ADJUST_CUSTOMER_C
  23          /*===================== Module dependency  ================== */
  24          #include "Core\Header\Include.h"
  25          
  26          void CAdjustAudio(void)
  27          {
  28   1          if(0)//_GET_INPUT_SOURCE() == _SOURCE_VIDEO_AV || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_SV)
  29   1          {
  30   2                      pData[0] = (0x78 + stAudioData.Volume - 50);//0x80
  31   2                      pData[1] = (0x78 + stAudioData.Volume - 50);//0x80
  32   2                      pData[2] = (0x78 + stAudioData.Volume - 50);//0x80
  33   2          }
  34   1          else
  35   1          {
  36   2                      pData[0] = (0x80 + stAudioData.Volume - 50);//0x80
  37   2                      pData[1] = (0x80 + stAudioData.Volume - 50);//0x80
  38   2                      pData[2] = (0x80 + stAudioData.Volume - 50);//0x80
  39   2      
  40   2          }
  41   1           CAdjustVolume();
  42   1      }
  43          
  44          //--------------------------------------------------
  45          // Description  : Adjust color precessing brightness
  46          // Input Value  : None
  47          // Output Value : None
  48          //--------------------------------------------------
  49          void CAdjustBrightness(void)
  50          {
  51   1              if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
  52   1              {
  53   2                      pData[0] = (128 + stConBriData.Brightness - 50);// + stColorTempData.ColorTemp[0];
  54   2                      pData[1] = pData[0];//(128 + stConBriData.Brightness - 50);// + stColorTempData.ColorTemp[1];
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 2   

  55   2                      pData[2] = pData[0];//(128 + stConBriData.Brightness - 50);// + stColorTempData.ColorTemp[2];
  56   2              }
  57   1          //   EricLee modify for AV/SV gary-scale
  58   1          else if(0)//_GET_INPUT_SOURCE() == _SOURCE_VIDEO_AV || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_SV)
  59   1          {
  60   2                      pData[0] = (0x78 + stConBriData.Brightness - 50);//0x80
  61   2                      pData[1] = (0x78 + stConBriData.Brightness - 50);//0x80
  62   2                      pData[2] = (0x78 + stConBriData.Brightness - 50);//0x80
  63   2          }
  64   1          else
  65   1          {
  66   2                      pData[0] = (0x80 + stConBriData.Brightness - 50);//0x80
  67   2                      pData[1] = (0x80 + stConBriData.Brightness - 50);//0x80
  68   2                      pData[2] = (0x80 + stConBriData.Brightness - 50);//0x80
  69   2          }
  70   1          
  71   1              CAdjustSetBrightness();
  72   1      #if(_BACKLIGHT_USE_FAC_ADJ == _DISABLE)
  73   1          CAdjustBacklight();
  74   1      #endif
  75   1      }
  76          
  77          //--------------------------------------------------
  78          // Description  : Adjust color processing contrast
  79          // Input Value  : None
  80          // Output Value : None
  81          //--------------------------------------------------
  82          void CAdjustContrast(void)
  83          {
  84   1              BYTE cnt;
  85   1      
  86   1          if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
  87   1          {
  88   2                  for(cnt=0;cnt<3;cnt++)
  89   2                      {
  90   3                      //pData[cnt] = (((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128) > 255) ? 255 : 
             -(BYTE)((WORD)stColorTempData.ColorTemp[cnt] * stConBriData.Contrast / 128);
  91   3                      pData[cnt] = (BYTE)(((WORD)stColorTempData.ColorTemp[cnt] * (stConBriData.Contrast+_CONTRAST_MIN)
             - / 128) > 255) ? 255 : (BYTE)((WORD)stColorTempData.ColorTemp[cnt] * (stConBriData.Contrast+_CONTRAST_MIN) / 128);
  92   3                      }
  93   2              }                       
  94   1          else if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_AV || _GET_INPUT_SOURCE() == _SOURCE_VIDEO_SV)
  95   1          {
  96   2                      pData[0] = (0x80 + stConBriData.Contrast - 50);
  97   2                      pData[1] = (0x80 + stConBriData.Contrast - 50);
  98   2                      pData[2] = (0x80 + stConBriData.Contrast - 50);
  99   2              }       
 100   1          else
 101   1          {
 102   2                      pData[0] = (0x80 + stConBriData.Contrast - 50);
 103   2                      pData[1] = (0x80 + stConBriData.Contrast - 50);
 104   2                      pData[2] = (0x80 + stConBriData.Contrast - 50);
 105   2              }       
 106   1      
 107   1          CAdjustSetContrast();
 108   1      }
 109          
 110          #if (sRGB_Color_Enhance == _ENABLE)
 111          void CAdjustYpbprhue(BYTE  ucYPbPrhue)
 112          {
 113   1          CAdjustSaturationHue(ucYPbPrhue, _FALSE);
 114   1      }
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 3   

 115                       /*
 116          
 117          #define _YUV2RGB_k13   1
 118          #define _YUV2RGB_k22   2
 119          #define _YUV2RGB_k23   3
 120          #define _YUV2RGB_k32   4
 121          UINT16 tYUV2RGB_COEF_601_YCbCr[] =
 122          {
 123           
 124            0x0100, // k11
 125            0x0166, // k13
 126            0x0058, // k22
 127            0x00b6, // k23
 128            0x01c5, // k32
 129            0x0000, // R-offset
 130            0x0000, // G-offset
 131            0x0000, // B-offset
 132           
 133            0x0000, // Y Clamp (Y-16)
 134            0x0001, // UV Clamp (UV-512)
 135           
 136          };              */
 137          
 138          void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
 139          {
 140   1          WORD PB,PR;//,new_k13,new_k22,new_k23,new_k32,new_coeffs;
 141   1          BYTE temp;
 142   1      
 143   1          temp=ucYPbPrSaturation;
 144   1      
 145   1          if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR||_GET_INPUT_SOURCE() == _SOURCE_YPBPR1)
 146   1          {
 147   2              PR = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_RED] + ((50 - temp) << 2)) :
 148   2              ((WORD)stYPbPrData.YPbPrGain[_RED] - (temp - 50));
 149   2          
 150   2              PB = (temp <= 50)  ? ((WORD)stYPbPrData.YPbPrGain[_BLUE] + ((50 - temp) << 2)) :
 151   2              ((WORD)stYPbPrData.YPbPrGain[_BLUE] - (temp - 50));
 152   2          
 153   2              if(HIBYTE(PB)>0)
 154   2                  PB  = HIBYTE(PB) < 0x02 ? 0x00FF : 0 ;
 155   2              if (HIBYTE(PR)>0)
 156   2                  PR  = HIBYTE(PR) < 0x02 ? 0x00FF : 0 ;
 157   2          
 158   2          #if(_ADC1_INPUT_SWAP_RG == _ON)
                  
                      pData[1] = PR;
                      pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                  
                  #elif(_ADC1_INPUT_SWAP_RB == _ON)
                  
                      pData[2] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[0] = PB;
                  
                  #elif(_ADC1_INPUT_SWAP_GB == _ON)
 171   2          
 172   2              pData[0] = PR;
 173   2              pData[2] = stYPbPrData.YPbPrGain[_GREEN];
 174   2              pData[1] = PB;
 175   2          
 176   2          #else
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 4   

                  
                      pData[0] = PR;
                      pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                      pData[2] = PB;
                  
                  #endif
 183   2              //CAdjustSetYpbprSaturation();//eric 20070613
 184   2              CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 185   2          }
 186   1      
 187   1          //Lewis, adjust sRGB domain
 188   1          CAdjustSaturationHue(ucYPbPrSaturation, _TRUE);
 189   1                        /*
 190   1      
 191   1          new_coeffs =  (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k13] * ucYPbPrSaturation;
 192   1          new_coeffs = (new_coeffs >> 7) ;
 193   1          new_k13 = (new_coeffs > 0x1ff) ? 0x1ff: new_coeffs;
 194   1          
 195   1          new_coeffs = (double)  tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k22]  * ucYPbPrSaturation;
 196   1          new_coeffs = (new_coeffs >> 7) ;
 197   1          
 198   1          new_k22 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 199   1          
 200   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k23]  * ucYPbPrSaturation;
 201   1          new_coeffs = (new_coeffs >> 7) ;
 202   1          
 203   1          new_k23 = (new_coeffs > 0xff) ? 0xff: new_coeffs;
 204   1          
 205   1          new_coeffs = (double)   tYUV2RGB_COEF_601_YCbCr[_YUV2RGB_k32]  * ucYPbPrSaturation;
 206   1          new_coeffs = (new_coeffs >> 7) ;
 207   1          
 208   1          new_k32 = (new_coeffs > 0x3ff) ? 0x3ff: new_coeffs;
 209   1      
 210   1      
 211   1          CScalerPageSelect(_PAGE7);
 212   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k13 >> 8));
 213   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k13 & 0xFF));
 214   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k22 >> 8));
 215   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k22 & 0xFF));
 216   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k23 >> 8));
 217   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k23 & 0xFF));
 218   1          CScalerSetByte(_P7_YUV2RGB_ACCESS_C0,(WORD)(new_k32 >> 8));
 219   1          CScalerSetByte(_P7_YUV2RGB_DATA_C1,(WORD)(new_k32 & 0xFF)); */
 220   1      }
 221          
 222          #else
              // cftsai 20061031 modify
              INT16 code RR[]=
              {
              -155,-149,-143,-138,-132,-127,-121,-116,-111,-105,
              -100, -95, -90, -85, -80, -75, -71, -66, -62, -57,
               -53, -49, -45, -40, -36, -33, -29, -25, -22, -18,
               -15, -12,  -8,  -5,  -2,   0,   2,   5,   7,  10,
                12,  14,  16,  18,  20,  22,  24,  25,  26,  28,
                29,  30,  31,  32,  32,  33,  33,  34,  34,  34,
                34,  34,  34,  33,  33,  32,  32,  31,  30,  29,
                28
              };
              
              INT16 code RG[]=
              {
              -100, -99, -98, -96, -95, -93, -92, -90, -88, -86,
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 5   

               -84, -81, -79, -77, -74, -72, -69, -66, -63, -60,
               -57, -54, -51, -47, -44, -40, -36, -33, -29, -25,
               -21, -17, -13,  -8,  -4,   0,   4,   9,  13,  18,
                23,  28,  33,  38,  43,  48,  53,  58,  64,  69,
                74,  80,  86,  91,  97, 102, 108, 114, 120, 126,
               132, 138, 144, 150, 156, 162, 168, 174, 180, 186,
               193
              };
              
              INT16 code RB[]=
              {
              255, 249, 242, 235, 227, 220, 213, 206, 199, 192,
              184, 177, 170, 162, 155, 148, 140, 133, 125, 118,
              110, 103,  96,  88,  81,  73,  66,  58,  51,  44,
               36,  29,  21,  14,   7,   0,  -7, -14, -21, -28,
              -35, -42, -49, -56, -63, -70, -77, -84, -91, -97,
              -104, -110, -117, -123, -130, -136, -142, -148, -154, -160,
              -166, -172, -178, -184, -189, -195, -200, -205, -211, -216,
              -221
              };
              
              INT16 code GR[]=
              {
              162 ,157 ,152 ,147 ,142 ,137 ,132 ,127 ,
              122 ,117 ,113 ,108 ,103 ,98  ,93  ,88  ,
              84  ,79  ,74  ,70  ,65  ,60  ,56  ,51  ,
              47  ,42  ,38  ,33  ,29  ,25  ,20  ,16  ,
              12  ,8   ,4   ,0   ,-4  ,-7  ,-11 ,-15 ,
              -19 ,-23 ,-27 ,-30 ,-34 ,-37 ,-41 ,-44 ,
              -48 ,-51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,
              -72 ,-75 ,-77 ,-80 ,-83 ,-85 ,-87 ,-90 ,
              -92 ,-94 ,-96 ,-98 ,-100,-102,-104
              };
              
              INT16 code GG[]=
              {
              -9 ,-7 ,-6 ,-4 ,-3 ,-2 ,-1 ,0  ,
              1  ,2  ,3  ,3  ,4  ,5  ,5  ,6  ,
              6  ,7  ,7  ,7  ,7  ,7  ,7  ,7  ,
              7  ,7  ,6  ,6  ,5  ,5  ,4  ,3  ,
              2  ,2  ,1  ,0  ,-1 ,-2 ,-3 ,-5 ,
              -6 ,-8 ,-9 ,-11,-13,-15,-16,-18,
              -20,-23,-25,-27,-29,-32,-34,-37,
              -39,-42,-45,-48,-51,-53,-56,-60,
              -63,-66,-69,-72,-76,-79,-83
              };
              
              INT16 code GB[]=
              {
              -152,-149,-145,-142,-138,-135,-131,-127,
              -123,-120,-116,-112,-108,-103,-99 ,-95 ,
              -91 ,-86 ,-82 ,-77 ,-73 ,-68 ,-64 ,-59 ,
              -54 ,-49 ,-45 ,-40 ,-35 ,-30 ,-25 ,-20 ,
              -15 ,-10 ,-5  ,0   ,5   ,10  ,15  ,20  ,
              26  ,31  ,36  ,42  ,47  ,52  ,58  ,63  ,
              69  ,74  ,79  ,85  ,90  ,96  ,101 ,107 ,
              112 ,117 ,123 ,128 ,134 ,139 ,144 ,150 ,
              155 ,160 ,166 ,171 ,176 ,181 ,187
              };
              
              INT16 code BR[]=
              {
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 6   

              -172, -169, -165, -162 , -158, -154, -150, -146, -142, -138,
              -133, -129, -124,-120,-115,-110,-105,-100,-95,-90,
              -85,-80,-75,-69,-64,-58,-53,-47,-41,-35,
              -30,-24,-18,-12,-6,0,6,12,18,24,
              31,37,44,50,57,63,70,76,83,89,
              96,103,109,116,123,130,136,143,150,157,
              163,170,177,183,190,197,204,210,217,224,
              230
              };
              
              INT16 code BG[]=
              {
              193 ,186 ,180 ,174 ,168 ,162 ,156 ,150 ,
              144 ,138 ,132 ,126 ,120 ,114 ,108 ,102 ,
              97  ,91  ,86  ,80  ,74  ,69  ,64  ,58  ,
              53  ,48  ,43  ,38  ,33  ,28  ,23  ,18  ,
              13  ,9   ,4   ,0   ,-4  ,-8  ,-13 ,-17 ,
              -21 ,-25 ,-29 ,-33 ,-36 ,-40 ,-44 ,-47 ,
              -51 ,-54 ,-57 ,-60 ,-63 ,-66 ,-69 ,-72 ,
              -74 ,-77 ,-79 ,-81 ,-84 ,-86 ,-88 ,-90 ,
              -92 ,-93 ,-95 ,-96 ,-98 ,-99 ,-100
              };
              
              INT16 code BB[]=
              {
              -20 ,-17, -14, -12, -9, -7, -5, -3,
              -1  ,0   ,1   ,3   ,4   ,5   ,6   ,7   ,
              8   ,9   ,9   ,10  ,10  ,10  ,10  ,10  ,
              10  ,10  ,9   ,9   ,8   ,7   ,6   ,5   ,
              4   ,3   ,1   ,0   ,-1  ,-3  ,-5  ,-7  ,
              -9  ,-12 ,-14 ,-17 ,-20 ,-22 ,-25 ,-29 ,
              -32 ,-35 ,-39 ,-42 ,-46 ,-50 ,-53 ,-57 ,
              -62 ,-66 ,-70 ,-75 ,-79 ,-84 ,-88 ,-93 ,
              -98 ,-103,-108,-114,-119,-124,-130
              };
              
              void CAdjustYpbprhue(BYTE  ucYPbPrhue)
              {
                  BYTE uchue ;
              
                  uchue = ucYPbPrhue *0.7 ;
                  //Write R
                  pData[0] = ((RR[uchue] >> 8) & 0x01);   // RRH
                  pData[1] = (RR[uchue] & 0xff);      // RRL
                  pData[2] = ((RG[uchue] >> 8) & 0x01);   // RGH
                  pData[3] = (RG[uchue] & 0xff);      // RGL
                  pData[4] = ((RB[uchue] >> 8) & 0x01);   // RBH
                  pData[5] = (RB[uchue] & 0xff);      // RBL
                  CAdjustSetYpbprRhue();
              
                  //Write G
                  pData[0] = ((GR[uchue] >> 8) & 0x01);   // GRH
                  pData[1] = (GR[uchue] & 0xff);      // GRL
                  pData[2] = ((GG[uchue] >> 8) & 0x01);   // GGH
                  pData[3] = (GG[uchue] & 0xff);      // GGL
                  pData[4] = ((GB[uchue] >> 8) & 0x01);   // GBH
                  pData[5] = (GB[uchue] & 0xff);      // GBL
                  CAdjustSetYpbprGhue();
              
                  //Write B
                  pData[0] = ((BR[uchue] >> 8) & 0x01);   // BRH
                  pData[1] = (BR[uchue] & 0xff);      // BRL
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 7   

                  pData[2] = ((BG[uchue] >> 8) & 0x01);   // BGH
                  pData[3] = (BG[uchue] & 0xff);      // BGL
                  pData[4] = ((BB[uchue] >> 8) & 0x01);   // BBH
                  pData[5] = (BB[uchue] & 0xff);      // BBL
                  CAdjustSetYpbprBhue();
              
                  CScalerSetBit(_COLOR_CTRL_62, 0xff, 0x80);          // cftsai 20061031 added, ready to write
              }
              
              
              void CAdjustYpbprSaturation(BYTE  ucYPbPrSaturation)
              {
                  WORD    PB, PR ;
              
                  PR = (WORD)stYPbPrData.YPbPrGain[_RED] * (100 - ucYPbPrSaturation) /(WORD)50  ;
                  PB = (WORD)stYPbPrData.YPbPrGain[_BLUE] * (100 - ucYPbPrSaturation) /(WORD)50 ;
              if(HIBYTE(PB)>0)
                  PB  = 0x00FF ;
              if (HIBYTE(PR)>0)
                  PR  = 0x00FF ;
              
               #if(_ADC_INPUT_SWAP_RG == _ON)
              
                  pData[1] = PR;
                  pData[0] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[2] = PB;
              
              #elif(_ADC_INPUT_SWAP_RB == _ON)
              
                  pData[2] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[0] = PB;
              
              #elif(_ADC_INPUT_SWAP_GB == _ON)
              
                  pData[0] = PR;
                  pData[2] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[1] = PB;
              
              #else
              
                  pData[0] = PR;
                  pData[1] = stYPbPrData.YPbPrGain[_GREEN];
                  pData[2] = PB;
              
              #endif
                  CAdjustSetYpbprSaturation();
              
              }
              #endif      // sRGB_Color_Enhance end
 413          
 414          
 415          
 416          #if(_AdjustCustomerColorMode==_ENABLE)
              void CAdjustCustomerColorMode(void)
              {
              #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
              
              // Brightness_R,Brightness_G,Brightness_B,Contrast_R,Contrast_G,Contrast_B,Sharpness_Num
              // VDC_Contrast,VDC_Brightness,VDC_Saturation,VDC_Hue,VDC_Shaprness
              
                  BYTE code ColorType[][12] = {
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 8   

                  // CVBS,SV
                  //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                      0x80,  0x80,  0x7F,  0x87,  0x80,  0x7A,   6,        38,           0x78,     64,         46,      
             -    0x17,
              
                  // TV
                  //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                      0x80,  0x80,  0x80,  0x80,  0x80,  0x80,  6,        52,           0x85,     52,         47,       
             -   0x17,
                     //0x80,  0x80,  0x80,  0x80,  0x80,  0x80,   6,        33,           0x85,     58,         46,     
             -     0x17,
              
                  // YPbPr  , HDMI
                  //    B_R    B_G   B_B     C_R    C_G    C_B    Sharp   VD_Con   VD_Bri   VD_Sat   VD_Hue    VD_Sharp
                      0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,      
             -    0x17,
                     //0x80,  0x80,  0x7F,  0xB3,  0xAA,  0xA2,   6,        38,           0x78,     50,         50,     
             -     0x17,
              
              
                  };
              
                  if(!bSourceVideo())
                  {
              
                          pData[0] = ColorType[2][0];
                          pData[1] = ColorType[2][1];
                          pData[2] = ColorType[2][2];
                          pData[3] = ColorType[2][3];
                          pData[4] = ColorType[2][4];
                          pData[5] = ColorType[2][5];
              
                          CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                          SET_PEAKING_CORING(ColorType[2][6]);
                          SET_CONTRAST(ColorType[2][7]);
                          //SET_YPbPrSaturation(ColorType[2][9]);
                          //SET_YPbPrHue(ColorType[2][10]);
                                   SET_SATURATION(ColorType[2][9]);
                          SET_HUE(ColorType[2][10]);          
                          CEepromSaveSystemData();
              
                          CAdjustPeakingFilter(GET_PEAKING_CORING());
                          CAdjustContrast();
                          //CAdjustYpbprSaturation(GET_YPbPrSaturation());
                          //CAdjustYpbprhue(GET_YPbPrHue());
                          CAdjustYpbprSaturation(GET_SATURATION());
                          CAdjustYpbprhue(50);//GET_HUE());
              #ifdef _SRGB_ENLARGE_RANGE
                                      CScalerSetBit(_COLOR_CTRL_62,~(_BIT6|_BIT2),(_BIT6|_BIT2));     //  Enable SRGB
              #else //#ifdef _SRGB_ENLARGE_RANGE
                                      CScalerSetBit(_COLOR_CTRL_62, 0xFF, _BIT2);
              #endif //#ifdef _SRGB_ENLARGE_RANGE
              
                  }
                  else
                  {   
                      if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                      {
                          
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 9   

                          pData[0] = ColorType[1][0];
                          pData[1] = ColorType[1][1];
                          pData[2] = ColorType[1][2];
                          pData[3] = ColorType[1][3];
                          pData[4] = ColorType[1][4];
                          pData[5] = ColorType[1][5];
              
                          CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
              
                          SET_PEAKING_CORING(ColorType[1][6]);
                          SET_CONTRAST(ColorType[1][7]);
                          SET_SATURATION(ColorType[1][9]);
                          SET_HUE(ColorType[1][10]);
                          CVideoSetVDCBrightness(ColorType[1][8]);
                          I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[1][11]);
                          
                          CEepromSaveSystemData();
                      }
                      else
                      {
                      
                      
                          pData[0] = ColorType[0][0];
                          pData[1] = ColorType[0][1];
                          pData[2] = ColorType[0][2];
                          pData[3] = ColorType[0][3];
                          pData[4] = ColorType[0][4];
                          pData[5] = ColorType[0][5];
              
                          CScalerSetByte(_CB_ACCESS_PORT_64, 0x80);
                              CScalerWrite(_CB_DATA_PORT_65, 6, pData, _NON_AUTOINC);
                              CScalerSetByte(_CB_ACCESS_PORT_64, 0x00);
              
                          SET_PEAKING_CORING(ColorType[0][6]);
                          SET_CONTRAST(ColorType[0][7]);
                          SET_SATURATION(ColorType[0][9]);
                          SET_HUE(ColorType[0][10]);
                          CVideoSetVDCBrightness(ColorType[0][8]);
                          I2CByteWrite(0x80,_VIDEO_DEVICE,ColorType[0][11]);
                          
                          CEepromSaveSystemData();
              
                      }
                      CAdjustPeakingFilter(GET_PEAKING_CORING());
                      CVideoSetContrast(GET_CONTRAST());
                      CVideoSetSaturation(GET_SATURATION());
                      kx_CAdjustVDCHue(GET_HUE());       
                  }
              
              
              #endif
              
              
              #if(sRGB_Color_Enhance == _ENABLE)
              
                  CVideoSetSaturation(GET_SATURATION());
                  kx_CAdjustVDCHue(GET_HUE());
              #ifdef _SRGB_ENLARGE_RANGE
                      CScalerSetBit(_COLOR_CTRL_62,~(_BIT6|_BIT2),(_BIT6|_BIT2));     //  Enable SRGB
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 10  

              #else //#ifdef _SRGB_ENLARGE_RANGE
                      CScalerSetBit(_COLOR_CTRL_62, ~_BIT2, _BIT2);           // enable sRGB
              #endif //#ifdef _SRGB_ENLARGE_RANGE
              
              #endif
              
              }
              #endif
 552          
 553          
 554          #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 555          #define _VIDEO_SATURATION_MAX   0xFF
 556          #define _VIDEO_SATURATION_MIN   0x00
 557          #endif
 558          
 559          //--------------------------------------------------
 560          // Description  : Set  2610 Saturation
 561          // Input Value  : saturationNone
 562          // Output Value : None
 563          //--------------------------------------------------
 564          void CVideoSetSaturation(BYTE ucValue)
 565          {
 566   1      #if(_VIDEO_AUTO_WHITE_BLANCE == _ENABLE)
 567   1              BYTE ucSaturation;
 568   1              BYTE temp;
 569   1              
 570   1              if (_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
 571   1              ucSaturation = 106; // 140
 572   1          else
 573   1              ucSaturation = 140;
 574   1      
 575   1          if(ucValue > 50)
 576   1          {
 577   2              temp = ((UINT16)((_VIDEO_SATURATION_MAX - ucSaturation)*(ucValue - 50))) / 50;
 578   2              temp += ucSaturation;
 579   2          }
 580   1          else if(ucValue < 50)
 581   1          {
 582   2              temp = ((UINT16)((ucSaturation -_VIDEO_SATURATION_MIN) * (50 - ucValue))) / 50;
 583   2              temp = ucSaturation - temp;
 584   2          }
 585   1          else
 586   1              temp = ucSaturation;
 587   1          CVideoSetVDCSaturation(temp);
 588   1      #else
                  ucValue = ucValue * 2.5;
                  CVideoSetVDCSaturation(ucValue);
              #endif
 592   1      }
 593          
 594          //--------------------------------------------------
 595          // Description  : Set  2610 Contrast
 596          // Input Value  : ucValue
 597          // Output Value : None
 598          //--------------------------------------------------
 599          void CVideoSetContrast(BYTE ucValue)
 600          {
 601   1          ucValue = ucValue * 2.5;
 602   1          CVideoSetVDCContrast(ucValue);
 603   1      }
 604          
 605          void CAdjustHueSatSet(BYTE color, SWORD TempU1, SWORD TempU2, SWORD TempV1, SWORD TempV2)
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 11  

 606          {
 607   1          BYTE i;
 608   1          SWORD u,v;
 609   1      
 610   1          BYTE value = (color & 0x0f);
 611   1          //CTimerWaitForEvent(_EVENT_DEN_STOP);
 612   1          CScalerPageSelect(_PAGE7);
 613   1      
 614   1          CScalerSetByte(_P7_ICM_SEL_D1, value);
 615   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,0x00);
 616   1          if(value == 0)
 617   1          {       //R
 618   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x02);
 619   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 620   2              if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 621   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xaa);
 622   2              else
 623   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 624   2          }
 625   1          else if(value == 1)
 626   1          {//G
 627   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x08);
 628   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x00);
 629   2              if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 630   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 631   2              else
 632   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xee);
 633   2          }
 634   1          else if(value == 2)
 635   1          {//B
 636   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0d);
 637   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 638   2              if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 639   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 640   2              else
 641   2                  CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xbe);
 642   2          }
 643   1          else if(value == 3)
 644   1          {//Y
 645   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x05);
 646   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x2e);
 647   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x62);  //ff
 648   2          }
 649   1          else if(value == 4)
 650   1          {//C
 651   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x0a);
 652   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0xd2);
 653   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,0x66);
 654   2          }
 655   1          //CTimerWaitForEvent(_EVENT_DEN_STOP);
 656   1          CScalerSetByte(_P7_ICM_SEL_D1,value);
 657   1          CScalerSetByte(_P7_ICM_ACCESS_PORT_D2,((color & 0xf0)+0x03));
 658   1          //CScalerSendAddr(_P7_ICM_DATA_PORT_D3, _WRITE, _NON_AUTOINC);//provisional ¼È©w
 659   1          
 660   1          for(i=1; i<9; i++)
 661   1          {
 662   2              u = ((TempU1+TempU2)*CAdjustColorGammaCal(value, i)/64) - ((TempU1*i)/8);
 663   2              v = ((TempV1+TempV2)*CAdjustColorGammaCal(value, i)/64) - ((TempV1*i)/8);
 664   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,u); //CScalerSetByte(0xe3,u);       
 665   2              CScalerSetByte(_P7_ICM_DATA_PORT_D3,v); //CScalerSetByte(0xe3,v);       
 666   2          }
 667   1          if(_GET_INPUT_SOURCE() == _SOURCE_VGA || _GET_INPUT_SOURCE() == _SOURCE_DVI)//CGetInputSourceNum(_GET_
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 12  

             -INPUT_SOURCE())>1)
 668   1              CScalerSetByte(_P7_ICM_CTRL_D0,0xdf);
 669   1          else
 670   1              CScalerSetByte(_P7_ICM_CTRL_D0,0xdc);
 671   1          
 672   1      }
 673          
 674          #define CENTER    0x00
 675          #define RIGHT     0x10
 676          #define LEFT      0x20
 677          void CAdjustSetHueUVDelta(BYTE color, BYTE select)
 678          {
 679   1          SWORD TempU1,TempV1,TempU2,TempV2;
 680   1      
 681   1          pData[0] = (select >> 3); //(select >> 4) << 1
 682   1          pData[1] = pData[0] + 1;
 683   1      
 684   1          if(CGetInputSourceNum(_GET_INPUT_SOURCE())>1)
 685   1          {
 686   2            TempU1 = Video_TempUV1[color][pData[0]];
 687   2            TempV1 = Video_TempUV1[color][pData[1]];
 688   2          }
 689   1          else
 690   1          {
 691   2            TempU1 = Graphic_TempUV1[color][pData[0]];
 692   2            TempV1 = Graphic_TempUV1[color][pData[1]];
 693   2          }
 694   1      
 695   1          pData[2] = color*3 + (select >> 4);
 696   1      
 697   1          if(stICMColor.ICM_COLOR[color] < 8)
 698   1          {
 699   2             TempU2 = (long)TempUV2[pData[2]][0] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 700   2             TempV2 = (long)TempUV2[pData[2]][1] * (8 - stICMColor.ICM_COLOR[color]) >> 3;
 701   2          }
 702   1          else
 703   1          {
 704   2             TempU2 = (long)TempUV2[pData[2]][2] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 705   2             TempV2 = (long)TempUV2[pData[2]][3] * (stICMColor.ICM_COLOR[color] - 8) >> 3;
 706   2          }
 707   1          CAdjustHueSatSet((select | color), TempU1, TempU2, TempV1, TempV2);
 708   1      
 709   1      
 710   1      }
 711          #if(_COLOR_PREFERENCE == _PANASONIC_STYLE)
 712          
 713          #define RF_StartOffset          5
 714          #define AV_StartOffset          0
 715          #define YPbPr_StartOffset       0
 716          
 717          void CAdjustPeakingFilter(SBYTE ucPeaking)
 718          {
 719   1          if(_GET_INPUT_SOURCE() == _SOURCE_VGA)
 720   1          {
 721   2              CScalerPageSelect(_PAGE7);
 722   2              CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00); // disable Peaking and Coring
 723   2              CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 724   2              CScalerPageSelect(_PAGE6);
 725   2              CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 726   2              CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 727   2              return;
 728   2          }
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 13  

 729   1              else if(_GET_INPUT_SOURCE() == _SOURCE_HDMI || _GET_INPUT_SOURCE() == _SOURCE_DVI)
 730   1          {
 731   2              //if(HDMI_V_Height>=720)        //720p above
 732   2                  pData[0] = 0x00;                    //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 733   2              //else
 734   2                  //pData[0] = 0x00;                  //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 735   2              pData[1] = 0x7E;                        //Peaking_C0 (126) 
 736   2              pData[2] = 0xF7;                        //Peaking_C1 (-19)  
 737   2              pData[3] = 0x4A;                        //Peaking_C2 (82)
 738   2              pData[4] = 0x00;                        //Gain_Blur
 739   2              pData[5] = (WORD)(ucPeaking*195)/100;       //Gain_Pos(Min~Max)
 740   2              pData[6] = (WORD)(ucPeaking*195)/100;       //Gain_Neg(Min~Max)
 741   2              pData[7] = 0x0F;                        //Pos_Range(MSB)+Neg_Range(MSB)
 742   2              pData[8] = 0x20;                        //Pos_Range(LSB)(1023)
 743   2              pData[9] = 0x40;                        //Neg_Range(LSB)(1023)
 744   2              pData[10] = 0x09;                   //Coring(LV_min~LV_max)     
 745   2          }       
 746   1          else if(_GET_INPUT_SOURCE() == _SOURCE_YPBPR||_GET_INPUT_SOURCE() == _SOURCE_YPBPR1)
 747   1          {
 748   2              //if(HDMI_V_Height>=720)        //720p above
 749   2                  pData[0] = 0x00;                    //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 750   2              //else
 751   2                  //pData[0] = 0x00;                  //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 752   2              pData[1] = 0x7E;                        //Peaking_C0 (126) 
 753   2              pData[2] = 0xF7;                        //Peaking_C1 (-19)  
 754   2              pData[3] = 0x4A;                        //Peaking_C2 (82)
 755   2              pData[4] = 0x00;                        //Gain_Blur
 756   2              pData[5] = (WORD)(ucPeaking*195)/100;       //Gain_Pos(Min~Max)
 757   2              pData[6] = (WORD)(ucPeaking*195)/100;       //Gain_Neg(Min~Max)
 758   2              pData[7] = 0x00;                        //Pos_Range(MSB)+Neg_Range(MSB)
 759   2              pData[8] = 0x20;                        //Pos_Range(LSB)(1023)
 760   2              pData[9] = 0x40;                        //Neg_Range(LSB)(1023)
 761   2              pData[10] = 0x0E;                   //Coring(LV_min~LV_max)         
 762   2          }   
 763   1          else
 764   1          {//AV SV TV
 765   2              pData[0] = 0x00;                        //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -           
 766   2              pData[1] = 126;      //Peaking_C0 (126) 
 767   2              pData[2] = 11;      //Peaking_C1 (-9)  
 768   2              pData[3] = 54;      //Peaking_C2 (74)
 769   2              pData[4] = 0x00;      //Gain_Blur
 770   2              pData[5] = (WORD)(ucPeaking*255)/100;  //Gain_Pos(Min~Max)
 771   2              pData[6] = (WORD)(ucPeaking*255)/100;  //Gain_Neg(Min~Max)
 772   2              pData[7] = 0x00;       //Pos_Range(MSB)+Neg_Range(MSB)
 773   2              pData[8] = 128;        //Pos_Range(LSB)(1023)
 774   2              pData[9] = 128;        //Neg_Range(LSB)(1023)
 775   2              pData[10] =  0x26;     //Coring(LV_min~LV_max)
 776   2          }   
 777   1              
 778   1          // D-Domain Peaking 
 779   1          CScalerPageSelect(_PAGE7);
 780   1          CScalerWrite(_P7_PEAKING_DATA00_AA, 11, pData, _AUTOINC);
 781   1      #if(_HDMI_SUPPORT == _OFF)
 782   1          if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
 783   1              CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);     // disable Peaking and Coring
 784   1          else
 785   1      #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 14  

                  if(_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI))// && !CHdmiFormatDetect(
             -)))//HDMI Source & input DVI timing
                      CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, 0x00);     // disable Peaking and Coring
                  else
              #endif
 790   1          {
 791   2              if (bSourceVideo())
 792   2              {
 793   3                  CScalerSetByte(_P7_DLTI_DCTI_ENABLE_A1, 0xC0);       //Open  D DOMAIN's DCTI, Open GAIN to 0xO
             -F
 794   3                  CScalerSetByte(_P7_DLTI_GAIN_A3, 0x05);              //DLTi_Gain
 795   3                  CScalerSetByte(_P7_DLTI_GAIN_THRESHOLD_A4, 0x01);    //DLTi_Gain_Threshold   0x1e
 796   3                  CScalerSetByte(_P7_DLTI_OPTIONS_A5, 0x70);           //DLTi_Options
 797   3                  CScalerSetByte(_P7_DCTI_1ST_GAIN_A6, 0x0F);          //Open GAIN to 0xOF
 798   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);    // enable Peaking and Coring
 799   3              }
 800   2              else
 801   2              {
 802   3                  CScalerSetBit(_P7_DLTI_DCTI_ENABLE_A1, ~(_BIT6 | _BIT7), 0x00);
 803   3                  CScalerSetBit(_P7_PEAKING_ENABLE_A9, ~_BIT3, _BIT3);    // enable Peaking and Coring
 804   3              }
 805   2          }
 806   1      
 807   1          switch(_GET_INPUT_SOURCE())
 808   1          {
 809   2          case _SOURCE_VGA:
 810   2              CScalerPageSelect(_PAGE6);
 811   2              CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00); // disable Peaking and Coring
 812   2              return;
 813   2      
 814   2          case _SOURCE_HDMI:
 815   2          case _SOURCE_DVI:
 816   2              //if(HDMI_V_Height>=720)        //720p above
 817   2                  pData[0] = 0x00;                    //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 818   2              //else
 819   2                  //pData[0] = 0x00;                  //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels  
             -    
 820   2              pData[1] = 0x7E;                        //Peaking_C0 (126) 
 821   2              pData[2] = 0xF7;                        //Peaking_C1 (-19)  
 822   2              pData[3] = 0x4A;                        //Peaking_C2 (82)
 823   2              pData[4] = 0x00;                        //Gain_Blur
 824   2              pData[5] = 0x14/*ucPeaking*13*/;        //Gain_Pos(Min~Max)
 825   2              pData[6] = 0x14/*ucPeaking*13*/;        //Gain_Neg(Min~Max)
 826   2              pData[7] = 0x0F;                        //Pos_Range(MSB)+Neg_Range(MSB)
 827   2              pData[8] = 0xFF;                        //Pos_Range(LSB)(80)
 828   2              pData[9] = 0xFF;                        //Neg_Range(LSB)(80)
 829   2              pData[10] = 0x09;                   //Coring(LV_min~LV_max)     
 830   2              break;
 831   2      
 832   2          case _SOURCE_YPBPR:
 833   2              pData[0] = 0x00;                    //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
             -         
 834   2              pData[1] = 0x7E;                        //Peaking_C0 (126) 
 835   2              pData[2] = 0xF7;                        //Peaking_C1 (-19)  
 836   2              pData[3] = 0x4A;                        //Peaking_C2 (82)
 837   2              pData[4] = 0x00;                        //Gain_Blur
 838   2              pData[5] = 0x14/*ucPeaking*13*/;        //Gain_Pos(Min~Max)
 839   2              pData[6] = 0x14/*ucPeaking*13*/;        //Gain_Neg(Min~Max)
 840   2              pData[7] = 0x0F;                        //Pos_Range(MSB)+Neg_Range(MSB)
 841   2              pData[8] = 0xFF;                        //Pos_Range(LSB)(1023)
 842   2              pData[9] = 0xFF;                        //Neg_Range(LSB)(1023)
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 15  

 843   2              pData[10] = 0x09;                   //Coring(LV_min~LV_max)         
 844   2              break;
 845   2          case _SOURCE_YPBPR1:
 846   2              pData[0] = 0x00;                    //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
             -         
 847   2              pData[1] = 0x7E;                        //Peaking_C0 (126) 
 848   2              pData[2] = 0xF7;                        //Peaking_C1 (-19)  
 849   2              pData[3] = 0x4A;                        //Peaking_C2 (82)
 850   2              pData[4] = 0x00;                        //Gain_Blur
 851   2              pData[5] = 0x14/*ucPeaking*13*/;        //Gain_Pos(Min~Max)
 852   2              pData[6] = 0x14/*ucPeaking*13*/;        //Gain_Neg(Min~Max)
 853   2              pData[7] = 0x0F;                        //Pos_Range(MSB)+Neg_Range(MSB)
 854   2              pData[8] = 0xFF;                        //Pos_Range(LSB)(1023)
 855   2              pData[9] = 0xFF;                        //Neg_Range(LSB)(1023)
 856   2              pData[10] = 0x09;                   //Coring(LV_min~LV_max)         
 857   2              break;
 858   2      
 859   2          default:   //AV TV SV       
 860   2                  pData[0] = 0x00;     //bit[3:2]->10: 9 pixels; ->01: 7 pixels; ->00: 5 pixels      
 861   2                  pData[1] = 127;      //Peaking_C0 (126) 
 862   2                  pData[2] = 74;      //Peaking_C1 (11)  
 863   2                  pData[3] = 0xF6;      //Peaking_C2 (-10)
 864   2                  pData[4] = 0x00;      //Gain_Blur
 865   2                  pData[5] = 128;      //Gain_Pos(Min~Max)
 866   2                  pData[6] = 128;      //Gain_Neg(Min~Max)
 867   2                  pData[7] = 0x00;      //Pos_Range(MSB)+Neg_Range(MSB)
 868   2                  pData[8] = 20;      //Pos_Range(LSB)(1023)
 869   2                  pData[9] = 20;       //Neg_Range(LSB)(1023)
 870   2                  pData[10] =  4 ;     //Coring(LV_min~LV_max)
 871   2              break;
 872   2          }
 873   1      
 874   1          // I-Domain Peaking 
 875   1          CScalerPageSelect(_PAGE6);
 876   1          CScalerWrite(_P6_PEAKING_DATA00_C2, 11, pData, _AUTOINC);
 877   1      #if(_HDMI_SUPPORT == _OFF)
 878   1          if(_GET_INPUT_SOURCE()==_SOURCE_DVI)//HDMI Source & input DVI timing
 879   1              CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);     // disable Peaking and Coring
 880   1          else
 881   1      #elif(_HDMI_SUPPORT == _ON || _TMDS_SUPPORT == _ON)
                  //if(_GET_INPUT_SOURCE()==_SOURCE_DVI || (_GET_INPUT_SOURCE() == _SOURCE_HDMI && !CHdmiFormatDetect())
             -)//HDMI Source & input DVI timing
                  if((_GET_INPUT_SOURCE()==_SOURCE_DVI || _GET_INPUT_SOURCE() == _SOURCE_HDMI) && !CHdmiFormatDetect())/
             -/HDMI Source & input DVI timing
                      CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, 0x00);     // disable Peaking and Coring
                  else
              #endif
 887   1          {
 888   2              if (bSourceVideo())
 889   2              {
 890   3                              if (ucVideoType == ZNTSC || ucVideoType == ZNTSC_443 || ucVideoType == ZNTSC_50)
 891   3                                      CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x0f);  //Close  I DOMAIN's DCTI,Open GAIN to 0xOF
 892   3                              else
 893   3                                      CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x8f);  //Open  I DOMAIN's DCTI,Open GAIN to 0xOF
 894   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x02);
 895   3                  CScalerSetByte(_P6_PEAKING_ENABLE_C1, 0x00);            // disable Peaking and Coring
 896   3              }
 897   2              else
 898   2              {
 899   3                  CScalerSetByte(_P6_DCTI_1ST_GAIN_D8, 0x4A);
 900   3                  CScalerSetByte(_P6_SPATIAL_CTRL_DB, 0x00);
 901   3                  CScalerSetBit(_P6_PEAKING_ENABLE_C1, ~_BIT3, _BIT3);    // enable Peaking and Coring
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 16  

 902   3              }
 903   2          }
 904   1      }
 905              
 906          #else
              
              #if(_Peaking_Coring_Table == SharpnessTable1)
                                                                                                                  
              BYTE code PeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                      0x30, 0xe5, 0x3, 0x5, 0x50, 0xb0,
                      //level=2 :
                      0x38, 0xe1, 0x3, 0x5, 0x50, 0xb0,
                      //level=3 :
                      0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                      //level=4 :
                      0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                      //level=5 :
                      0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                      //level=6 :
                      0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                      //level=7 :
                      0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                      //level=8 :
                      0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
                      //level=9 :
                      0x6e, 0xc1, 0x8, 0x5, 0x50, 0xb0,
                      //level=10 :
                      0x76, 0xbc, 0x9, 0x5, 0x50, 0xb0,
                      //level=11 :
                      0x40, 0xdc, 0x4, 0x5, 0x50, 0xb0,
                      //level=12 :
                      0x46, 0xd7, 0x6, 0x5, 0x50, 0xb0,
                      //level=13 :
                      0x4e, 0xd3, 0x6, 0x5, 0x50, 0xb0,
                      //level=14 :
                      0x56, 0xce, 0x7, 0x5, 0x50, 0xb0,
                      //level=15 :
                      0x5e, 0xca, 0x7, 0x5, 0x50, 0xb0,
                      //level=16 :
                      0x66, 0xc5, 0x8, 0x5, 0x50, 0xb0,
              
              };
              
              BYTE code TVPeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=0 :
                      0x0, 0x0, 0x0, 0x14, 0x50, 0xb0,
                      //level=1 :
                      0x4, 0x1, 0xfd, 0x16, 0x50, 0xb0,
                      //level=2 :
                      0x6, 0x2, 0xfb, 0x18, 0x50, 0xb0,
                      //level=3 :
                      0xa, 0x3, 0xf8, 0x1a, 0x50, 0xb0,
                      //level=4 :
                      0xc, 0x5, 0xf5, 0x1c, 0x50, 0xb0,
                      //level=5 :
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 17  

                      0x10, 0x6, 0xf2, 0x1e, 0x50, 0xb0,
                      //level=6 :
                      0x12, 0x7, 0xf0, 0x1f, 0x50, 0xb0,
                      //level=7 :
                      0x16, 0x8, 0xed, 0x1f, 0x50, 0xb0,
                      //level=8 :
                      0x1a, 0xa, 0xe9, 0x1f, 0x50, 0xb0,
                      //level=9 :
                      0x1c, 0xb, 0xe7, 0x1f, 0x50, 0xb0,
                      //level=10 :
                      0x20, 0xc, 0xe4, 0x1f, 0x50, 0xb0,
                      //level=11 :
                      0x22, 0xd, 0xe2, 0x1f, 0x50, 0xb0,
                      //level=12 :
                      0x26, 0xf, 0xde, 0x1f, 0x50, 0xb0,
                      //level=13 :
                      0x2c, 0x11, 0xd9, 0x1f, 0x50, 0xb0,
                      //level=14 :
                      0x32, 0x14, 0xd3, 0x1f, 0x50, 0xb0,
                      //level=15 :
                      0x38, 0x16, 0xce, 0x1f, 0x50, 0xb0,
                      //level=16 :
                      0x3e, 0x19, 0xc8, 0x1f, 0x50, 0xb0,
              };
              
              #elif(_Peaking_Coring_Table == SharpnessTable2)
              
              BYTE code PeakingCoeff[][6] =
              {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                      0x08, 0x00, 0xFC, 0x00, 0x28, 0xF8,
                      //level=2 :
                      0x0C, 0x00, 0xFA, 0x00, 0x28, 0xF8,
                      //level=3 :
                      0x10, 0x00, 0xF8, 0x00, 0x28, 0xF8,
                      //level=4 :
                          0x18, 0x00, 0xF4, 0x00, 0x28, 0xF8, //3
                      //level=5 :
                      0x20, 0x00, 0xF0, 0x00, 0x28, 0xF8,
                      //level=6 :
                      0x28, 0x00, 0xEC, 0x00, 0x28, 0xF8,
                      //level=7 :
                      0x30, 0x00, 0xE8, 0x00, 0x28, 0xF8,
                      //level=8 :
                      0x38, 0x00, 0xE4, 0x00, 0x28, 0xF8,
                      //level=9 :
                      0x40, 0x00, 0xE0, 0x00, 0x28, 0xF8,
                      //level=10 :
                      0x46, 0x00, 0xDD, 0x00, 0x28, 0xF8,
                      //level=11 :
                      0x4E, 0x00, 0xD9, 0x00, 0x28, 0xF8,
                      //level=12 :
                      0x56, 0x00, 0xD5, 0x00, 0x28, 0xF8,
                      //level=13 :
                      0x5E, 0x00, 0xD1, 0x00, 0x28, 0xF8,
                      //level=14 :
                      0x66, 0x00, 0xCD, 0x00, 0x28, 0xF8,
                      //level=15 :
                      0x6E, 0x00, 0xC9, 0x00, 0x28, 0xF8,
                      //level=16 :
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 18  

                      0x76, 0x00, 0xC5, 0x00, 0x28, 0xF8,
              };
              
              
              BYTE code TVPeakingCoeff[][6] =
               {
                      //Peaking_Coef0,  Peaking_Coef1,  Peaking_Coef2,  Coring_Min,  Coring_Max_Pos,  Coring_Max_Neg ,
              
                      //level=1 :
                       0x08, 0x00, 0xFC, 0x12, 0x60, 0xF8,
                      //level=2 :
                       0x0A, 0x00, 0xFB,  0x12, 0x60, 0xF8,
                      //level=3 :
                       0x0C, 0x00, 0xFA,  0x12, 0x60, 0xF8,
                      //level=4 :
                       0x0E, 0x00, 0xF9,  0x12, 0x60, 0xF8,
                      //level=5 :
                       0x10, 0x00, 0xF8,  0x12, 0x60, 0xF8,
                      //level=6 :
                       0x12, 0x00, 0xF7,  0x12, 0x60, 0xF8,
                      //level=7 :
                       0x14, 0x00, 0xF6,  0x12, 0x60, 0xF8,
                      //level=8 :
                       0x16, 0x00, 0xF5,  0x12, 0x60, 0xF8,
                      //level=9 :
                           0x18, 0x00, 0xF4,  0x12, 0x60, 0xF8,
                      //level=10 :
                       0x1A, 0x00, 0xF3,  0x12, 0x60, 0xF8,
                      //level=11 :
                       0x1C, 0x00, 0xF2,  0x12, 0x60, 0xF8,
                      //level=12 :
                       0x1E, 0x00, 0xF1,  0x12, 0x60, 0xF8,
                      //level=13 :
                       0x20, 0x00, 0xF0,  0x12, 0x60, 0xF8,
                      //level=14 :
                       0x22, 0x00, 0xEF,  0x12, 0x60, 0xF8,
                       //level=15 :
                       0x24, 0x00, 0xEE,  0x12, 0x60, 0xF8,
                      //level=16 :
                       0x26, 0x00, 0xED,  0x12, 0x60, 0xF8,
              };
              #endif
              //----------------------------------------------------
              // CAdjustPeakingFilter
              // Adjust Peaking Filter and Coring Control
              // @param <Coefficient C0 of Peaking Filter>
              // @return {none}
              //----------------------------------------------------
                          
              void CAdjustPeakingFilter(SBYTE ucPeaking)
              {
              #if (_Peaking_Coring_Table != SharpnessNoneTable)//reference Table
                  if((_GET_INPUT_SOURCE()==_SOURCE_VGA)||(_GET_INPUT_SOURCE()==_SOURCE_DVI) || (_GET_INPUT_SOURCE() == _
             -SOURCE_HDMI))
                  {
                      CScalerPageSelect(_PAGE7);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x00);
              
                      return;
                  }
                  else
                  {
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 19  

              
                      if(_GET_INPUT_SOURCE() == _SOURCE_VIDEO_TV)
                      {
                          pData[0] = TVPeakingCoeff[ucPeaking][0];
                          pData[1] = TVPeakingCoeff[ucPeaking][1];
                          pData[2] = TVPeakingCoeff[ucPeaking][2];
                          pData[3] = TVPeakingCoeff[ucPeaking][3];
                          pData[4] = TVPeakingCoeff[ucPeaking][4];
                          pData[5] = TVPeakingCoeff[ucPeaking][5];
              
                      }
                      else
                      {
                          pData[0] = PeakingCoeff[ucPeaking][0];
                          pData[1] = PeakingCoeff[ucPeaking][1];
                          pData[2] = PeakingCoeff[ucPeaking][2];
                          pData[3] = PeakingCoeff[ucPeaking][3];
                          pData[4] = PeakingCoeff[ucPeaking][4];
                          pData[5] = PeakingCoeff[ucPeaking][5];
                      }
              
                      CScalerPageSelect(_PAGE7);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                      CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                      CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
              
                  }
              
              #else//default
              
                  if((_GET_INPUT_SOURCE() == _SOURCE_VGA)||(_GET_INPUT_SOURCE() == _SOURCE_DVI) || (_GET_INPUT_SOURCE() 
             -== _SOURCE_HDMI))
                      ucPeaking = ucPeaking * 2;
                  else
                      ucPeaking = ucPeaking * 8;
              
                  if(ucPeaking > 126)
                      ucPeaking = 126;
                  if(ucPeaking < 14 && ucPeaking > 0)
                      ucPeaking = 14;
                      
                  pData[0] = ((ucPeaking +1) >> 1) << 1;
                  if((bit)(ucPeaking & 0x01))
                  {
                      pData[1] = (SWORD)-72 * pData[0] / 126;
                      pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                  }
                  else
                  {
                      pData[1] = (SWORD)-73 * pData[0] / 126;
                      pData[2] = (SWORD)-(pData[0] + 2*pData[1]) / 2;
                  }
              
                  pData[3] = (BYTE)_CORING_MIN;
                  pData[4] = (BYTE)_CORING_MAX_POS;
                  pData[5] = (SBYTE)_CORING_MAX_NEG;
                  CScalerPageSelect(_PAGE7);
                  CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x80);
                  CScalerWrite(_P7_PC_DATA_PORT_D7, 6, pData, _NON_AUTOINC);
                  CScalerSetByte(_P7_PC_ACCESS_PORT_D6, 0x40);
              
              #endif
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 20  

              }
              
              
              #endif
1152          
1153          //--------------------------------------------------
1154          // Description  : Adjust sharpness
1155          // Input Value  : None
1156          // Output Value : None
1157          //--------------------------------------------------
1158          void CAdjustPeakingCoding(void)
1159          {
1160   1          CAdjustPeakingFilter(GET_PEAKING_CORING());
1161   1      }
1162          
1163          void CAdjustVolume(void)
1164          {
1165   1          BYTE iVolume;
1166   1      
1167   1          iVolume = (WORD)(_MAX_VOLUME - _MIN_VOLUME) * stAudioData.Volume/ 100;
1168   1      
1169   1          if(_VOLUME_INV == 0)
1170   1              iVolume = _MAX_VOLUME - iVolume;
1171   1          else
1172   1              iVolume = _MIN_VOLUME + iVolume;
1173   1            
1174   1          CSetPWM(bVOLUME_PWM,iVolume);
1175   1      }
1176          
1177          //--------------------------------------------------
1178          // Description  : Adjust backlight
1179          // Input Value  : None
1180          // Output Value : None
1181          //--------------------------------------------------
1182          void CAdjustBacklight(void)
1183          {
1184   1      #if(_BACKLIGHT_USE_FAC_ADJ == _DISABLE)
1185   1      
1186   1          BYTE ucLight;
1187   1      
1188   1          ucLight = (WORD)(_BACKLIGHT_MAX - _BACKLIGHT_MIN) * stConBriData.Brightness/100;
1189   1      
1190   1       #if(_BACKLIGHT_PWM_INVERSE == _ENABLE)
              
                  ucLight = _BACKLIGHT_MAX - ucLight;
               #else
1194   1      
1195   1          ucLight = _BACKLIGHT_MIN + ucLight;
1196   1      
1197   1       #endif
1198   1      
1199   1          CSetPWM(_BACKLIGHT_PWM, ucLight);
1200   1      
1201   1      #else
              
                  BYTE ucLight;
              
                  ucLight = (BYTE)((WORD)(255) * stSystemData.BackLight/100);
              
                      CSetPWM(_BACKLIGHT_PWM, ucLight);
              #endif
1209   1      }
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 21  

1210          //--------------------------------------------------
1211          void CAdjustGammaTable(BYTE index)
1212          {
1213   1          index = index;
1214   1      #if(_GAMMA_TYPE ==  _FULL_GAMMA_NORMAL_TABLE)
                  switch(index)
                  {
                  case 1:
                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
                      break;
              
                  case 2:
                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
                      break;
              
                  case 3:
                      CAdjustGamma(_FULL_GAMMA_NORMAL_TABLE, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
                      break;
              
                  case 0:
                      CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
                      break;
              
                  default:
                      break;
                  }
                  
              #elif(_GAMMA_TYPE == _FULL_GAMMA_COMPRESS_TABLE2)
              
                  switch(index)
                  {
                  case 0:     // disable Gamma
                      CScalerSetBit(_GAMMA_CTRL_67, ~_BIT6, 0x00);
                      break;
              
                  case 1:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_1_R, GAMMA_1_G, GAMMA_1_B);
                      break;
              
                  case 2:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_2_R, GAMMA_2_G, GAMMA_2_B);
                      break;
              
                  case 3:
                      CAdjustGamma(_FULL_GAMMA_COMPRESS_TABLE2, GAMMA_3_R, GAMMA_3_G, GAMMA_3_B);
                      break;
                  
                  default:
                      break;
                  }
              #endif
1261   1      }
1262          
1263          
1264          #if(sRGB_Color_Enhance == _ENABLE)
1265          //Use sRGB to adjust Saturation and Hue
1266          void CAdjustSaturationHue(BYTE  ucValue, BOOL bSaturationIndex)
1267          {
1268   1      //Lewis, this table have multiplied by 1024
1269   1          INT16 code YUV2RGB[3][3] =
1270   1          {
1271   1            {1024,   0,      1436},
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 22  

1272   1            {1024,   -342,   -731},
1273   1            {1024,   1815,   0}
1274   1           };
1275   1      
1276   1      //Lewis, this table have multiplied by 1024
1277   1          INT16 code RGB2YUV[3][3] =
1278   1          {
1279   1              {306,     601,   117},
1280   1            {-173,   -339,    512},
1281   1              {512,   -429,   -83}
1282   1           };
1283   1      
1284   1          BYTE i, j;
1285   1          INT16 temp_buff0[3][3];
1286   1          //731401***
1287   1          //INT16 temp_buff1[3][3];
1288   1          //INT16 temp_buff2[3][3];
1289   1          INT16 MATRIX_GAIN_HUE[3][3];
1290   1          //INT16 MATRIX_GAIN[3][3];
1291   1          //INT16 MATRIX_HUE[3][3];
1292   1          //731401###
1293   1          INT16 temp_hue, temp_saturation;
1294   1      
1295   1      
1296   1          if(bSaturationIndex == _TRUE) //adjust saturation
1297   1          {
1298   2              temp_saturation=(INT16)ucValue;
1299   2              temp_hue=(INT16)GET_HUE() - 50;
1300   2          }
1301   1          else
1302   1          {
1303   2              temp_saturation = (INT16)GET_SATURATION();
1304   2              temp_hue=(INT16)ucValue - 50;
1305   2          }
1306   1      
1307   1          //Lewis 20060717, to prevent adjust CSC matrix, the saturation overflow
1308   1          if(temp_saturation>75)
1309   1              temp_saturation = 75;
1310   1          else if(temp_saturation<25)
1311   1              temp_saturation = 25;
1312   1      
1313   1          temp_hue = temp_hue*19>>5; //Lewis, 20060720, limited Hue range to prevent grey bar have color
1314   1      //731401***
1315   1      //Lewis, this table have multiplied by 1024
1316   1          MATRIX_GAIN_HUE[0][0] = 1024;
1317   1          MATRIX_GAIN_HUE[0][1] = 0;
1318   1          MATRIX_GAIN_HUE[0][2] = 0;
1319   1          MATRIX_GAIN_HUE[1][0] = 0;
1320   1          MATRIX_GAIN_HUE[1][1] = ((temp_saturation<<7)/25)<<2;
1321   1          MATRIX_GAIN_HUE[1][2] = 0;
1322   1          MATRIX_GAIN_HUE[2][0] = 0;
1323   1          MATRIX_GAIN_HUE[2][1] = 0;
1324   1          MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1];
1325   1      
1326   1          CAdjustMatrixMultiply(MATRIX_GAIN_HUE,RGB2YUV,temp_buff0);
1327   1          
1328   1      //Lewis, this table have multiplied by 1024
1329   1          MATRIX_GAIN_HUE[0][0] = 1024;
1330   1          MATRIX_GAIN_HUE[0][1] = 0;
1331   1          MATRIX_GAIN_HUE[0][2] = 0;
1332   1          MATRIX_GAIN_HUE[1][0] = 0;
1333   1          MATRIX_GAIN_HUE[1][1] = CAdjustCosine(temp_hue);
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 23  

1334   1          MATRIX_GAIN_HUE[1][2] = CAdjustSine(temp_hue);
1335   1          MATRIX_GAIN_HUE[2][0] = 0;
1336   1          MATRIX_GAIN_HUE[2][1] = (-1)*MATRIX_GAIN_HUE[1][2];//-CAdjustSine(temp);
1337   1          MATRIX_GAIN_HUE[2][2] = MATRIX_GAIN_HUE[1][1]; //CAdjustCosine(temp);
1338   1      
1339   1      
1340   1          CAdjustMatrixMultiply(MATRIX_GAIN_HUE,temp_buff0,temp_buff0);
1341   1          CAdjustMatrixMultiply(YUV2RGB,temp_buff0,temp_buff0);
1342   1      
1343   1          for(i=0; i<3; i++)
1344   1          {
1345   2              for(j=0; j<3; j++)
1346   2              {
1347   3                  if (i==j)
1348   3                     temp_buff0[i][j]-=1024;
1349   3          
1350   3                  temp_buff0[i][j] = temp_buff0[i][j]>>1;
1351   3          
1352   3                  if (temp_buff0[i][j]>255)
1353   3                      temp_buff0[i][j] = 255;
1354   3                  else if(temp_buff0[i][j]<-256)
1355   3                      temp_buff0[i][j] = -256;
1356   3              }
1357   2          }
1358   1      
1359   1          //Write R
1360   1          //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x08);
1361   1          pData[0] =(temp_buff0[0][0]<0?1:0);
1362   1          pData[1]=(BYTE)(temp_buff0[0][0]);
1363   1          pData[2] =(temp_buff0[0][1]<0?1:0);
1364   1          pData[3]=(BYTE)(temp_buff0[0][1]);
1365   1          pData[4] =(temp_buff0[0][2]<0?1:0);
1366   1          pData[5]=(BYTE)(temp_buff0[0][2]);
1367   1      
1368   1      //  CAdjustSetsRGBRhue();
1369   1          CAdjustSetYpbprRhue();
1370   1      
1371   1          //Write G
1372   1          //frank CScalerSetBit(_COLOR_CTRL_62,0xc7,0x10);
1373   1      
1374   1          pData[0] =(temp_buff0[1][0]<0?1:0);
1375   1          pData[1]=(BYTE)(temp_buff0[1][0]);
1376   1          pData[2] =(temp_buff0[1][1]<0?1:0);
1377   1          pData[3]=(BYTE)(temp_buff0[1][1]);
1378   1          pData[4] =(temp_buff0[1][2]<0?1:0);
1379   1          pData[5]=(BYTE)(temp_buff0[1][2]);
1380   1      
1381   1      //  CAdjustSetsRGBGhue();
1382   1          CAdjustSetYpbprGhue();
1383   1      
1384   1          //Write B
1385   1      
1386   1          pData[0] =(temp_buff0[2][0]<0?1:0);
1387   1          pData[1]=(BYTE)(temp_buff0[2][0]);
1388   1          pData[2] =(temp_buff0[2][1]<0?1:0);
1389   1          pData[3]=(BYTE)(temp_buff0[2][1]);
1390   1          pData[4] =(temp_buff0[2][2]<0?1:0);
1391   1          pData[5]=(BYTE)(temp_buff0[2][2]);
1392   1      //731401###
1393   1      //  CAdjustSetsRGBBhue();
1394   1          CAdjustSetYpbprBhue();
1395   1      
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 24  

1396   1          CScalerSetBit(_COLOR_CTRL_62, 0xff, 0x80);          // cftsai 20061031 added, ready to write
1397   1      }
1398          
1399          INT16 CAdjustCosine(INT16 fDegree)
1400          {
1401   1          //Lewis, the curve value table have multiplied by 1024
1402   1          UINT16 code fCosCurveAngle[13] = {   0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1403   1          UINT16 code fCosCurveValue[13] = {1024, 1018, 1002, 974, 935, 887, 818, 737, 630, 512, 384, 213,  0};
1404   1          UINT8 i,cQuadrant;
1405   1          INT16 fDegreeTemp, fDegreeSpan, fCosValueSpan, fCosValue;
1406   1      
1407   1          if (fDegree < 0)
1408   1              fDegree += 360;
1409   1      
1410   1          fDegree = fDegree%360;
1411   1      
1412   1          //locate degree on which quadrant
1413   1          cQuadrant = (UINT8)(fDegree / 90);
1414   1          cQuadrant++;
1415   1          if (cQuadrant==1) //first quadrant
1416   1              fDegree = fDegree;
1417   1          else if(cQuadrant==2) //second quadrant
1418   1              fDegree = 180 - fDegree;
1419   1          else if(cQuadrant==3) //third quadrant
1420   1              fDegree = fDegree - 180;
1421   1          else if(cQuadrant==4) //forth quadrant
1422   1              fDegree = 360 -fDegree;
1423   1          //locate degree on which quadrant
1424   1      
1425   1          if (fDegree<=fCosCurveAngle[0])
1426   1              fCosValue = fCosCurveValue[0];
1427   1          else
1428   1          {
1429   2              for (i=0;fCosCurveAngle[i] < fDegree; i++);
1430   2      
1431   2              i--;
1432   2              fDegreeTemp = fDegree-fCosCurveAngle[i];
1433   2              fDegreeSpan = fCosCurveAngle[i+1]-fCosCurveAngle[i];
1434   2              fCosValueSpan = fCosCurveValue[i+1]-fCosCurveValue[i];
1435   2              fCosValue = fCosCurveValue[i]+fDegreeTemp*fCosValueSpan/fDegreeSpan;
1436   2          }
1437   1      
1438   1          if (cQuadrant==2 || cQuadrant==3)
1439   1              fCosValue = fCosValue*(-1);
1440   1      
1441   1          return fCosValue;
1442   1      }
1443          
1444          INT16 CAdjustSine(INT16 fDegree)
1445          {
1446   1          //Lewis, this table have multiplied by 1024
1447   1          UINT16 code fSinCurveAngle[13] = {0,   6,  12,  18,  24,  30,  37,  44,  52,  60,  68,  78, 90};
1448   1          UINT16 code fSinCurveValue[13] = {0, 107, 213, 316, 416, 512, 616, 711, 807, 887, 949, 1002,  1024};
1449   1          UINT8 i,cQuadrant;
1450   1          INT16 fDegreeTemp,fDegreeSpan,fSinValueSpan,fSinValue;
1451   1      
1452   1          if (fDegree < 0)
1453   1              fDegree += 360;
1454   1      
1455   1          fDegree = fDegree%360;
1456   1      
1457   1          //locate degree on which quadrant
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 25  

1458   1          cQuadrant = (UINT8)(fDegree / 90);
1459   1          cQuadrant++;
1460   1          if (cQuadrant==1) //first quadrant
1461   1              fDegree = fDegree;
1462   1          else if(cQuadrant==2) //second quadrant
1463   1              fDegree = 180 - fDegree;
1464   1          else if(cQuadrant==3) //third quadrant
1465   1              fDegree = fDegree - 180;
1466   1          else if(cQuadrant==4) //forth quadrant
1467   1              fDegree = 360 -fDegree;
1468   1          //locate degree on which quadrant
1469   1      
1470   1          if (fDegree<=fSinCurveAngle[0])
1471   1              fSinValue = fSinCurveValue[0];
1472   1          else
1473   1          {
1474   2              for (i=0;fSinCurveAngle[i] < fDegree; i++);
1475   2      
1476   2              i--;
1477   2              fDegreeTemp = fDegree-fSinCurveAngle[i];
1478   2              fDegreeSpan = fSinCurveAngle[i+1]-fSinCurveAngle[i];
1479   2              fSinValueSpan = fSinCurveValue[i+1]-fSinCurveValue[i];
1480   2              fSinValue = fSinCurveValue[i]+fDegreeTemp*fSinValueSpan/fDegreeSpan;
1481   2          }
1482   1      
1483   1          if (cQuadrant==3 || cQuadrant==4)
1484   1              fSinValue = fSinValue*(-1);
1485   1      
1486   1          return fSinValue;
1487   1      }
1488          
1489          void CAdjustMatrixMultiply(INT16 (*arrayA)[3], INT16 (*arrayB)[3], INT16 (*arrayC)[3])
1490          {
1491   1          BYTE i, j;
1492   1          INT32 Temp[3][3];
1493   1      
1494   1          for(i=0; i<3; i++)
1495   1          {
1496   2              for(j=0; j<3; j++)
1497   2              {
1498   3                  Temp[i][j] = ((INT32)arrayA[i][0]*arrayB[0][j]>>2)
1499   3                              + ((INT32)arrayA[i][1]*arrayB[1][j]>>2)
1500   3                              + ((INT32)arrayA[i][2]*arrayB[2][j]>>2);
1501   3      
1502   3                  //arrayC[i][j] = (INT16)(Temp[i][j]>>8);//731401
1503   3              }
1504   2          }
1505   1      
1506   1          for(i=0; i<3; i++)
1507   1          {
1508   2              for(j=0; j<3; j++)
1509   2              {
1510   3                  arrayC[i][j] = (INT16)(Temp[i][j]>>8);
1511   3              }
1512   2          }
1513   1      
1514   1      }
1515          
1516          #endif
1517          
1518          
1519          
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 26  

1520          BYTE code SatPlus[8]  = { 41, 44, 43, 39, 31, 22, 11, 0 }; // by 1/256
1521          BYTE code SatMinus[8] = { 24, 35, 40, 41, 36, 28, 16, 0 }; // by 1/256
1522          
1523          int CAdjustColorGammaCal(BYTE color, BYTE n) // n = 1~8
1524          {
1525   1          BYTE temp;
1526   1      
1527   1          if (color == 0)     //R
1528   1              temp = GET_ICM_SAT_R();
1529   1          else if (color== 1) //G
1530   1              temp = GET_ICM_SAT_G();
1531   1          else if (color == 2)//B
1532   1              temp = GET_ICM_SAT_B();
1533   1          else if (color == 3)//Y
1534   1              temp = GET_ICM_SAT_Y();
1535   1          else if (color == 4)//C
1536   1              temp = GET_ICM_SAT_C();
1537   1          temp *= 2;  //Since the scale for OSD(from 0~16) and cloor(from 0~32) is different, we will have to mu
             -ltiply
1538   1                     //temp by 2 to make up the difference
1539   1          if (temp >= 16)
1540   1          {
1541   2              return ((int)(512*n) + (int)((temp-16)*(int)SatPlus[n-1])) / 64 ;
1542   2          }
1543   1          else
1544   1          {
1545   2              return ((int)(512*n) - (int)((16-temp)*(int)SatMinus[n-1])) / 64 ;
1546   2          }
1547   1      }
1548          
1549          #define CENTER    0x00
1550          #define RIGHT     0x10
1551          #define LEFT      0x20
1552          
1553          void CAdjustMZHueSat(BYTE color)
1554          {
1555   1          //Value  0~4095 => angle 0~359
1556   1          //R / G / B / Y /C
1557   1          //range  256 => 22.5  degree
1558   1          //buffer 128 => 11.25 degree
1559   1          //R / G / B
1560   1          //range  512 => 45    degree
1561   1          //buffer 128 => 11.25 degree
1562   1          CTimerWaitForEvent(_EVENT_DEN_STOP);
1563   1          CAdjustSetHueUVDelta(color, CENTER);
1564   1          CAdjustSetHueUVDelta(color, RIGHT);
1565   1          CAdjustSetHueUVDelta(color, LEFT);
1566   1      
1567   1          CScalerPageSelect(_PAGE7);
1568   1          CScalerSetBit(_P7_ICM_CTRL_D0, ~_BIT7, _BIT7);
1569   1      
1570   1      }
1571          
1572          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3917    ----
   CONSTANT SIZE    =    156    ----
   XDATA SIZE       =   ----     135
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V7.06   ADJUST_CUSTOMER                                                       04/29/2010 18:06:03 PAGE 27  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

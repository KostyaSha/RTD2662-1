C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE LCD_FUNC
OBJECT MODULE PLACED IN .\Output\Lcd_func.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Code\Lcd_func.c OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND CODE SYMBOLS PR
                    -INT(.\Output\Lcd_func.lst) PREPRINT(.\Output\Lcd_func.i) OBJECT(.\Output\Lcd_func.obj)

stmt level    source

   1          #define __FUNC__
   2          
   3          #include "reg52.h"
   4          #include "intrins.h"
   5          
   6          #include "Header\MAIN_DEF.H"
   7          #include "Header\MTV512.H"
   8          #include "Header\CONFIG.H"
   9          #include "Header\ACCESS.H"
  10          #include "Header\OSD.H"
  11          #include "Header\LCD_COEF.H"
  12          #include "Header\LCD_MAIN.H"
  13          #include "Header\LCD_AUTO.H"
  14          #include "Header\LCD_FUNC.H"
  15          #include "Header\FRAME_SYNC.H"
  16          #include "Header\LCD_OSD.H"
  17          
  18          // val =1 open sound,val = 0 close sound
  19          void SetMute(bit val)
  20          {
  21   1      //anson MTV 512
  22   1              if(val == 0)   //關聲音
  23   1              {
  24   2                      bMUTE = 0;                      // 1 : On   0 : Off
  25   2                      bSTANDBY = 1;
  26   2              }
  27   1              else            //開聲音
  28   1              {
  29   2                      bMUTE = 1;
  30   2                      bSTANDBY = 0;
  31   2              }
  32   1      
  33   1      //anson Tp2804
  34   1      /*
  35   1              if(val == 1)
  36   1              {
  37   1                      bMUTE = 0;                      // 1 : Off   0 : On
  38   1                      bSTANDBY = 0;
  39   1              }
  40   1              else 
  41   1              {
  42   1                      bMUTE = 1;
  43   1                      bSTANDBY = 1;
  44   1              }
  45   1      */
  46   1      }
  47          
  48          #if (TV_CHIP != TV_NONE)
              #include "TUNER.H"
              #endif
  51          
  52          void SetVolume()
  53          {
  54   1          stGUD3.VOLUME   &= 0x1f;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 2   

  55   1      
  56   1      #if (AUDIO_TYPE == AUDIO_LM4832)
                  Data[0] = 10;
                  Data[1] = ADDR_LM4832;
                  Data[2] = 0x00;
                  Data[3] = 0x02;
                  Data[4] = 0x00;                     // Input Volume - 0 dB
                  Data[5] = 0x26;                     // Bass         - 0 dB
                  Data[6] = 0x46;                     // Treble       - 0 dB
                  Data[7] = 0x60 | stGUD3.VOLUME;     // Right Volume
                  Data[8] = 0x80 | stGUD3.VOLUME;     // Left Volume
              
                  // Mic 1 selected with 20dB when input source is VGA or DVI
                  // Both Mic 1 and 2 selected with 20dB when input source is AV or S-Video
                  Data[9] = (SOURCE_AV <= (stGUD1.INPUT_SOURCE & 0x07)) ? 0xa6 : 0xa4;
                  
                  I2CWrite(Data);
              #endif
  73   1      
  74   1      #if (AUDIO_TYPE == AUDIO_PWM2)
                  Data[0] = 6;
                  Data[1] = Y_INC;
                  Data[2] = OSD_ROW_90;
                  Data[3] = 0x80;
                  Data[4] = 0x01;
              #if (INV_VOLUME)
                  Data[5] = (0xff -(stGUD3.VOLUME << 3));
              #else
                      Data[5] = (stGUD3.VOLUME << 3);
              #endif
                      Data[6] = 0;
                  RTDWrite(Data);
              #endif
  88   1      
  89   1      
  90   1      #if (AUDIO_TYPE == AUDIO_PWM0)
  91   1      
  92   1          Data[0] = 6;
  93   1          Data[1] = Y_INC;
  94   1          Data[2] = OSD_ROW_90;
  95   1          Data[3] = 0x00;
  96   1          Data[4] = 0x01;
  97   1      #if (INV_VOLUME)
                  Data[5] = (0xff -(stGUD3.VOLUME << 3));
              #else
 100   1              Data[5] = (stGUD3.VOLUME << 3);
 101   1      #endif
 102   1              Data[6] = 0;
 103   1          RTDWrite(Data);
 104   1      #endif
 105   1      }
 106          
 107          void WriteGamma(unsigned char code *arrayR, unsigned char code *arrayG, unsigned char code *arrayB)
 108          {
 109   1          unsigned char   n   = 0;
 110   1      
 111   1          RTDSetBit(COLOR_CTRL_5D, 0xfb, 0x10);   // Disable GAMMA & Enable Access Channel
 112   1          
 113   1      
 114   1          // GAMMA_RED
 115   1          bRTD_SCSB   = 0;
 116   1          RTDSendAddr(RED_GAMMA_64, WRITE, N_INC);
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 3   

 117   1          do
 118   1          {
 119   2              RTDSendByte(arrayR[n]);
 120   2          }
 121   1          while (++n);    // if n is 0xff, then n will be 0x00 after increased.
 122   1      
 123   1      #if(MCU_TYPE == MCU_WINBOND)
 124   1          bRTD_SCLK   = 0; 
 125   1          bRTD_SCLK   = 1;           
 126   1          bRTD_SCSB   = 1;
 127   1          
 128   1          // GAMMA_GREEN
 129   1          bRTD_SCSB   = 0;
 130   1      #else
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
                  
                  // GAMMA_GREEN
                  MCU_WriteRtdScsb(_LOW);
              #endif
 138   1      
 139   1          RTDSendAddr(GRN_GAMMA_65, WRITE, N_INC);
 140   1          do
 141   1          {
 142   2              RTDSendByte(arrayG[n]);
 143   2          }
 144   1          while (++n);
 145   1      #if(MCU_TYPE == MCU_WINBOND)
 146   1          bRTD_SCLK   = 0; 
 147   1          bRTD_SCLK   = 1;           
 148   1          bRTD_SCSB   = 1;
 149   1          
 150   1          //GAMMA_BLUE
 151   1          bRTD_SCSB   = 0;
 152   1      #else
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
                  
                  //GAMMA_BLUE
                  MCU_WriteRtdScsb(_LOW);
              #endif
 160   1          RTDSendAddr(BLU_GAMMA_66, WRITE, N_INC);
 161   1          do
 162   1          {
 163   2              RTDSendByte(arrayB[n]);
 164   2          }
 165   1          while (++n);
 166   1      
 167   1      #if(MCU_TYPE == MCU_WINBOND)
 168   1          bRTD_SCLK   = 0; 
 169   1          bRTD_SCLK   = 1;           
 170   1          bRTD_SCSB   = 1;
 171   1      #else
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
              #endif
 176   1      
 177   1          
 178   1          RTDSetBit(COLOR_CTRL_5D, 0xef, 0x04);   // Enable GAMMA & Diable Access Channel
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 4   

 179   1      }
 180          
 181          void WriteDither(unsigned char code *array , bit new_dither)
 182          {
 183   1          unsigned char   n;
 184   1          if(new_dither)
 185   1            RTDSetBit(FX_LST_LEN_H_5A,0xff,0x80);
 186   1          else
 187   1            RTDSetBit(FX_LST_LEN_H_5A,0x7f,0x00);
 188   1      
 189   1          RTDSetBit(COLOR_CTRL_5D, 0xb7, 0x68);   // Enable DITHER & Enable Access Channels
 190   1      
 191   1      #if(MCU_TYPE == MCU_WINBOND)
 192   1          bRTD_SCSB   = 0;
 193   1          RTDSendAddr(DITHER_PORT_67, WRITE, N_INC);
 194   1      
 195   1          for (n = 0; n < 8; n++)     RTDSendByte(array[n]);
 196   1      
 197   1          bRTD_SCLK   = 0; 
 198   1          bRTD_SCLK   = 1;           
 199   1          bRTD_SCSB   = 1;
 200   1      #else
                  MCU_WriteRtdScsb(_LOW);
                  RTDSendAddr(DITHER_PORT_67, WRITE, N_INC);
              
                  for (n = 0; n < 8; n++)     RTDSendByte(array[n]);
              
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
              #endif
 210   1          
 211   1          //RTDSetBit(COLOR_CTRL_5D, 0xdf, 0x48);   // Enable DITHER & Disable Access Channels
 212   1              RTDSetBit(COLOR_CTRL_5D, 0x1f, 0x88);   // Enable DITHER & Disable Access Channels
 213   1      }
 214          
 215          void WriteSU_COEF(unsigned char code *arrayH, unsigned char code *arrayV)
 216          {
 217   1          unsigned char   n;
 218   1          
 219   1      
 220   1      
 221   1          RTDSetBit(FILTER_CTRL1_1C, 0xfc, 0x01);     // Enable H-Coeff access
 222   1      #if(MCU_TYPE == MCU_WINBOND)
 223   1          bRTD_SCSB   = 0;
 224   1          RTDSendAddr(FILTER_PORT_1D, WRITE, N_INC);
 225   1          for (n = 0; n < 128; n++)    RTDSendByte(arrayH[n]);
 226   1      
 227   1          bRTD_SCLK   = 0; 
 228   1          bRTD_SCLK   = 1;           
 229   1          bRTD_SCSB   = 1;
 230   1      
 231   1          RTDSetBit(FILTER_CTRL1_1C, 0xfc, 0x03);     // Enable V-Coeff access
 232   1          
 233   1          bRTD_SCSB   = 0;
 234   1          RTDSendAddr(FILTER_PORT_1D, WRITE, N_INC);
 235   1          for (n = 0; n < 128; n++)    RTDSendByte(arrayV[n]);
 236   1      
 237   1          bRTD_SCLK   = 0; 
 238   1          bRTD_SCLK   = 1;           
 239   1          bRTD_SCSB   = 1;
 240   1      
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 5   

 241   1      #else
                  MCU_WriteRtdScsb(_LOW);
                  RTDSendAddr(FILTER_PORT_1D, WRITE, N_INC);
                  for (n = 0; n < 128; n++)    RTDSendByte(arrayH[n]);
              
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
              
                  RTDSetBit(FILTER_CTRL1_1C, 0xfc, 0x03);     // Enable V-Coeff access
                  
                  MCU_WriteRtdScsb(_LOW);
                  RTDSendAddr(FILTER_PORT_1D, WRITE, N_INC);
                  for (n = 0; n < 128; n++)    RTDSendByte(arrayV[n]);
              
                  MCU_WriteRtdSclk(_LOW); 
                  MCU_WriteRtdSclk(_HIGH);           
                  MCU_WriteRtdScsb(_HIGH);
              
              #endif
 261   1      
 262   1          RTDSetBit(FILTER_CTRL1_1C, 0xfc, 0xc4);     // Disable filter coefficient access
 263   1      }
 264          
 265          void Set_H_Position(void)
 266          {
 267   1      #if(AS_NON_FRAMESYNC)
                  RTDSetBit(ODD_CTRL_8E,0xef,0x00);
              #endif
 270   1      
 271   1          // if the backporch is far small then the standard one,
 272   1              // it is possibile that even IHS_Delay decrease to zero still can't correct the H position
 273   1              // so adjust the usIPH_ACT_STA first and turn back to original value later
 274   1      
 275   1          if(stMUD.H_POSITION < ucH_Min_Margin)
 276   1          {
 277   2             usIPH_ACT_STA = usIPH_ACT_STA - (ucH_Min_Margin - stMUD.H_POSITION);
 278   2             stMUD.H_POSITION = ucH_Min_Margin;
 279   2          }
 280   1      
 281   1      #if(ALIGN_LEFT == CLOCK_ALIGN)
 282   1          ((unsigned int*)Data)[4] = usIPH_ACT_STA + (stMUD.CLOCK >> 2) - 32;
 283   1      #else
                  ((unsigned int*)Data)[4] = usIPH_ACT_STA + (stMUD.CLOCK >> 1) - 64;
              #endif
 286   1      
 287   1      
 288   1          Wait_For_Event(EVENT_IEN_STOP);
 289   1              
 290   1          Data[0] = 5;
 291   1          Data[1] = Y_INC;
 292   1          Data[2] = IPH_ACT_STA_06;
 293   1          Data[3] = (unsigned char)((unsigned int*)Data)[4];
 294   1          Data[4] = (unsigned char)(((unsigned int*)Data)[4] >> 8);
 295   1          Data[5] = 0;    
 296   1          RTDWrite(Data);
 297   1      
 298   1          // Update IHS delay according to phase
 299   1      //    Set_Phase(stMUD.PHASE & 0x7c);
 300   1          //Data[0]     = PROGRAM_HDELAY + (stMUD.H_POSITION - ucH_Min_Margin);
 301   1           Data[12] = (stMUD.H_POSITION - ucH_Min_Margin) + PROGRAM_HDELAY;
 302   1              
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 6   

 303   1              RTDSetByte(IHS_DELAY_8D, Data[12]);
 304   1         
 305   1      
 306   1      #if(AS_NON_FRAMESYNC)
                  if(bFrameSync && bStable)
                      RTDSetBit(ODD_CTRL_8E,0xef,0x10);
              #endif
 310   1      }
 311          
 312          #if(PANEL_TYPE == PANEL_HYUNDAI)                //hgxxxx 0522 for Hyundai
              #define MAX_MOVE_LINE   2
              bit     bSTEP_VPOS      = 0;
              static unsigned char idata ucPre_V_POS = 0x80;
              void Set_V_Position4HD(void);
              
              void Set_V_Position(void)
              {
                      unsigned char tempstore;
                      tempstore = stMUD.V_POSITION;
                      bSTEP_VPOS = 1;
                  do
                      {
                              if(stMUD.V_POSITION > ucPre_V_POS)
                              {
                                      if(stMUD.V_POSITION - ucPre_V_POS > MAX_MOVE_LINE)
                                              stMUD.V_POSITION = ucPre_V_POS + MAX_MOVE_LINE;
                              }
                              else
                              {
                                      if(ucPre_V_POS - stMUD.V_POSITION > MAX_MOVE_LINE)
                                              stMUD.V_POSITION = ucPre_V_POS - MAX_MOVE_LINE;
                              }
                              Set_V_Position4HD();
                              stMUD.V_POSITION = tempstore;
                      }
                      while(stMUD.V_POSITION != ucPre_V_POS);
                      bSTEP_VPOS = 0;
              }
              
              void Set_V_Position4HD(void)
              #else
 344          void Set_V_Position(void)
 345          #endif
 346          
 347          {
 348   1          unsigned int    usIV_Temp, usDV_Temp;
 349   1      
 350   1      
 351   1      #if(AS_NON_FRAMESYNC)
                  RTDSetBit(ODD_CTRL_8E,0xef,0x00);
              #endif
 354   1      
 355   1      #if(AS_DV_TOTAL)
 356   1          RTDSetBit(DV_BKGD_STA_31,0x7f,0x00);
 357   1      #endif
 358   1      
 359   1          if ((ucV_Max_Margin - 1)  < stMUD.V_POSITION)
 360   1          {
 361   2             
 362   2              RTDSetByte(IVS_DELAY_8C, (PROGRAM_VDELAY + stMUD.V_POSITION - (ucV_Max_Margin - 1)));
 363   2      
 364   2      
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 7   

 365   2              usIV_Temp   = usIPV_ACT_STA + (ucV_Max_Margin - 1) - 128;
 366   2              usDV_Temp   = (unsigned int)ucDV_Delay + (ucV_Max_Margin - 1) - 128;
 367   2          }
 368   1          else
 369   1          {
 370   2      
 371   2              RTDSetByte(IVS_DELAY_8C, PROGRAM_VDELAY);
 372   2      
 373   2      
 374   2              usIV_Temp   = usIPV_ACT_STA + stMUD.V_POSITION - 128;
 375   2              usDV_Temp   = (unsigned int)ucDV_Delay + stMUD.V_POSITION - 128;
 376   2          }
 377   1      
 378   1          Wait_For_Event(EVENT_IEN_START);
 379   1      
 380   1          Data[0] = 4;
 381   1          Data[1] = N_INC;
 382   1          Data[2] = IV_DV_LINES_38;
 383   1          Data[3] = (unsigned char)usDV_Temp;
 384   1          Data[4] = 5;    
 385   1          Data[5] = Y_INC;
 386   1          Data[6] = IPV_ACT_STA_0A;
 387   1          Data[7] = (unsigned char)usIV_Temp;
 388   1          Data[8] = (unsigned char)(usIV_Temp >> 8);
 389   1          Data[9] = 0;
 390   1          RTDWrite(Data);
 391   1      
 392   1          Wait_For_Event(EVENT_IEN_START);
 393   1      
 394   1      
 395   1              RTDSetByte(STATUS0_01, 0x00);  // Clear status
 396   1          RTDSetByte(STATUS1_1F, 0x00);  // Clear status
 397   1      
 398   1      
 399   1      #if(AS_NON_FRAMESYNC)
                  if(bFrameSync && bStable)
                      RTDSetBit(ODD_CTRL_8E,0xef,0x10);
              #endif
 403   1      
 404   1      #if(AS_DV_TOTAL)
 405   1          if(bFrameSync && bStable)
 406   1          {
 407   2             RTDSetByte(DV_TOTAL_STATUS_3D,0x00);  //Write once to clear status
 408   2             RTDSetBit(DV_BKGD_STA_31,0x7f,0x80);
 409   2          }
 410   1      #endif
 411   1      
 412   1      #if(PANEL_TYPE == PANEL_HYUNDAI)                //hgxxxx 0522 for Hyundai
                      ucPre_V_POS = stMUD.V_POSITION;
              #endif
 415   1      }
 416          
 417          /*
 418          void Set_V_Position(void)
 419          {
 420              unsigned int    usIV_Temp, usDV_Temp;
 421          #if(PANEL_TYPE == PANEL_HANDAI)
 422                  unsigned int    usDHT,usDHTc;
 423                  unsigned char   ucIVD0,ucIVD1;
 424          #endif
 425          
 426          #if(AS_NON_FRAMESYNC)
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 8   

 427              RTDSetBit(ODD_CTRL_8E,0xef,0x00);
 428          #endif
 429          
 430          
 431              if (ucV_Max_Margin < stMUD.V_POSITION)
 432              {
 433          
 434                  RTDSetByte(IVS_DELAY_8C, (PROGRAM_VDELAY + stMUD.V_POSITION - ucV_Max_Margin));
 435          
 436          
 437                  usIV_Temp   = usIPV_ACT_STA + ucV_Max_Margin - 128;
 438                  usDV_Temp   = (unsigned int)ucDV_Delay + ucV_Max_Margin - 128;
 439              }
 440              else
 441              {
 442          
 443                  RTDSetByte(IVS_DELAY_8C, PROGRAM_VDELAY);
 444          
 445          
 446                  usIV_Temp   = usIPV_ACT_STA + stMUD.V_POSITION - 128;
 447                  usDV_Temp   = (unsigned int)ucDV_Delay + stMUD.V_POSITION - 128;
 448              }
 449          
 450          #if(PANEL_TYPE == PANEL_HANDAI)
 451                  //DHT =  xxxxxxxx_xxx00000 (0x22) + 00000000_00xxxxx0 (0x2e)
 452                  RTDRead(0x22, 0x02, Y_INC);
 453                  usDHT = 256 * (Data[1]&0x07) + Data[0] + 2;
 454                  RTDRead(0x2E, 0x01, Y_INC);
 455                  //to restore DV_tatal
 456                  Data[15] = Data[0];
 457                  usDHT = usDHT*32 + ((Data[0]>>2) & 0x3e);
 458          
 459          
 460                  //compensated DH_Total
 461                  RTDRead(IVS_DELAY_8C, 0x01, Y_INC);
 462                  //original IVS delay
 463                  ucIVD0 = Data[0];  
 464                  //The IVS delay you are going to set
 465                  ucIVD1 = (ucV_Max_Margin < stMUD.V_POSITION) ? (0x80 | (PROGRAM_VDELAY + stMUD.V_POSITION - ucV_Max_Margi
             -n)) : (0x80 | PROGRAM_VDELAY);
 466                  //original IVS_DVS_Delay
 467                  RTDRead(IV_DV_LINES_38, 0x01, Y_INC);
 468                  //usDV_Temp  => IVS_DVS_delay you are going to set
 469                  usDHTc = (unsigned long)usDHT * (usVsync + usDV_Temp - Data[0] + ucIVD1 - ucIVD0)/usVsync - 0x40;//-2
 470              
 471              
 472          
 473          
 474                  //modify DH_Total
 475              Wait_For_Event(EVENT_IEN_STOP);
 476                  Data[0] = 5;
 477              Data[1] = Y_INC;
 478              Data[2] = DH_TOTAL_22;
 479              Data[3] = (unsigned char)((usDHTc>>5) & 0x00fe);
 480                  Data[4] = (unsigned char)((usDHTc>>13) & 0x0007);
 481                  Data[5] = 4;
 482                  Data[6] = Y_INC;
 483                  Data[7] = 0x2e;
 484                  Data[8] = (Data[15] & 0x07) | (((usDHTc+1)<<2) & 0x00f8);
 485                  Data[9] = 0;
 486              RTDWrite(Data);
 487          
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 9   

 488          #endif
 489              Wait_For_Event(EVENT_IEN_START);
 490          
 491              Data[0] = 4;
 492              Data[1] = N_INC;
 493              Data[2] = IV_DV_LINES_38;
 494              Data[3] = (unsigned char)usDV_Temp;
 495              Data[4] = 5;    
 496              Data[5] = Y_INC;
 497              Data[6] = IPV_ACT_STA_0A;
 498              Data[7] = (unsigned char)usIV_Temp;
 499              Data[8] = (unsigned char)(usIV_Temp >> 8);
 500              Data[9] = 0;
 501              RTDWrite(Data);
 502          
 503          
 504          #if(PANEL_TYPE == PANEL_HANDAI)
 505              //restore DH_Total
 506                  usDHT = usDHT - 0x40;   
 507              Wait_For_Event(EVENT_DEN_STOP);
 508                  Data[0] = 5;
 509              Data[1] = Y_INC;
 510              Data[2] = 0x22;
 511              Data[3] = (unsigned char)((usDHT>>5) & 0x00fe);
 512                  Data[4] = (unsigned char)((usDHT>>13) & 0x0007);
 513                  Data[5] = 4;
 514                  Data[6] = Y_INC;
 515                  Data[7] = 0x2e;
 516                  Data[8] = (Data[15] & 0x07) | ((usDHT<<2) & 0x00f8);
 517                  Data[9] = 0;
 518              RTDWrite(Data);     
 519          #endif
 520          
 521              Wait_For_Event(EVENT_IEN_START);
 522          
 523          
 524                  RTDSetByte(STATUS0_01, 0x00);  // Clear status
 525              RTDSetByte(STATUS1_1F, 0x00);  // Clear status
 526          
 527          
 528          #if(AS_NON_FRAMESYNC)
 529              if(bFrameSync && bStable)
 530                  RTDSetBit(ODD_CTRL_8E,0xef,0x10);
 531          #endif
 532          }
 533          */
 534          void Set_Clock(void)
 535          {
 536   1          unsigned char   ucM_Code, ucN_Code, ucTemp0, ucTemp1, ucResult;
 537   1      
 538   1          // Issac :
 539   1          // In this F/W, the frequency of PLL1 is fixed to 24.576*19/2=233.472MHz.
 540   1          // Our goal is to find the best M/N settings of PLL2 according to the relationship below
 541   1          // Best Fav = 233.472 * 32 / 31 = 241.003Mhz, and pixel rate = Fav * M / N
 542   1          // Too small or large N code will cause larger jitter of ADC clock.
 543   1          // In this F/W, I limite N code value between 16 and 31.
 544   1      
 545   1          unsigned int    usClock = usADC_Clock + (unsigned int)stMUD.CLOCK - 128;    // Pixel clock number
 546   1          unsigned long   ulRate  = (unsigned long)24576 * usClock / usStdHS;         // Pixel clock in kHz
 547   1      
 548   1      #if(AS_PLL_NONLOCK)
 549   1          RTDSetBit(ODD_CTRL_8E,0xdf,0x00);
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 10  

 550   1      #endif
 551   1      
 552   1      #if(AS_NON_FRAMESYNC)
                  RTDSetBit(ODD_CTRL_8E,0xef,0x00);
              #endif
 555   1      
 556   1      #if (TUNE_APLL)
 557   1          RTDSetBit(DV_TOTAL_STATUS_3D, 0xdf, 0x00);//Disable PE Max Measurement
 558   1          RTDSetByte(DV_TOTAL_STATUS_3D,0x40); //clear PE Max value
 559   1          ucPE_Max = 0;
 560   1      #endif
 561   1      
 562   1      /*
 563   1      
 564   1          ((unsigned int *)Data)[0]  = 375;
 565   1      
 566   1          ucM_Code    = 0;
 567   1          ucN_Code    = 0;
 568   1          ucResult    = 0;
 569   1          ucTemp0     = 7;
 570   1          do
 571   1          {
 572   1              ucTemp1 = ulRate * ucTemp0 / 241003;
 573   1      
 574   1              if (2 <= ucTemp1)
 575   1              {
 576   1                  ((unsigned long *)Data)[2]  = ulRate * ucTemp0 / ucTemp1;
 577   1                  
 578   1                  ((unsigned int *)Data)[1]   = (unsigned long)3735552000 / ((unsigned long *)Data)[2];
 579   1      
 580   1                  if (15500 <= ((unsigned int *)Data)[1])
 581   1                  {
 582   1                      if (15700 >= ((unsigned int *)Data)[1])
 583   1                      {
 584   1                          if (0 != ucResult || (((unsigned long)usClock * ucTemp0 / ucTemp1) * ucTemp1) != ((uns
             -igned long)usClock * ucTemp0))
 585   1                          {
 586   1                              ucN_Code    = ucTemp0;
 587   1                              ucM_Code    = ucTemp1;
 588   1                              break;
 589   1                          }
 590   1                      }
 591   1      
 592   1                      ((unsigned int *)Data)[1]   = ((unsigned int *)Data)[1] - 15500;
 593   1                  }
 594   1                  else
 595   1                  {
 596   1                      if (15375 <= ((unsigned int *)Data)[1])
 597   1                      {
 598   1                          if (0 != ucResult || (((unsigned long)usClock * ucTemp0 / ucTemp1) * ucTemp1) != ((uns
             -igned long)usClock * ucTemp0))
 599   1                          {
 600   1                              ucN_Code    = ucTemp0;
 601   1                              ucM_Code    = ucTemp1;
 602   1                              break;
 603   1                          }
 604   1                      }
 605   1                      
 606   1                      ((unsigned int *)Data)[1]   = 15500 - ((unsigned int *)Data)[1];
 607   1                  }
 608   1                  
 609   1                  if (((unsigned int *)Data)[0] > ((unsigned int *)Data)[1])
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 11  

 610   1                  {
 611   1                      ((unsigned int *)Data)[0]   = ((unsigned int *)Data)[1];
 612   1      
 613   1                      ucN_Code    = ucTemp0;
 614   1                      ucM_Code    = ucTemp1;
 615   1                  }
 616   1              }
 617   1      
 618   1              ucTemp1 = ucTemp1 + 1;
 619   1      
 620   1              if (2 <= ucTemp1)
 621   1              {
 622   1                  ((unsigned long *)Data)[2]  = ulRate * ucTemp0 / ucTemp1;
 623   1      
 624   1                  ((unsigned int *)Data)[1]   = (unsigned long)3735552000 / ((unsigned long *)Data)[2];
 625   1      
 626   1                  if (15500 <= ((unsigned int *)Data)[1])
 627   1                  {
 628   1                      if (15700 >= ((unsigned int *)Data)[1])
 629   1                      {
 630   1                          if (0 != ucResult || (((unsigned long)usClock * ucTemp0 / ucTemp1) * ucTemp1) != ((uns
             -igned long)usClock * ucTemp0))
 631   1                          {
 632   1                              ucN_Code    = ucTemp0;
 633   1                              ucM_Code    = ucTemp1;
 634   1                              break;
 635   1                          }
 636   1                      }
 637   1      
 638   1                      ((unsigned int *)Data)[1]   = ((unsigned int *)Data)[1] - 15500;
 639   1                  }
 640   1                  else
 641   1                  {
 642   1                      if (15375 <= ((unsigned int *)Data)[1])
 643   1                      {
 644   1                          if (0 != ucResult || (((unsigned long)usClock * ucTemp0 / ucTemp1) * ucTemp1) != ((uns
             -igned long)usClock * ucTemp0))
 645   1                          {
 646   1                              ucN_Code    = ucTemp0;
 647   1                              ucM_Code    = ucTemp1;
 648   1                              break;
 649   1                          }
 650   1                      }
 651   1                      
 652   1                      ((unsigned int *)Data)[1]   = 15500 - ((unsigned int *)Data)[1];
 653   1                  }
 654   1      
 655   1                  if (((unsigned int *)Data)[0] > ((unsigned int *)Data)[1])
 656   1                  {
 657   1                      ((unsigned int *)Data)[0]   = ((unsigned int *)Data)[1];
 658   1      
 659   1                      ucN_Code    = ucTemp0;
 660   1                      ucM_Code    = ucTemp1;
 661   1                  }
 662   1              }
 663   1      
 664   1              if (0 == ucResult)
 665   1              {
 666   1                  if (43 < ucTemp0 && 60000 < ulRate)
 667   1                  {
 668   1                      ucTemp0     = 10;
 669   1                      ucResult    = 1;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 12  

 670   1      
 671   1                      ((unsigned int *)Data)[0]  = 500;
 672   1                  }
 673   1              }
 674   1              else
 675   1              {
 676   1                  if (36 < ucTemp0 && 200 > ((unsigned int *)Data)[0])
 677   1                  {
 678   1                      break;
 679   1                  }
 680   1              }
 681   1          }
 682   1          while (53 >= ++ucTemp0);
 683   1      
 684   1          if (8 >= ucN_Code)
 685   1          {
 686   1              ucN_Code    = ucN_Code * 3;
 687   1              ucM_Code    = ucM_Code * 3;
 688   1          }
 689   1          else if (12 >= ucN_Code)
 690   1          {
 691   1              ucN_Code    = ucN_Code * 2;
 692   1              ucM_Code    = ucM_Code * 2;
 693   1          }
 694   1      
 695   1          usClock     = usClock - 1;
 696   1      
 697   1          Wait_For_Event(EVENT_IEN_STOP);
 698   1      
 699   1          RTDSetByte(I_CODE_MB_CA, 0x18);
 700   1          RTDSetByte(I_CODE_LB_C9, 0x00);
 701   1          RTDSetByte(P_CODE_CB, 0x18);
 702   1      
 703   1          Data[0]     = 5;
 704   1          Data[1]     = Y_INC;
 705   1          Data[2]     = PLL1_M_D7;
 706   1          Data[3]     = 0x11;
 707   1          Data[4]     = 0x00;
 708   1          Data[5]     = 0;
 709   1          RTDWrite(Data);
 710   1      
 711   1      */
 712   1      
 713   1          ((unsigned int *)Data)[0]  = 500;
 714   1      
 715   1          ucM_Code    = 0;
 716   1          ucN_Code    = 0;
 717   1          ucResult    = 0;
 718   1          ucTemp0     = 7;
 719   1          do
 720   1          {
 721   2              //Fav * PLL2_M / PLL2_N = ulRate
 722   2              //PLL2_M = ulRate * PLL2_N / Fav;
 723   2              //ucTemp1 = ulRate * ucTemp0 / 253687;// (20/2 * 24.576 *32/31)
 724   2              ucTemp1 = ulRate * ucTemp0 / 215634;// (17/2 * 24.576 *32/31)
 725   2      
 726   2              if (2 <= ucTemp1)
 727   2              {   //Fav = ulRate * PLL2_N / PLL2_M
 728   3                  ((unsigned long *)Data)[2]  = ulRate * ucTemp0 / ucTemp1;
 729   3                                                              //(20/2 * 24.576 * 16)
 730   3                              //((unsigned int *)Data)[1]   = (unsigned long)393216000 / ((unsigned long *)Data)[2];
 731   3                  ((unsigned int *)Data)[1]   = (unsigned long)334223600 / ((unsigned long *)Data)[2];
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 13  

 732   3                  // > 31/2 = 15.5
 733   3                  if (1550 <= ((unsigned int *)Data)[1])
 734   3                  {
 735   4                      if (1570 >= ((unsigned int *)Data)[1])
 736   4                      {
 737   5                          ucN_Code    = ucTemp0;
 738   5                          ucM_Code    = ucTemp1;
 739   5                          break;
 740   5                      }
 741   4      
 742   4                      ((unsigned int *)Data)[1]   = ((unsigned int *)Data)[1] - 1550;
 743   4                  }
 744   3                  else //小於32/31時，jitter爛的比較快
 745   3                  {
 746   4                      if (1537 <= ((unsigned int *)Data)[1])
 747   4                      {
 748   5                          ucN_Code    = ucTemp0;
 749   5                          ucM_Code    = ucTemp1;
 750   5                          break;
 751   5                      }
 752   4                      
 753   4                      ((unsigned int *)Data)[1]   = 1550 - ((unsigned int *)Data)[1];
 754   4                  }
 755   3                  
 756   3                  if (((unsigned int *)Data)[0] > ((unsigned int *)Data)[1])
 757   3                  {
 758   4                      ((unsigned int *)Data)[0]   = ((unsigned int *)Data)[1];
 759   4      
 760   4                      ucN_Code    = ucTemp0;
 761   4                      ucM_Code    = ucTemp1;
 762   4                  }
 763   3              }
 764   2      
 765   2              ucTemp1 = ucTemp1 + 1;
 766   2      
 767   2              if (2 <= ucTemp1)
 768   2              {
 769   3                  ((unsigned long *)Data)[2]  = ulRate * ucTemp0 / ucTemp1;
 770   3      
 771   3                  //((unsigned int *)Data)[1]   = (unsigned long)393216000 / ((unsigned long *)Data)[2];
 772   3                  ((unsigned int *)Data)[1]   = (unsigned long)334223600 / ((unsigned long *)Data)[2];
 773   3      
 774   3                  if (1550 <= ((unsigned int *)Data)[1])
 775   3                  {
 776   4                      if (1570 >= ((unsigned int *)Data)[1])
 777   4                      {
 778   5                          ucN_Code    = ucTemp0;
 779   5                          ucM_Code    = ucTemp1;
 780   5                          break;
 781   5                      }
 782   4      
 783   4                      ((unsigned int *)Data)[1]   = ((unsigned int *)Data)[1] - 1550;
 784   4                  }
 785   3                  else
 786   3                  {
 787   4                      if (1537 <= ((unsigned int *)Data)[1])
 788   4                      {
 789   5                          ucN_Code    = ucTemp0;
 790   5                          ucM_Code    = ucTemp1;
 791   5                          break;
 792   5                      }
 793   4                      
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 14  

 794   4                      ((unsigned int *)Data)[1]   = 1550 - ((unsigned int *)Data)[1];
 795   4                  }
 796   3      
 797   3                  if (((unsigned int *)Data)[0] > ((unsigned int *)Data)[1])
 798   3                  {
 799   4                      ((unsigned int *)Data)[0]   = ((unsigned int *)Data)[1];
 800   4      
 801   4                      ucN_Code    = ucTemp0;
 802   4                      ucM_Code    = ucTemp1;
 803   4                  }
 804   3              }
 805   2          }
 806   1          while (53 >= ++ucTemp0);
 807   1      
 808   1      
 809   1      
 810   1      /*
 811   1          if (8 >= ucN_Code)
 812   1          {
 813   1              ucN_Code    = ucN_Code * 3;
 814   1              ucM_Code    = ucM_Code * 3;
 815   1          }
 816   1          else if (12 >= ucN_Code)
 817   1          {
 818   1              ucN_Code    = ucN_Code * 2;
 819   1              ucM_Code    = ucM_Code * 2;
 820   1          }
 821   1      */
 822   1          usClock     = usClock - 1;
 823   1      
 824   1          Wait_For_Event(EVENT_IEN_STOP);
 825   1      /*
 826   1          RTDSetByte(I_CODE_LB_C9, 0x8c);
 827   1          RTDSetByte(I_CODE_MB_CA, 0x24);
 828   1          RTDSetByte(P_CODE_CB, 0x18);
 829   1      */
 830   1      
 831   1          RTDSetByte(I_CODE_LB_C9, 0x8c);
 832   1          RTDSetByte(I_CODE_MB_CA, 0x20);
 833   1          RTDSetByte(P_CODE_CB, 0x18);
 834   1      
 835   1          Data[0]     = 5;
 836   1          Data[1]     = Y_INC;
 837   1          Data[2]     = PLL1_M_D7;
 838   1          Data[3]     = 0x0f;//0x12;
 839   1          Data[4]     = 0x00;
 840   1          Data[5]     = 0;
 841   1          RTDWrite(Data);
 842   1      
 843   1          Data[0]     = 5;
 844   1          Data[1]     = Y_INC;
 845   1          Data[2]     = PLLDIV_CC;
 846   1          Data[3]     = (unsigned char)(usClock >> 8);
 847   1          Data[4]     = (unsigned char)usClock;
 848   1          Data[5]     = 5;
 849   1          Data[6]     = Y_INC;
 850   1          Data[7]     = PLL2_M_DB;
 851   1          Data[8]     = ucM_Code - 2;
 852   1          Data[9]     = ucN_Code - 2;
 853   1          Data[10]    = 0;
 854   1          RTDWrite(Data);
 855   1      
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 15  

 856   1          PowerUp_ADC();
 857   1          //Device_Power(ADC_POWER,ON);
 858   1      /*    
 859   1          Wait_For_Event(EVENT_IVS);
 860   1      */
 861   1          Delay_Xms(10);
 862   1      
 863   1      //    Wait_For_Event(EVENT_IVS);
 864   1      //    Wait_For_Event(EVENT_IVS);
 865   1      
 866   1      
 867   1          RTDSetByte(I_CODE_LB_C9, 0xfc);
 868   1          RTDSetByte(I_CODE_MB_CA, 0x21);
 869   1          RTDSetByte(P_CODE_CB, 0x17);
 870   1      
 871   1      
 872   1      //    RTDSetByte(P_CODE_CB, 0x15);
 873   1      //    RTDSetByte(I_CODE_MB_CA, 0x35);
 874   1      //    RTDSetByte(I_CODE_LB_C9, 0xdc);
 875   1      
 876   1      
 877   1          Wait_For_Event(EVENT_IVS);
 878   1      
 879   1          ulRate  = (unsigned long)24576 * usADC_Clock / usStdHS;         // Pixel clock in kHz
 880   1      
 881   1      #if(NEW_PI_CODE)
 882   1      /*
 883   1          RTDSetByte(I_CODE_LB_C9,0xFC);
 884   1          RTDSetByte(I_CODE_MB_CA,0x25);
 885   1          RTDSetByte(P_CODE_CB, 0x17);    
 886   1      */
 887   1      
 888   1          if(ucI_Code)
 889   1          {
 890   2             if((ucI_Code & 0x80) == 0x80)
 891   2                 RTDSetBit(I_CODE_MB_CA,0xdf,0x20);  //Set the I_Code[13] to 1;
 892   2             else
 893   2                 RTDSetBit(I_CODE_MB_CA,0xdf,0x00);  //Set the I_Code[13] to 0;
 894   2      
 895   2             ucI_Code = ucI_Code & 0x7f;
 896   2      
 897   2                 RTDSetByte(I_CODE_LB_C9,0x18 | ((ucI_Code & 0x07) << 5));
 898   2                 RTDSetBit(I_CODE_MB_CA,0xfc,0x04 | ((ucI_Code & 0x18) >> 3));
 899   2                 RTDSetByte(P_CODE_CB,P_Code);
 900   2          }
 901   1          else
 902   1          {
 903   2             RTDSetByte(I_CODE_LB_C9,0x1C);
 904   2             RTDSetByte(I_CODE_MB_CA,0x11); //Use old PFD first
 905   2             RTDSetByte(P_CODE_CB, 0x16);    
 906   2          }
 907   1      
 908   1      //    RTDSetByte(I_CODE_LB_C9,0xdc);
 909   1      //    RTDSetByte(I_CODE_MB_CA,0x35);
 910   1      //    RTDSetByte(P_CODE_CB, 0x16);    
 911   1      
 912   1              
 913   1      #else
                  RTDSetByte(I_CODE_LB_C9,0x03);
                  RTDSetByte(I_CODE_MB_CA,0x00);
                  if (90000 < ulRate)
                  {
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 16  

                      RTDSetByte(P_CODE_CB, 0x19);
                      //RTDSetByte(P_CODE_CB, 0x1a);
                      
                  }
                  else if (60000 < ulRate)
                  {
                      RTDSetByte(P_CODE_CB, 0x19);
                      //RTDSetByte(P_CODE_CB, 0x1a);        
                  }
                  else if (35000 < ulRate)
                  {
                      //RTDSetByte(P_CODE_CB, 0x19);
                      RTDSetByte(P_CODE_CB, 0x18);
                      Delay_Xms(2);
              
                      //RTDSetByte(P_CODE_CB, 0x1b);
                      RTDSetByte(P_CODE_CB, 0x1a);
                  }
                  else
                  {
                      //RTDSetByte(P_CODE_CB, 0x19);
                      RTDSetByte(P_CODE_CB, 0x18);
                      Delay_Xms(2);
              
                      //RTDSetByte(P_CODE_CB, 0x1b);
                      RTDSetByte(P_CODE_CB, 0x1a);
                  }
              #endif
 946   1       
 947   1            if(!bAutoInProgress)
 948   1                 Wait_For_Event(EVENT_IVS);
 949   1       //   Wait_For_Event(EVENT_IVS);
 950   1      
 951   1      #if (TUNE_APLL)
 952   1          if (ucPE_Level)
 953   1          {
 954   2              //RTDSetByte(I_CODE_LB_C9, 0x00);
 955   2              //RTDSetByte(I_CODE_MB_CA, 0xff);
 956   2      
 957   2              Delay_Xms(2);
 958   2          }
 959   1      #endif
 960   1      
 961   1      
 962   1              RTDSetByte(STATUS0_01, 0x00);  // Clear status
 963   1          RTDSetByte(STATUS1_1F, 0x00);  // Clear status
 964   1      
 965   1      
 966   1      #if(AS_PLL_NONLOCK)
 967   1         if(bFrameSync && bStable)
 968   1              RTDSetBit(ODD_CTRL_8E,0xdf,0x20);
 969   1      #endif
 970   1      
 971   1      #if(AS_NON_FRAMESYNC)
                  if(bFrameSync && bStable)
                      RTDSetBit(ODD_CTRL_8E,0xef,0x10);
              #endif
 975   1      } 
 976          
 977          void Set_Phase(unsigned char phase)
 978          {
 979   1          unsigned char   ucX_Ctrl, ucY_Ctrl, ucSelect;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 17  

 980   1      
 981   1      
 982   1          unsigned long   ulRate  = (unsigned long)24576 * usADC_Clock / usStdHS;     // Standard pixel clock in
             - kHz
 983   1      
 984   1      #if(MORE_PHASE)
                  Data[0] = phase & 0x03;
              #endif
 987   1          phase   &= 0x7c;
 988   1      
 989   1      
 990   1          ucSelect    = phase & 0x3c;
 991   1      
 992   1          phase       = phase >> 2;
 993   1          ucX_Ctrl    = (4 >= phase || 29 <= phase) ? 0x80 : (13 <= phase && 21 >= phase) ? 0x80 : 0x00;
 994   1          ucY_Ctrl    = (12 >= phase || 29 <= phase) ? 0x01 : 0x00;
 995   1      
 996   1      #if(MORE_PHASE)
                  ucY_Ctrl    = ucX_Ctrl | (ucSelect << 1) | ucY_Ctrl | (Data[0] << 1);
              #else
 999   1          ucY_Ctrl    = ucX_Ctrl | (ucSelect << 1) | ucY_Ctrl;
1000   1      #endif
1001   1      
1002   1      
1003   1      
1004   1      
1005   1          // Issac :
1006   1          // Code below is to select stable HSYNC latch edge.
1007   1          // There is about 12.23ns delay between input clock into ADC and output from ADC.
1008   1          // Calculating the corresponding phase delay for 6.187ns 
1009   1          // Original Formula :
1010   1              // ucSelect = 32 * 12.23 / (1000000 / ulRate); //for ver C
1011   1      
1012   1      
1013   1      
1014   1          ucSelect    = ulRate * 391 / 1000000;
1015   1      
1016   1      
1017   1      //    ucDebug_Value0 = ucSelect;
1018   1          ucSelect    = 32 >= ucSelect ? 32 - ucSelect : 64 - ucSelect;
1019   1      
1020   1      //    ucDebug_Value1 = ucSelect;
1021   1      
1022   1          //Calculate the absolute value from the selected phase to transition
1023   1          ucX_Ctrl    = (phase >= ucSelect) ? phase - ucSelect : ucSelect - phase;
1024   1      
1025   1          Data[0]     = PROGRAM_HDELAY + (stMUD.H_POSITION - ucH_Min_Margin);
1026   1          //compensate the H position shift due to the phase select
1027   1         ucSelect    = (phase + 6) < ucSelect ? Data[0] - 1 : Data[0];
1028   1      //      ucSelect    = Data[0];
1029   1      
1030   1          
1031   1      
1032   1           Wait_For_Event(EVENT_IEN_STOP);
1033   1      
1034   1             //select a correct edge to latch the stable data
1035   1          RTDSetByte(MEAS_HS_LATCH_4E, (6 < ucX_Ctrl && 26 > ucX_Ctrl) ? 0x00 : 0x10);
1036   1      //    RTDSetByte(MEAS_HS_LATCH_4E, 0x00);
1037   1          RTDSetByte(IHS_DELAY_8D, ucSelect);
1038   1              
1039   1      
1040   1          RTDSetByte(PLL_PHASE_9F, ucY_Ctrl);
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 18  

1041   1      
1042   1              Delay_Xms(2);
1043   1      
1044   1              RTDSetByte(STATUS0_01, 0x00);  // Clear status
1045   1          RTDSetByte(STATUS1_1F, 0x00);  // Clear status
1046   1      
1047   1      }
1048          
1049          
1050          //////////////////////////////////////////////////////////////////////////////////////////////////////
1051          
1052          
1053          void Set_Bright_Contrast(void)
1054          {
1055   1          // Set RTD's contrast and brightness
1056   1          if (100 < stGUD0.CONTRAST)          stGUD0.CONTRAST         = 50;
1057   1          if (100 < stGUD0.RTD_R_CONTRAST)    stGUD0.RTD_R_CONTRAST   = 50;
1058   1          if (100 < stGUD0.RTD_G_CONTRAST)    stGUD0.RTD_G_CONTRAST   = 50;
1059   1          if (100 < stGUD0.RTD_B_CONTRAST)    stGUD0.RTD_B_CONTRAST   = 50;
1060   1      
1061   1          Data[0] = 9;
1062   1          Data[1] = Y_INC;
1063   1          Data[2] = BRIGHT_R_5E;
1064   1      
1065   1      #if (0)
                  if (SOURCE_VGA == (stGUD1.INPUT_SOURCE & 0x07))
                  {
                      Data[3] = 0x7f;
                      Data[4] = 0x7f;
                      Data[5] = 0x7f;
                  }
                  else
              #endif
1074   1          {
1075   2              Data[3] = 0x7d;
1076   2              Data[4] = 0x7d;
1077   2              Data[5] = 0x7d;
1078   2          }
1079   1      
1080   1              switch((stGUD1.INPUT_SOURCE & 0x18) >> 3)
1081   1              {
1082   2              case 0:
1083   2                      Data[13] = stGUD4.C1_G;
1084   2                      Data[14] = stGUD4.C1_B;
1085   2                      Data[15] = stGUD4.C1_R;         
1086   2                      break;
1087   2              case 1:
1088   2                      Data[13] = stGUD4.C2_G;
1089   2                      Data[14] = stGUD4.C2_B;
1090   2                      Data[15] = stGUD4.C2_R;         
1091   2                      break;
1092   2              case 2:
1093   2                      Data[13] = stGUD4.C3_G;
1094   2                      Data[14] = stGUD4.C3_B;
1095   2                      Data[15] = stGUD4.C3_R;         
1096   2                      break;
1097   2              default:
1098   2                      Data[13] = stGUD0.RTD_G_CONTRAST;
1099   2                      Data[14] = stGUD0.RTD_B_CONTRAST;
1100   2                      Data[15] = stGUD0.RTD_R_CONTRAST;
1101   2                      break;
1102   2              }
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 19  

1103   1      #if(ANALOG_CONTRAST)
1104   1          if((stGUD1.INPUT_SOURCE & 0x07) == SOURCE_VGA)
1105   1              Data[6] = 0x80; //if using the analog gain to adjust contrast,digital gain alway set to 128
1106   1          else
1107   1            Data[6] = (50 >= stGUD0.CONTRAST) ? 78 + stGUD0.CONTRAST : 104 + (stGUD0.CONTRAST >> 1);
1108   1      #else
                  Data[6] = (50 >= stGUD0.CONTRAST) ? 78 + stGUD0.CONTRAST : 104 + (stGUD0.CONTRAST >> 1);  
              #endif
1111   1      
1112   1      
1113   1              Data[7] = (50 >= Data[13]) ? (unsigned int)Data[6] * (75 + (Data[13] >> 1)) / 100
1114   1                                                      : (unsigned int)Data[6] * (88 + (Data[13] >> 2)) / 100;
1115   1      
1116   1              Data[8] = (50 >= Data[14]) ? (unsigned int)Data[6] * (75 + (Data[14] >> 1)) / 100
1117   1                                                  : (unsigned int)Data[6] * (88 + (Data[14] >> 2)) / 100;
1118   1      
1119   1              Data[6] = (50 >= Data[15]) ? (unsigned int)Data[6] * (75 + (Data[15] >> 1)) / 100
1120   1                                                  : (unsigned int)Data[6] * (88 + (Data[15] >> 2)) / 100;
1121   1      
1122   1          Data[9] = 0;
1123   1          RTDWrite(Data);
1124   1      
1125   1          if (100 < stGUD0.BRIGHT)    stGUD0.BRIGHT   = 50;
1126   1      
1127   1          Data[0] = 6;
1128   1          Data[1] = Y_INC;
1129   1          Data[2] = OSD_ADDR_MSB_90;
1130   1      #if(PWM0 == BRIGHTNESS_PWM)  //PWM0 OUTPUT
                  Data[3] = 0x00;
                  Data[4] = 0x01;
              #elif(PWM1 == BRIGHTNESS_PWM) //PWM1 OUTPUT
                  Data[3] = 0x40;
                  Data[4] = 0x01;
              #else                         //PWM2 OUTPUT
1137   1          Data[3] = 0x80;
1138   1          Data[4] = 0x01;
1139   1      #endif
1140   1      
1141   1      
1142   1      #if (INV_BRIGHTNESS)
1143   1      //////////////////////////////////////////////////////////////////////////////////////////////////////
1144   1      //anson                         TP2804
1145   1      //////////////////////////////////////////////////////////////////////////////////////////////////////
1146   1      /*
1147   1              #if (PANEL_TYPE == PANEL_CHIMEI)
1148   1                      Data[5] = MIN_BRIGHTNESS + (unsigned int)(255 - 147) * (100 - stGUD0.BRIGHT) /100;      //anson Tp2804
1149   1              #elif (PANEL_TYPE == PANEL_HANNSTAR)
1150   1                      Data[5] = MIN_BRIGHTNESS + (unsigned int)(255 - 147) * (100 - stGUD0.BRIGHT) /100;      //anson Tp2804
1151   1              #elif (PANEL_TYPE == PANEL_CPT)
1152   1                      Data[5] = 35 + (unsigned int)(220 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
1153   1              #elif (PANEL_TYPE == PANEL_QDI)
1154   1                      Data[5] = 38 + (unsigned int)(217 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
1155   1              #else //(PANEL_TYPE == PANEL_SHARP)
1156   1                      Data[5] = MIN_BRIGHTNESS + (unsigned int)(255 - 143) * (100 - stGUD0.BRIGHT) /100;      //anson
1157   1              #endif
1158   1      */
1159   1      //////////////////////////////////////////////////////////////////////////////////////////////////////
1160   1      //anson                         MTV512
1161   1      //////////////////////////////////////////////////////////////////////////////////////////////////////
1162   1              #if (PANEL_TYPE == PANEL_CHIMEI)
                              Data[5] = 38 + (unsigned int)(217 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
                      #elif (PANEL_TYPE == PANEL_HANNSTAR)
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 20  

1165   1                      Data[5] = 38 + (unsigned int)(217 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
1166   1              #elif (PANEL_TYPE == PANEL_CPT)
                              Data[5] = 35 + (unsigned int)(220 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
                      #elif (PANEL_TYPE == PANEL_QDI)
                              Data[5] = 38 + (unsigned int)(217 - 0) * stGUD0.BRIGHT /100;                                            //anson MTV512
                      #else //(PANEL_TYPE == PANEL_SHARP)
                              Data[5] = MIN_BRIGHTNESS + (unsigned int)(255 - 143) * (100 - stGUD0.BRIGHT) /100;      //anson
                      #endif
1173   1      //////////////////////////////////////////////////////////////////////////////////////////////////////
1174   1      #else
                  Data[5] = MIN_BRIGHTNESS + (unsigned int)(MAX_BRIGHTNESS - MIN_BRIGHTNESS) * stGUD0.BRIGHT / 100;
              #endif
1177   1          Data[6] = 0;
1178   1      
1179   1      
1180   1          RTDWrite(Data);
1181   1      }
1182          
1183          void Set_Gamma(void)
1184          {
1185   1          switch (stGUD1.FUNCTION & 0x60)
1186   1          {
1187   2          case 0x20 :
1188   2              WriteGamma(GAMMA_1, GAMMA_1, GAMMA_1);
1189   2              break;
1190   2          case 0x40 :
1191   2              WriteGamma(GAMMA_2, GAMMA_2, GAMMA_2);
1192   2              break;
1193   2          case 0x60 :
1194   2              WriteGamma(GAMMA_3, GAMMA_3, GAMMA_3);
1195   2              break;
1196   2          default :
1197   2              RTDSetBit(COLOR_CTRL_5D, 0xeb, 0x00);   // Disable gamma function and its access channel
1198   2              break;
1199   2          }
1200   1      }
1201          
1202          void Set_Dithering(void)
1203          {
1204   1      #if (DISP_BIT == DISP_18BIT)
              
                  WriteDither(DITHER_1,0);
              
              #if(NEW_DITHER)
                  WriteDither(NEW_DITHER_TABLE,NEW_DITHER);
              #endif
              
              #else
1213   1      
1214   1      
1215   1          WriteDither(DITHER_1,0);
1216   1      
1217   1      #if(NEW_DITHER)
                  WriteDither(NEW_DITHER_TABLE,NEW_DITHER);
              #endif
1220   1      
1221   1          RTDSetBit(COLOR_CTRL_5D, 0x97, 0x00);       //  Disable dithering function and its access channel
1222   1      
1223   1      #endif
1224   1      }
1225          
1226          void Sharpness(void)
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 21  

1227          {
1228   1          if (MODE_NOSIGNAL != ucMode_Curr && MODE_NOSUPPORT != ucMode_Curr)
1229   1          {
1230   2      
1231   2              // For RTD2020 rev.B and later
1232   2              RTDSetByte(FILTER_CTRL0_1B, 0xc4);
1233   2      
1234   2              switch (stGUD1.FILTER)
1235   2              {
1236   3              case 0 :
1237   3                  WriteSU_COEF(SU_COEF_1, SU_COEF_1);
1238   3                  break;
1239   3              case 1 :
1240   3                  WriteSU_COEF(SU_COEF_2, SU_COEF_2);
1241   3                  break;
1242   3              case 2 :
1243   3                  if((usIPH_ACT_WID == 1280) && (DISP_SIZE == DISP_1280x1024))
1244   3                              {
1245   4                     WriteSU_COEF(SU_COEF_7, SU_COEF_7);
1246   4                              }
1247   3                  else
1248   3                              {
1249   4                     WriteSU_COEF(SU_COEF_3, SU_COEF_3);
1250   4                              }
1251   3      
1252   3                  break;
1253   3              case 3 :
1254   3                  WriteSU_COEF(SU_COEF_4, SU_COEF_4);
1255   3                  break;
1256   3              default :
1257   3                  WriteSU_COEF(SU_COEF_5, SU_COEF_5);
1258   3                  break;
1259   3              }
1260   2      
1261   2              RTDSetByte(FILTER_CTRL0_1B, 0xc7);
1262   2          }
1263   1      }
1264          
1265          
1266          #if(ANALOG_CONTRAST)
1267          
1268          unsigned char Set_Contrast_Gain(unsigned char ContrastValue, unsigned char ColorValue)
1269          {
1270   1           if(ContrastValue >= 45) //decrease gain
1271   1           {
1272   2                  if(ColorValue & 0x80)
1273   2                      {
1274   3                         ColorValue &= 0x7f;
1275   3                         ColorValue = ColorValue + ContrastValue - 45;
1276   3                         if(ColorValue > 0x7f)
1277   3                                ColorValue  = 0xff;   //(minus)
1278   3                         else
1279   3                            ColorValue |= 0x80;       //(minus)
1280   3                      }
1281   2                      else
1282   2                      {
1283   3                          if(ColorValue > (ContrastValue - 45))
1284   3                                  ColorValue = ColorValue - (ContrastValue - 45);
1285   3                              else
1286   3                                  ColorValue = 0x80 | (ContrastValue - 45 - ColorValue);
1287   3                      }
1288   2               }
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 22  

1289   1           else  //increase gain
1290   1           {
1291   2              if(ColorValue & 0x80)
1292   2                      {
1293   3                         ColorValue &= 0x7f;
1294   3                         if((45 - ContrastValue) > ColorValue)
1295   3                              ColorValue = 45 - ContrastValue - ColorValue;
1296   3                         else
1297   3                              ColorValue = 0x80 | (ColorValue - (45 - ContrastValue));
1298   3                         
1299   3                      }
1300   2                      else
1301   2                                 ColorValue = ColorValue + (45 - ContrastValue);
1302   2           }
1303   1       
1304   1           return ColorValue;
1305   1      }
1306          
1307          #endif
1308          
1309          void SetColorGainOffset(unsigned char addr,unsigned char parameter,unsigned char bios)
1310          {
1311   1              if(bios & 0x80)
1312   1              {       //(minus)
1313   2                      bios &= 0x7f;
1314   2                      RTDSetByte(addr, (parameter >= bios) ? parameter - bios : 0);
1315   2          }
1316   1          else
1317   1          {   //(plus)
1318   2                      RTDSetByte(addr, (parameter >= (0xff - bios)) ? 0xff : parameter + bios);
1319   2          }   
1320   1      }
1321          
1322          void SetADC_Gain(void)
1323          {
1324   1      /*
1325   1      #if (SWAP_RED_BLUE)
1326   1          RTDSetByte(REDGAIN_E0, stGUD2.AD_B_GAIN);
1327   1          RTDSetByte(GRNGAIN_E1, stGUD2.AD_G_GAIN);
1328   1          RTDSetByte(BLUGAIN_E2, stGUD2.AD_R_GAIN);
1329   1      #else
1330   1          RTDSetByte(REDGAIN_E0, stGUD2.AD_R_GAIN);
1331   1          RTDSetByte(GRNGAIN_E1, stGUD2.AD_G_GAIN);
1332   1          RTDSetByte(BLUGAIN_E2, stGUD2.AD_B_GAIN);
1333   1      #endif
1334   1      */
1335   1      
1336   1          unsigned char   ucTempContrast = 50;
1337   1          unsigned char   ucRate1  = (unsigned long)98 * usADC_Clock / usStdHS/4;
1338   1              unsigned char   ucRed = 0,ucGreen = 0,ucBlue = 0;
1339   1      
1340   1      
1341   1              if(110 < ucRate1)
1342   1              {
1343   2                  ucRed   =  0x80 | 29;
1344   2                      ucGreen =  0x80 | 28;
1345   2                      ucBlue  =  0x80 | 27;
1346   2              }
1347   1              else if(100 < ucRate1)
1348   1              {
1349   2                  ucRed   =  0x80 | 10;
1350   2                      ucGreen =  0x80 | 12;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 23  

1351   2                      ucBlue  =  0x80 | 10;
1352   2      
1353   2              }
1354   1              else if(90 < ucRate1)
1355   1              {
1356   2                  ucRed   =  1;
1357   2                      ucGreen =  1;
1358   2                      ucBlue  =  2;
1359   2      
1360   2              }
1361   1              else if(70 < ucRate1)
1362   1              {
1363   2                  ucRed   =  6;
1364   2                      ucGreen =  5;
1365   2                      ucBlue  =  5;
1366   2      
1367   2              }
1368   1              else if(48 < ucRate1)
1369   1              {
1370   2                 ucRed   =  0;
1371   2                 ucGreen =  0;
1372   2                 ucBlue  =  0;
1373   2              }
1374   1              else if(38 < ucRate1)
1375   1              {
1376   2                  ucRed   =  8;
1377   2                      ucGreen =  9;
1378   2                      ucBlue  =  8;
1379   2      
1380   2              }
1381   1              else
1382   1              {
1383   2                  ucRed   =  2;
1384   2                      ucGreen =  5;
1385   2                      ucBlue  =  4;
1386   2              }
1387   1      
1388   1              
1389   1      //    ucRate  = (100 >= ucRate) ? 0 : ucRate - 100;     
1390   1      #if(ANALOG_CONTRAST)
1391   1          if (100 < stGUD0.CONTRAST)  stGUD0.CONTRAST = 50;
1392   1              ucTempContrast = (unsigned int)stGUD0.CONTRAST * 9 / 10;
1393   1      
1394   1          ucRed   = Set_Contrast_Gain(ucTempContrast,ucRed);
1395   1          ucGreen = Set_Contrast_Gain(ucTempContrast,ucGreen);
1396   1          ucBlue  = Set_Contrast_Gain(ucTempContrast,ucBlue); 
1397   1      
1398   1      
1399   1          //(stGUD2.AD_X_GAIN - ucRate + 50 - stGUD0.CONTRAST)
1400   1      #endif
1401   1      
1402   1      #if(SWAP_RED_BLUE)
                  SetColorGainOffset(BLUGAIN_E2,stGUD2.AD_R_GAIN,ucRed);
              #else
1405   1          SetColorGainOffset(REDGAIN_E0,stGUD2.AD_R_GAIN,ucRed);
1406   1      #endif
1407   1      
1408   1          SetColorGainOffset(GRNGAIN_E1,stGUD2.AD_G_GAIN,ucGreen);
1409   1      
1410   1      #if(SWAP_RED_BLUE)
                  SetColorGainOffset(REDGAIN_E0,stGUD2.AD_B_GAIN,ucBlue);
              #else
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 24  

1413   1          SetColorGainOffset(BLUGAIN_E2,stGUD2.AD_B_GAIN,ucBlue);
1414   1      #endif
1415   1      
1416   1      
1417   1      }
1418          
1419          void SetADC_Offset(void)
1420          {
1421   1      /*
1422   1      #if (SWAP_RED_BLUE)
1423   1          RTDSetByte(REDOFST_E3, stGUD2.AD_B_OFFSET);
1424   1          RTDSetByte(GRNOFST_E4, stGUD2.AD_G_OFFSET);
1425   1          RTDSetByte(BLUOFST_E5, stGUD2.AD_R_OFFSET);
1426   1      #else
1427   1          RTDSetByte(REDOFST_E3, stGUD2.AD_R_OFFSET);
1428   1          RTDSetByte(GRNOFST_E4, stGUD2.AD_G_OFFSET);
1429   1          RTDSetByte(BLUOFST_E5, stGUD2.AD_B_OFFSET);
1430   1      #endif
1431   1      */
1432   1          unsigned char   ucRed = 0, ucBlue = 0, ucGreen = 0;
1433   1          unsigned char   ucRate  = (unsigned long)98 * usADC_Clock / usStdHS/4;
1434   1      
1435   1      
1436   1              if(110 < ucRate)
1437   1              {
1438   2                ucRed = 10;
1439   2                ucGreen = 11;
1440   2                ucBlue = 11;
1441   2              }
1442   1              else if(90 < ucRate)
1443   1              {
1444   2            ucRed = 5;
1445   2                ucGreen = 7;
1446   2                ucBlue = 5;
1447   2              }
1448   1              else if(60 < ucRate)
1449   1              {
1450   2                ucRed = 0;
1451   2                ucGreen = 0;
1452   2                ucBlue = 0;
1453   2              }
1454   1              else if(48 < ucRate)
1455   1              {
1456   2                ucRed = 0x80 | 1;
1457   2                ucGreen = 0;
1458   2                ucBlue = 0x80 | 1;
1459   2              }
1460   1              else
1461   1              {
1462   2                ucRed = 0;
1463   2                ucGreen = 0x80 | 1;
1464   2                ucBlue = 0x80 | 1;
1465   2              }
1466   1      /*
1467   1          if (110 < ucRate)
1468   1          {
1469   1      #if (SWAP_RED_BLUE)
1470   1              RTDSetByte(REDOFST_E3, stGUD2.AD_B_OFFSET <= 255 - 12 ? stGUD2.AD_B_OFFSET + 12 : 255);
1471   1              RTDSetByte(GRNOFST_E4, stGUD2.AD_G_OFFSET <= 255 - 12 ? stGUD2.AD_G_OFFSET + 12 : 255);
1472   1              RTDSetByte(BLUOFST_E5, stGUD2.AD_R_OFFSET <= 255 - 10 ? stGUD2.AD_R_OFFSET + 10 : 255);
1473   1      #else
1474   1              RTDSetByte(REDOFST_E3, stGUD2.AD_R_OFFSET <= 255 - 10 ? stGUD2.AD_R_OFFSET + 10 : 255);
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 25  

1475   1              RTDSetByte(GRNOFST_E4, stGUD2.AD_G_OFFSET <= 255 - 12 ? stGUD2.AD_G_OFFSET + 12 : 255);
1476   1              RTDSetByte(BLUOFST_E5, stGUD2.AD_B_OFFSET <= 255 - 12 ? stGUD2.AD_B_OFFSET + 12 : 255);
1477   1      #endif
1478   1          }
1479   1              */
1480   1         
1481   1      
1482   1      #if(SWAP_RED_BLUE)
                  SetColorGainOffset(BLUOFST_E5,stGUD2.AD_R_OFFSET,ucRed);
              #else
1485   1          SetColorGainOffset(REDOFST_E3,stGUD2.AD_R_OFFSET,ucRed);
1486   1      #endif
1487   1      
1488   1          SetColorGainOffset(GRNOFST_E4,stGUD2.AD_G_OFFSET,ucGreen);
1489   1      
1490   1      #if(SWAP_RED_BLUE)
                  SetColorGainOffset(REDOFST_E3,stGUD2.AD_B_OFFSET,ucBlue);
              #else
1493   1          SetColorGainOffset(BLUOFST_E5,stGUD2.AD_B_OFFSET,ucBlue);
1494   1      #endif
1495   1      
1496   1      
1497   1      }
1498          
1499          void SetADC_GainOffset(void)
1500          {
1501   1          SetADC_Gain();
1502   1          SetADC_Offset();
1503   1      }
1504          #if(VIDEO_CHIP != VDC_NONE)
              void SetVDC_Color(void)
              {
                  if (SOURCE_YUV == (stGUD1.INPUT_SOURCE & 0x07))
                  {
                      Data[0] = 6;
                      Data[1] = ADDR_VIDEO;
                      Data[2] = VDC_BRIGHT_YUV_CTRL;
                      Data[3] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VBRIGHT;
                      Data[4] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VCONTRAST   ^ 0x80;
                      Data[5] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VSATURATION ^ 0x80;
                      I2CWrite(Data);
                  }
                  else
                  {
                      Data[0] = 7;
                      Data[1] = ADDR_VIDEO;
                      Data[2] = VDC_BRIGHT_CTRL;
                      Data[3] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VBRIGHT;
                      Data[4] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VCONTRAST   ^ 0x80;
                      Data[5] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VSATURATION ^ 0x80;
                      Data[6] = ((LP_VIDEO_MODE_USER_DATA)&stMUD)->VHUE        ^ 0x80;
                      I2CWrite(Data);
                  }
              }
              #endif
1530          //mega #if(MCU_TYPE == MCU_WINBOND)             //anson 050519
1531          /*
1532          void Wait_For_Event(unsigned char event)
1533          {
1534                  unsigned char t;
1535          
1536                  t = 100;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 26  

1537          
1538                  RTDSetByte(0x1f,0x00);
1539                  do
1540                  {
1541                          RTDRead(STATUS1_1F, 1, Y_INC);
1542                          Data[0] = Data[0] & event;
1543                          t--;
1544                          Delay_Xms(1);
1545                  }while((Data[0] == 0) && (t));
1546          
1547              RTDSetByte(0x1f,0x00);
1548          
1549          }
1550          */
1551          
1552          void Wait_For_Event(unsigned char event)
1553          {
1554   1          unsigned char   ucDelayCnt  = 80;   // 80ms timeout
1555   1          unsigned char   ucProtect   = 24;   // 24ms protect
1556   1      
1557   1              RTDSetByte(STATUS1_1F,0x00);          // Clear status (status register will be cleared after write)
1558   1          
1559   1          bNotify_Timer1_Int  = 0;
1560   1          
1561   1          Data[0] = 0;
1562   1          Data[1] = 0;
1563   1          TR1     = 1;
1564   1          do
1565   1          {
1566   2              if (bNotify_Timer1_Int)
1567   2              {
1568   3                  bNotify_Timer1_Int  = 0;
1569   3      
1570   3                  if (Data[1] & (EVENT_IVS | EVENT_IEN_START))
1571   3                  {
1572   4                      Data[1]     = 0;
1573   4                      ucProtect   = 24;
1574   4                  }
1575   3                  else if (ucProtect)
1576   3                  {
1577   4                      ucProtect   = ucProtect - 1;
1578   4                  }
1579   3      
1580   3                  if (--ucDelayCnt)   TR1 = 1;
1581   3              }
1582   2      
1583   2      
1584   2              RTDRead(STATUS1_1F, 1, N_INC);  // Read Status1 
1585   2      
1586   2      
1587   2                      if(Data[0])
1588   2                              RTDSetByte(STATUS1_1F,0x00);
1589   2      
1590   2              
1591   2              Data[1] |= (Data[0] & (EVENT_IVS | EVENT_IEN_START));
1592   2              Data[0] &= event;
1593   2      
1594   2          }
1595   1          while (0 == Data[0] && 0 != ucDelayCnt);
1596   1      }
1597          
1598          #if 0  //mega           //anson 050519
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 27  

              //#else
              void Wait_For_Event(unsigned char event)
              {
                  unsigned char   ucDelayCnt  = 80;   // 80ms timeout
                  unsigned char   ucProtect   = 24;   // 24ms protect
              
                      RTDSetByte(STATUS1_1F,0x00);          // Clear status (status register will be cleared after write)
                  
                  bNotify_Timer1_Int  = 0;
                  
                  Data[0] = 0;
                  Data[1] = 0;
              //  TR1     = 1;
                  do
                  {
                      if (bNotify_Timer1_Int)
                      {
                          bNotify_Timer1_Int  = 0;
              
                          if (Data[1] & (EVENT_IVS | EVENT_IEN_START))
                          {
                              Data[1]     = 0;
                              ucProtect   = 24;
                          }
                          else if (ucProtect)
                          {
                              ucProtect   = ucProtect - 1;
                          }
              
                          if (--ucDelayCnt)   TR0 = 1;//TR1 = 1;
                      }
              
              
                      RTDRead(STATUS1_1F, 1, N_INC);  // Read Status1 
              
              
                              if(Data[0])
                                      RTDSetByte(STATUS1_1F,0x00);
              
                      
                      Data[1] |= (Data[0] & (EVENT_IVS | EVENT_IEN_START));
                      Data[0] &= event;
              
                              /*
                      if (bAutoInProgress && (event & EVENT_INPUT) && 0 == ucProtect)
                      {
              #if (TYPE_OF_8051 == INT_8051)
              #if (LIGHT_OFF)
                          SetPortBit(LIGHT_PWR_PORT, 0xff, LIGHT_PWR_MASK);
              #else
                          SetPortBit(LIGHT_PWR_PORT, ~LIGHT_PWR_MASK, 0);
              #endif
              #else
                          bLIGHT_PWR  = LIGHT_OFF;
              #endif
                      }
                              */
                  }
                  while (0 == Data[0] && 0 != ucDelayCnt);
              }
              
              #endif//mega
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 28  

1661          ///////////////////////////////////////////////////////////////////////////////////////////////
1662          
1663          void Save_GUD0(void)
1664          {
1665   1          Data[0]     = 11;
1666   1          Data[1]     = ADDR_EROM1;
1667   1          Data[2]     = 0xE0;
1668   1          Data[3]     = stGUD0.CONTRAST;
1669   1          Data[4]     = stGUD0.BRIGHT;
1670   1          Data[5]     = stGUD0.RTD_R_CONTRAST;
1671   1          Data[6]     = stGUD0.RTD_G_CONTRAST;
1672   1          Data[7]     = stGUD0.RTD_B_CONTRAST;
1673   1          Data[8]     = stGUD0.RTD_R_BRIGHT;
1674   1          Data[9]     = stGUD0.RTD_G_BRIGHT;
1675   1          Data[10]    = stGUD0.RTD_B_BRIGHT;
1676   1          I2CWrite(Data);
1677   1      
1678   1          Delay_Xms(SET_2404_DELAY);
1679   1      }
1680          
1681          void Load_GUD0(void)
1682          {
1683   1          I2CRead(ADDR_EROM1, 0xE0 , 8);
1684   1      
1685   1          stGUD0.CONTRAST         = Data[0];
1686   1          stGUD0.BRIGHT           = Data[1];
1687   1          stGUD0.RTD_R_CONTRAST   = Data[2];
1688   1          stGUD0.RTD_G_CONTRAST   = Data[3];
1689   1          stGUD0.RTD_B_CONTRAST   = Data[4];
1690   1          stGUD0.RTD_R_BRIGHT     = Data[5];
1691   1          stGUD0.RTD_G_BRIGHT     = Data[6];
1692   1          stGUD0.RTD_B_BRIGHT     = Data[7];
1693   1      }
1694          
1695          void Save_GUD1(void)
1696          {
1697   1          Data[0]     = 10;
1698   1          Data[1]     = ADDR_EROM1;
1699   1          Data[2]     = 0xE8;
1700   1          Data[3]     = stGUD1.FUNCTION;
1701   1          Data[4]     = stGUD1.INPUT_SOURCE;
1702   1          Data[5]     = stGUD1.FILTER;
1703   1          Data[6]     = stGUD1.OSD_POSH;
1704   1          Data[7]     = stGUD1.OSD_POSV;
1705   1          Data[8]     = stGUD1.OSD_TIMEOUT;
1706   1          Data[9]     = stGUD1.OSD_INPUT;                     //anson 05_0314
1707   1          Data[10]     = 0;                                           //anson 05_0314
1708   1          I2CWrite(Data);
1709   1      
1710   1          Delay_Xms(SET_2404_DELAY);
1711   1      }
1712          
1713          void Load_GUD1(void)
1714          {
1715   1          I2CRead(ADDR_EROM1, 0xE8 , 7);
1716   1          
1717   1              stGUD1.FUNCTION                 = Data[0];
1718   1              stGUD1.INPUT_SOURCE     = Data[1];
1719   1              stGUD1.FILTER                   = Data[2];
1720   1              stGUD1.OSD_POSH         = Data[3];
1721   1              stGUD1.OSD_POSV         = Data[4];
1722   1              stGUD1.OSD_TIMEOUT              = Data[5];
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 29  

1723   1              stGUD1.OSD_INPUT                = Data[6];              //anson 05_0314
1724   1      
1725   1      }
1726          
1727          void Save_GUD2(void)
1728          {
1729   1          Data[0]     = 9;
1730   1          Data[1]     = ADDR_EROM1;
1731   1          Data[2]     = 0xF0;
1732   1          Data[3]     = stGUD2.AD_R_GAIN;
1733   1          Data[4]     = stGUD2.AD_G_GAIN;
1734   1          Data[5]     = stGUD2.AD_B_GAIN;
1735   1          Data[6]     = stGUD2.AD_R_OFFSET;
1736   1          Data[7]     = stGUD2.AD_G_OFFSET;
1737   1          Data[8]     = stGUD2.AD_B_OFFSET;
1738   1      
1739   1          I2CWrite(Data);
1740   1          Delay_Xms(SET_2404_DELAY);
1741   1      }
1742          
1743          void Load_GUD2(void)
1744          {
1745   1          I2CRead(ADDR_EROM1, 0xF0 , 6);
1746   1          
1747   1          stGUD2.AD_R_GAIN    = Data[0];
1748   1          stGUD2.AD_G_GAIN    = Data[1];
1749   1          stGUD2.AD_B_GAIN    = Data[2];
1750   1          stGUD2.AD_R_OFFSET  = Data[3];
1751   1          stGUD2.AD_G_OFFSET  = Data[4];
1752   1          stGUD2.AD_B_OFFSET  = Data[5];
1753   1      }
1754          
1755          void Save_GUD3(void)
1756          {
1757   1          Data[0]     = 7;
1758   1          Data[1]     = ADDR_EROM1;
1759   1          Data[2]     = 0xF8;
1760   1          Data[3]     = stGUD3.VOLUME;
1761   1          Data[4]     = stGUD3.CURR_CHANNEL;
1762   1          Data[5]     = stGUD3.PREV_CHANNEL;
1763   1          Data[6]     = stGUD3.TV_SETTING;
1764   1      
1765   1          I2CWrite(Data);
1766   1          Delay_Xms(SET_2404_DELAY);
1767   1      }
1768          
1769          void Load_GUD3(void)
1770          {
1771   1          I2CRead(ADDR_EROM1, 0xF8 , 4);
1772   1          
1773   1          stGUD3.VOLUME       = Data[0];
1774   1          stGUD3.CURR_CHANNEL = Data[1];
1775   1          stGUD3.PREV_CHANNEL = Data[2];
1776   1          stGUD3.TV_SETTING   = Data[3];
1777   1      }
1778          
1779          void Save_GUD4(void)
1780          {
1781   1          Data[0]     = 12;
1782   1          Data[1]     = ADDR_EROM1;
1783   1          Data[2]     = 0xD0;
1784   1          Data[3]     = stGUD4.C1_R;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 30  

1785   1          Data[4]     = stGUD4.C1_G;
1786   1          Data[5]     = stGUD4.C1_B;
1787   1          Data[6]     = stGUD4.C2_R;
1788   1          Data[7]     = stGUD4.C2_G;
1789   1          Data[8]     = stGUD4.C2_B;
1790   1          Data[9]     = stGUD4.C3_R;
1791   1          Data[10]    = stGUD4.C3_G;
1792   1          Data[11]    = stGUD4.C3_B;
1793   1          I2CWrite(Data);
1794   1      
1795   1          Delay_Xms(SET_2404_DELAY);
1796   1      }
1797          
1798          void Load_GUD4(void)
1799          {
1800   1          I2CRead(ADDR_EROM1, 0xD0 , 9);
1801   1      
1802   1          stGUD4.C1_R   = Data[0];
1803   1          stGUD4.C1_G   = Data[1];
1804   1          stGUD4.C1_B   = Data[2];
1805   1          stGUD4.C2_R   = Data[3];
1806   1          stGUD4.C2_G   = Data[4];
1807   1          stGUD4.C2_B   = Data[5];
1808   1          stGUD4.C3_R   = Data[6];
1809   1          stGUD4.C3_G   = Data[7];
1810   1              stGUD4.C3_B   = Data[8];
1811   1      }
1812          
1813          
1814          void Save_MUD(unsigned char mode_num)
1815          {
1816   1          if (0 == mode_num || 64 < mode_num)  return;
1817   1          
1818   1          Data[0] = 7;
1819   1          Data[1] = ADDR_EROM0;
1820   1          Data[2] = (mode_num - 1) << 2;              
1821   1          Data[3] = stMUD.H_POSITION;
1822   1          Data[4] = stMUD.V_POSITION;
1823   1          Data[5] = stMUD.CLOCK;
1824   1          Data[6] = (stMUD.PHASE & 0x7c);// | (stMUD.P_Code - 0x19);
1825   1          I2CWrite(Data);
1826   1          
1827   1          Delay_Xms(SET_2404_DELAY);
1828   1      }
1829          
1830          void Load_MUD(unsigned char mode_num)
1831          {
1832   1          if (0 == mode_num || 64 < mode_num)  return;
1833   1      
1834   1          I2CRead(ADDR_EROM0, (mode_num - 1) << 2, 4);
1835   1      
1836   1          stMUD.H_POSITION    = Data[0];
1837   1          stMUD.V_POSITION    = Data[1];
1838   1          stMUD.CLOCK         = Data[2];
1839   1          stMUD.PHASE         = Data[3] & 0x7c;
1840   1      //      stMUD.P_Code        = (Data[3] & 0x03) + 0x19;
1841   1      
1842   1              
1843   1      }
1844          
1845          void Init_GUD(void)     // GU <= Default
1846          {
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 31  

1847   1          stGUD0.CONTRAST         = INIT_EEPROM0[3];
1848   1          stGUD0.BRIGHT           = INIT_EEPROM0[4];
1849   1          stGUD0.RTD_R_CONTRAST   = INIT_EEPROM0[5];
1850   1          stGUD0.RTD_G_CONTRAST   = INIT_EEPROM0[6];
1851   1          stGUD0.RTD_B_CONTRAST   = INIT_EEPROM0[7];
1852   1          stGUD0.RTD_R_BRIGHT     = INIT_EEPROM0[8];
1853   1          stGUD0.RTD_G_BRIGHT     = INIT_EEPROM0[9];
1854   1          stGUD0.RTD_B_BRIGHT     = INIT_EEPROM0[10];
1855   1      
1856   1          stGUD1.FUNCTION         = INIT_EEPROM0[11];
1857   1          stGUD1.INPUT_SOURCE     = INIT_EEPROM0[12];
1858   1          stGUD1.FILTER           = INIT_EEPROM0[13];
1859   1          stGUD1.OSD_POSH         = INIT_EEPROM0[14];
1860   1          stGUD1.OSD_POSV         = INIT_EEPROM0[15];
1861   1          stGUD1.OSD_TIMEOUT      = INIT_EEPROM0[16];
1862   1          stGUD1.OSD_INPUT      = INIT_EEPROM0[17];           //anson 05_0314
1863   1      
1864   1          stGUD2.AD_R_GAIN        = INIT_EEPROM1[3];
1865   1          stGUD2.AD_G_GAIN        = INIT_EEPROM1[4];
1866   1          stGUD2.AD_B_GAIN        = INIT_EEPROM1[5];
1867   1          stGUD2.AD_R_OFFSET      = INIT_EEPROM1[6];
1868   1          stGUD2.AD_G_OFFSET      = INIT_EEPROM1[7];
1869   1          stGUD2.AD_B_OFFSET      = INIT_EEPROM1[8];
1870   1      
1871   1          stGUD3.VOLUME           = INIT_EEPROM1[11];
1872   1          stGUD3.CURR_CHANNEL     = INIT_EEPROM1[12];
1873   1          stGUD3.PREV_CHANNEL     = INIT_EEPROM1[13];
1874   1          stGUD3.TV_SETTING       = INIT_EEPROM1[14];
1875   1      
1876   1              stGUD4.C1_R             = INIT_EEPROM2[3];
1877   1              stGUD4.C1_G             = INIT_EEPROM2[4];
1878   1              stGUD4.C1_B             = INIT_EEPROM2[5];
1879   1              stGUD4.C2_R             = INIT_EEPROM2[6];
1880   1              stGUD4.C2_G             = INIT_EEPROM2[7];
1881   1              stGUD4.C2_B             = INIT_EEPROM2[8];
1882   1              stGUD4.C3_R             = INIT_EEPROM2[9];
1883   1              stGUD4.C3_G             = INIT_EEPROM2[10];
1884   1              stGUD4.C3_B             = INIT_EEPROM2[11];
1885   1      
1886   1              
1887   1          I2CWrite(INIT_EEPROM0);
1888   1          Delay_Xms(SET_2404_DELAY);
1889   1      
1890   1          I2CWrite(INIT_EEPROM1);
1891   1          Delay_Xms(SET_2404_DELAY);
1892   1      
1893   1              I2CWrite(INIT_EEPROM2);
1894   1          Delay_Xms(SET_2404_DELAY);
1895   1      
1896   1      //      Save_GUD4();
1897   1      
1898   1      }
1899          
1900          void Init_MUD(void)
1901          {
1902   1          unsigned char   ucModeIdx;
1903   1      
1904   1              //anson 05_0314
1905   1              Data[0]     = 11;
1906   1              Data[1]     = ADDR_EROM1;
1907   1              Data[2]     = 0;
1908   1              Data[3]     = 0xff;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 32  

1909   1              Data[4]     = 0xff;
1910   1              Data[5]     = 0xff;
1911   1              Data[6]     = 0xff;
1912   1              Data[7]     = 0xff;
1913   1              Data[8]     = 0xff;
1914   1              Data[9]     = 0xff;
1915   1              Data[10]    = 0xff;
1916   1              I2CWrite(Data);
1917   1              Delay_Xms(SET_2404_DELAY);
1918   1      /*
1919   1          // Reset frame-Sync and TV channel settings
1920   1          Data[0]     = 11;
1921   1          Data[1]     = ADDR_EROM1;
1922   1          Data[2]     = 0;
1923   1          Data[3]     = 0x00;
1924   1          Data[4]     = 0x00;
1925   1          Data[5]     = 0x00;
1926   1          Data[6]     = 0x00;
1927   1          Data[7]     = 0x00;
1928   1          Data[8]     = 0x00;
1929   1          Data[9]     = 0x00;
1930   1          Data[10]    = 0x00;
1931   1          
1932   1          ucModeIdx   = 0;
1933   1          do
1934   1          {
1935   1              Data[2]     = ucModeIdx << 3;
1936   1              ucModeIdx   = ucModeIdx + 1;
1937   1      
1938   1              I2CWrite(Data);
1939   1              Delay_Xms(SET_2404_DELAY);
1940   1          }
1941   1          while (26 > ucModeIdx);
1942   1      */
1943   1          // Reset display settings
1944   1          Data[0]     = 7;
1945   1          Data[1]     = ADDR_EROM0;
1946   1          Data[2]     = 0;
1947   1          Data[3]     = 0x80; // stMUD.H_POSITION;
1948   1          Data[4]     = 0x80; // stMUD.V_POSITION;
1949   1          Data[5]     = 0x80; // stMUD.CLOCK;
1950   1          Data[6]     = 0x01; // stMUD.PHASE;
1951   1      
1952   1          ucModeIdx   = 0;
1953   1          do
1954   1          {
1955   2              Data[2]     = ucModeIdx << 2;
1956   2              ucModeIdx   = ucModeIdx + 1;
1957   2      
1958   2              switch (ucModeIdx)
1959   2              {
1960   3              case MODE_YUV60HZ :
1961   3                  Data[3] = 0xbc;         // VBRIGHT
1962   3                  Data[4] = 0x65 ^ 0x80;  // VCONTRAST
1963   3                  Data[5] = 0x64 ^ 0x80;  // VSATURATION
1964   3                  Data[6] = 0x00 ^ 0x80;  // VHUE
1965   3                  break;
1966   3              case MODE_YUV50HZ :
1967   3                  Data[3] = 0xb1;         // VBRIGHT
1968   3                  Data[4] = 0x5f ^ 0x80;  // VCONTRAST
1969   3                  Data[5] = 0x65 ^ 0x80;  // VSATURATION
1970   3                  Data[6] = 0x00 ^ 0x80;  // VHUE
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 33  

1971   3                  break;
1972   3      #if (VIDEO_CHIP == VDC_SAA7118)
                      case MODE_VIDEO60HZ :
                          Data[3] = 0x96;         // VBRIGHT
                          Data[4] = 0x48 ^ 0x80;  // VCONTRAST
                          Data[5] = 0x4a ^ 0x80;  // VSATURATION
                          Data[6] = 0xff ^ 0x80;  // VHUE
                          break;
                      case MODE_VIDEO50HZ :
                          Data[3] = 0x83;         // VBRIGHT
                          Data[4] = 0x48 ^ 0x80;  // VCONTRAST
                          Data[5] = 0x43 ^ 0x80;  // VSATURATION
                          Data[6] = 0x00 ^ 0x80;  // VHUE
                          break;
              #else
1986   3              case MODE_VIDEO60HZ :
1987   3                  Data[3] = 0x95;         // VBRIGHT
1988   3                  Data[4] = 0x47 ^ 0x80;  // VCONTRAST
1989   3                  Data[5] = 0x48 ^ 0x80;  // VSATURATION
1990   3                  Data[6] = 0xff ^ 0x80;  // VHUE
1991   3                  break;
1992   3              case MODE_VIDEO50HZ :
1993   3                  Data[3] = 0x82;         // VBRIGHT
1994   3                  Data[4] = 0x47 ^ 0x80;  // VCONTRAST
1995   3                  Data[5] = 0x42 ^ 0x80;  // VSATURATION
1996   3                  Data[6] = 0x00 ^ 0x80;  // VHUE
1997   3                  break;
1998   3      #endif
1999   3              }
2000   2              
2001   2              I2CWrite(Data);
2002   2              Delay_Xms(SET_2404_DELAY);
2003   2          }
2004   1          while (64 > ucModeIdx);
2005   1      }
2006          
2007          void Check_EEPROM(void)
2008          {
2009   1          I2CRead(ADDR_EROM1, 0xFE , 2);
2010   1          
2011   1          if ((INIT_EEPROM1[17] != Data[0]) || (INIT_EEPROM1[18] != Data[1]))
2012   1          {
2013   2              Delay_Xms(SET_2404_DELAY);
2014   2      
2015   2              Init_GUD();
2016   2              Init_MUD();
2017   2          }
2018   1          else
2019   1          {
2020   2              Load_GUD0();            // Read Global User Data 0 from EEPROM 2404
2021   2              Load_GUD1();            // Read Global User Data 1 from EEPROM 2404
2022   2              Load_GUD2();            // Read Global User Data 2 from EEPROM 2404
2023   2              Load_GUD3();            // Read Global User Data 3 from EEPROM 2404
2024   2                      Load_GUD4();            // Read Global User Data 4 from EEPROM 2404
2025   2          }
2026   1      }
2027          
2028          void Free_Background(void)  // Force to FreeRun & Background
2029          {
2030   1          RTDCodeW(FreeV);                            // Switch to free-running mode
2031   1      
2032   1          //if (PANEL_OFF == bPANEL_PWR)
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 34  

2033   1          if ( _OFF == bPanel_Status)
2034   1          {
2035   2      
2036   2          RTDSetByte(VDIS_SIGINV_21, 0x00 | DISP_EO_SWAP | DISP_RB_SWAP | DISP_ML_SWAP);       // DHS, DVS, DEN,
             - DCLK MUST NOT be inverted.
2037   2          RTDSetBit(VDIS_CTRL_20, 0xfd, 0x01);    // DHS, DVS, DEN, DCLK and data are clamped to 0
2038   2          }
2039   1      
2040   1          RTDSetBit(VGIP_CTRL_04, 0xfe, 0x00);        // Stop sampling input pixels
2041   1      
2042   1      
2043   1          RTDSetBit(VDIS_SIGINV_21, 0x0f, SOURCE_TV == (stGUD1.INPUT_SOURCE & 0x07) ? 0x10 | DISP_EO_SWAP | DISP
             -_RB_SWAP | DISP_ML_SWAP  : 
2044   1                                                                                  0x00 | DISP_EO_SWAP | DISP_RB_SWAP | 
             -DISP_ML_SWAP);
2045   1      
2046   1      }
2047          
2048          
2049          void Reset_Mode(void)
2050          {  
2051   1          unsigned char ucTimeout = 120;
2052   1      
2053   1      #if(MCU_TYPE == MCU_WINBOND)
2054   1          bLIGHT_PWR  = LIGHT_OFF;        // Turn off BackLight for reset display
2055   1      #else
                  MCU_WriteBacklightPower(LIGHT_OFF);        // Turn off BackLight for reset display
              #endif
2058   1      
2059   1      
2060   1          RTDSetByte(HOSTCTRL_02, 0x40);  // Wake RTD up
2061   1      
2062   1      #if(FIX_LAST_DHT)
                  RTDSetByte(FX_LST_LEN_H_5A,0x00); //Disable the Fixed DVTOTAL & Last Line Lenghth Fucntion
              #endif
2065   1      
2066   1      
2067   1      #if(SPREAD_SPECTRUM)
2068   1        RTDSetBit(SPREAD_SPECTRUM_99,0x0f,0x00); //Disable spread spectrum  
2069   1      #endif
2070   1      #if(AS_NON_FRAMESYNC)
                  RTDSetBit(ODD_CTRL_8E,0xef,0x00);
              #endif
2073   1      
2074   1      #if(AS_PLL_NONLOCK)
2075   1          RTDSetBit(ODD_CTRL_8E,0xdf,0x00);
2076   1      #endif
2077   1      #if(AS_DV_TOTAL)
2078   1          RTDSetBit(DV_BKGD_STA_31,0x7f,0x00);
2079   1      #endif
2080   1      
2081   1      #if(TMDS_ENABLE)
2082   1         RTDSetBit(TMDS_CORRECTION_FF,0xfc,0x00);
2083   1      #endif
2084   1      
2085   1      RTDSetByte(STATUS0_01, 0x00);  // Clear status
2086   1      RTDSetByte(STATUS1_1F, 0x00);  // Clear status
2087   1      RTDSetByte(DV_TOTAL_STATUS_3D,0x00);
2088   1      
2089   1      
2090   1      
2091   1          Free_Background();
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 35  

2092   1          
2093   1          RTDOSDW(OSD_Reset);            // Clear OSD
2094   1              RTDSetBit(OVL_CTRL_6D, 0xfe, 0x00);     // Disable overlay control
2095   1      
2096   1      #if (TUNE_APLL)
2097   1          RTDSetBit(DV_TOTAL_STATUS_3D, 0xdf, 0x00);//Disable PE Max Measurement
2098   1          //RTDSetBit(DV_TOTAL_STATUS_3D, 0x7f,0x40); //clear PE Max value
2099   1              RTDSetByte(DV_TOTAL_STATUS_3D,0x40); //clear PE Max value
2100   1          do
2101   1          {
2102   2               RTDRead(DV_TOTAL_STATUS_3D, 1, N_INC);
2103   2               Delay_Xms(1); 
2104   2                       
2105   2          }while( --ucTimeout && ((Data[0] & 0x40 ) == 0x40));
2106   1              ucPE_Max = 0;
2107   1              ucPE_Level = 0;
2108   1      #endif
2109   1      
2110   1      
2111   1          ucMode_Curr     = MODE_NOSIGNAL;
2112   1          ucMode_Found    = MODE_NOSUPPORT;
2113   1      
2114   1          ucMode_Times    = 0;
2115   1          ucAV_Mode       = 0;
2116   1          bStable         = 0;
2117   1          bReload         = 1;
2118   1          bFrameSync      = 0;
2119   1              ucPE_Max        = 0;
2120   1              ucI_Code        = 0;
2121   1          bOverSpec       = 0;
2122   1      
2123   1          if (SOURCE_AV == ucInputSrc || SOURCE_SV == ucInputSrc || SOURCE_TV == ucInputSrc)
2124   1          {
2125   2              RTDCodeW(VIDEO_INI);
2126   2              I2CWrite((SOURCE_SV == ucInputSrc) ? SV_DETECT : AV_DETECT);
2127   2      
2128   2              if (SOURCE_TV == ucInputSrc)
2129   2              {
2130   3                  // Select TV signal input pin and disable AGC of video decoder
2131   3                  I2CWrite(TV_SOURCE_SEL);
2132   3                  I2CWrite(TV_SCAN_GAIN);
2133   3              }
2134   2          }
2135   1      #if (VIDEO_CHIP == VDC_SAA7118)
                  else if (SOURCE_YUV == ucInputSrc)
                  {
                      RTDCodeW(VIDEO_INI);
                      I2CWrite(YUV_DETECT);
                  }
              #endif
2142   1      
2143   1      }
2144          
2145          
2146          #if (TV_CHIP != TV_NONE)
              
              void Set_TV_Channel()
              {
                  if (0 == stGUD3.CURR_CHANNEL)
                  {
                      stGUD3.CURR_CHANNEL = 1;
                  }
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 36  

                  else if (MAX_CATV_NUM < stGUD3.CURR_CHANNEL)
                  {
                      stGUD3.CURR_CHANNEL = MAX_CATV_NUM;
                  }
                  else if (0 == (stGUD3.TV_SETTING & 0x01) && MAX_AIR_NUM < stGUD3.CURR_CHANNEL)
                  {
                      stGUD3.CURR_CHANNEL = MAX_AIR_NUM;
                  }
              
                  ((unsigned int *)Data)[1]   = (stGUD3.TV_SETTING & 0x01) ? CATV_Freq[stGUD3.CURR_CHANNEL - 1] : AIR_Fr
             -eq[stGUD3.CURR_CHANNEL - 1];
              
              #if (TV_CHIP == TV_FI1236)
              
                  Data[0] = 6;
                  Data[1] = ADDR_TUNER;
                  Data[4] = 0xce;
                  Data[5] = (VHF_LOW_FREQ > (((unsigned int *)Data)[1] / 16)) ? 0xa0 : (VHF_HIGH_FREQ > (((unsigned int 
             -*)Data)[1] / 16)) ? 0x90 : 0x30;
              
                  I2CWrite(Data);
              
              #endif
              
              #if (TV_CHIP == TV_FQ1216)
              
                  Data[0] = 6;
                  Data[1] = ADDR_TUNER;
                  Data[4] = 0x8e;
                  Data[5] = (VHF_LOW_FREQ > (((unsigned int *)Data)[1] / 16)) ? 0xa1 : (VHF_HIGH_FREQ > (((unsigned int 
             -*)Data)[1] / 16)) ? 0x91 : 0x31;
              
                  I2CWrite(Data);  
              
              #endif
              }
              
              void Prev_Channel()
              {
                  if (0 == stGUD3.CURR_CHANNEL)   stGUD3.CURR_CHANNEL = 1;
              
                  stGUD3.PREV_CHANNEL = stGUD3.CURR_CHANNEL;
              
                  Data[1] = 0;
              
                  while (1)
                  {
                      if (1 == stGUD3.CURR_CHANNEL)
                          stGUD3.CURR_CHANNEL = (stGUD3.TV_SETTING & 0x01) ? MAX_CATV_NUM : MAX_AIR_NUM;
                      else
                          stGUD3.CURR_CHANNEL = stGUD3.CURR_CHANNEL - 1;
              
                      if (stGUD3.PREV_CHANNEL == stGUD3.CURR_CHANNEL)     break;
              
                      Data[2] = stGUD3.CURR_CHANNEL - 1;
                      Data[3] = 1 << (7 - (Data[2] & 0x07));
                      Data[4] = 0xd0 + (Data[2] >> 3);
              
                      if (Data[4] != Data[1])
                      {
                          Data[1] = Data[4];
                          I2CRead(ADDR_EROM1, Data[4], 1);
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 37  

                      }
              
                      if (Data[0] & Data[3])
                      {
                          Set_TV_Channel();
                          Save_GUD3();
                          break;
                      }
                  }
              }
              
              void Next_Channel()
              {
                  if (0 == stGUD3.CURR_CHANNEL)   stGUD3.CURR_CHANNEL = 1;
              
                  stGUD3.PREV_CHANNEL = stGUD3.CURR_CHANNEL;
              
                  Data[1] = 0;
              
                  while (1)
                  {
                      if (((0 == (stGUD3.TV_SETTING & 0x01)) && (MAX_AIR_NUM == stGUD3.CURR_CHANNEL)) || MAX_CATV_NUM ==
             - stGUD3.CURR_CHANNEL)
                          stGUD3.CURR_CHANNEL = 1;
                      else
                          stGUD3.CURR_CHANNEL = stGUD3.CURR_CHANNEL + 1;
              
                      if (stGUD3.PREV_CHANNEL == stGUD3.CURR_CHANNEL)     break;
              
                      Data[2] = stGUD3.CURR_CHANNEL - 1;
                      Data[3] = 1 << (7 - (Data[2] & 0x07));
                      Data[4] = 0xd0 + (Data[2] >> 3);
              
                      if (Data[4] != Data[1])
                      {
                          Data[1] = Data[4];
                          I2CRead(ADDR_EROM1, Data[4], 1);
                      }
              
                      if (Data[0] & Data[3])
                      {
                          Set_TV_Channel();
                          Save_GUD3();
                          break;
                      }
                  }
              }
              
              #endif
2261          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -////////////
2262          // THE CODE BELOW IS ONLY FOR DEBUG
2263          // RTD_Get_Set()    - For ICE
2264          // RTD_Test()       - For KINGMICE
2265          // OSD_Show_Check() - Display information on OSD
2266          //////////////////////////////////////////////////////////////////////////////////////////////////////////
             -////////////
2267          
2268          #if (GETREGISTER)
              void RTD_Get_Set(void)
              {
                  if (ucGETCHIP)
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 38  

                  {
                      if (ucGETCHIP & 0xf0)   // write
                      {   
                          Data[0] = 4;
                          Data[2] = ucGETADDR;
                          Data[3] = ucGETDATA0;
                          Data[4] = 0;
                          
                          switch (ucGETCHIP & 0x0f)
                          {
                          case 01 : //RTD
                              Data[1] = N_INC;
                              RTDWrite(Data);
                              break;
                          case 02 : //ADC
                              Data[1] = ADDR_ADC;
                              I2CWrite(Data);  
                              break;
                          case 03 : //VIDEO
                              Data[1] = ADDR_VIDEO;
                              I2CWrite(Data);  
                              break;
                          case 04 : //EEPROM0
                              Data[1] = ADDR_EROM0;
                              I2CWrite(Data);
                              break;
                          case 05 : //EEPROM1
                              Data[1] = ADDR_EROM1;
                              I2CWrite(Data);
                              break;
                          default:
                              break;
                          }
                      }
                      else    // read
                      {
                          switch (ucGETCHIP)
                          {
                          case 01 : //RTD
                              RTDRead(ucGETADDR, 2, Y_INC);
                              break;
                          case 02 : //ADC
                              I2CRead(ADDR_ADC, ucGETADDR , 2);
                              break;
                          case 03 : //VIDEO
                              I2CRead(ADDR_VIDEO, ucGETADDR , 2);
                              break;
                          case 04 : //EEPROM0
                              I2CRead(ADDR_EROM0, ucGETADDR , 2);
                              break;
                          case 05 : //EEPROM1
                              I2CRead(ADDR_EROM1, ucGETADDR , 2);
                              break;
                          default:
                              break;
                          }
                          ucGETDATA0  = Data[0];
                          ucGETDATA1  = Data[1];
                      }
                      ucGETCHIP   = 0;
                  }
              }
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 39  

              #endif
2335          
2336          #if (KINGMICE)
              
              void RTD_Test(void)
              {
                  static unsigned char idata ucI2C_Addr;
                  static unsigned char idata ucI2C_Data;
                  static unsigned char idata ucRTD_Data;
              
                  do
                  {
                      while (ucROM_A4 & 0x01)             // if action,
                      {
                          if (ucROM_A4 & 0x02)            // read   
                          {                            
                              if (ucROM_A4 & 0x10)        // if IIC_index        
                              {       
                                  I2CRead(ucI2C_Addr, ucROM_A3, 0x01);
                                  ucPRN_7 = Data[0];
                              }
                              else if (ucROM_A4 & 0x40)   // if RTD_index 
                              {
                                  RTDRead(ucROM_A3, 0x01, N_INC);                   
                                  ucPRN_7 = Data[0];
                              }
                              else if (ucROM_A4 & 0x80)   // if 8051_index 
                              {
                                  ucPRN_7 = *((unsigned char *)ucROM_A3);
                              }
                          }
                          else                            // write
                          {                            
                              if (ucROM_A4 & 0x04)        // if IIC_addr
                              {
                                  ucI2C_Addr  = ucROM_A3;
                              }
                              else if (ucROM_A4 & 0x08)   // if IIC_data
                              {
                                  ucI2C_Data  = ucROM_A3;
                              }
                              else if (ucROM_A4 & 0x10)   // if IIC_index 
                              {                       
                                  Data[0] = 4;
                                  Data[1] = ucI2C_Addr;
                                  Data[2] = ucROM_A3;
                                  Data[3] = ucI2C_Data;
                                  I2CWrite(Data);
                              }
                              else if (ucROM_A4 & 0x20)   // if RTD_data 
                              {
                                  ucRTD_Data  =  ucROM_A3;
                              }
                              else if (ucROM_A4 & 0x40)   // if RTD_index 
                              {                                       
                                  Data[0] = 4;
                                  Data[1] = N_INC;
                                  Data[2] = ucROM_A3;
                                  Data[3] = ucRTD_Data;
                                  Data[4] = 0;
                                  RTDWrite(Data);
                              }                
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 40  

                              else if (ucROM_A4 & 0x80)   // if 8051_index 
                              {                                      
                                  *((unsigned char *)ucROM_A3)    = Data[0];
                              }                 
                          } 
                          
                          if (ucROM_A5)   { }         // clear action 
                      }                               
                  }
                  while (ucROM_A0 & 0x80);
              }
              
              
              
              #else
2411          
2412          void RTD_Test(void)
2413          {
2414   1      
2415   1      #if(ISPACK)
                 static unsigned char idata  ucAddr, ucValue;
              
                  unsigned char   ucStatus, ucStop, DDC_SUB_IN, DDC_DATA_IN;
                      unsigned char idata *MEM_MAP;
              
              //      Data[0] = (unsigned char)(usHsync >> 8);
              //      Data[1] = (unsigned char)usHsync;
              //      Data[2] = (unsigned char)(usVsync >> 8);
              //      Data[3] = (unsigned char)usVsync;
              //      Data[4] = stGUD1.OSD_POSV;
              //      Data[5] = ucV_Min_Margin;
              //      Data[6] = stMUD.V_POSITION;
              //      Data[7] = (unsigned char)(usIPV_ACT_STA >> 8);
              //      Data[8] = (unsigned char)(usIPV_ACT_STA);
              
                  ucStop  = 0;
                  do
                  {
                          RTDRead(DDC_STATUS_F4, 1,N_INC);
              
                      //ucStatus    = DDC_STATUS;       // read DDC_STATUS;
                              ucStatus    = Data[0];       // read DDC_STATUS;
                      
                      if (ucStatus & 0x04)            // DDC_DATA_IN latched
                      {
                                  RTDRead(DDC_SUB_IN_F1, 2, Y_INC);
                                      DDC_SUB_IN = Data[0];
                                      DDC_DATA_IN = Data[1];
              
                          RTDSetByte(DDC_STATUS_F4,0x00);  //Write once to clear status
              
                          if (DDC_SUB_IN & 0x80)      // run/stop command             
                          {
                              ucStop = DDC_DATA_IN;
                                              
                          }
                          else if (DDC_SUB_IN & 0x40) // read command
                          {
                              switch (DDC_SUB_IN & 0x0f)
                              {
                              case 0x01 :
                                  //RTD_ADDR_PORT   = DDC_DATA_IN;
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 41  

                                  //DDC_DATA_OUT    = RTD_DATA_PORT;  
                                                      RTDRead(DDC_DATA_IN, 1, N_INC);
                                                      RTDSetByte(DDC_DATA_OUT_F3, Data[0]);
                                  break;
              
              //#if(ISPACK) 
              //               case 0x02 :
              //                              ucValue = DDC_DATA_IN;
              //                              DDC_DATA_OUT    = Data[ucValue];
              //                         break;
              //#endif
              
                              case 0x04 :
                                  I2CRead(ucAddr, DDC_DATA_IN, 1);
                                  //DDC_DATA_OUT    = Data[0];
                                  RTDSetByte(DDC_DATA_OUT_F3, Data[0]);
                                  break;
                              case 0x05 :
                                  //DDC_DATA_OUT    = *((unsigned char *)DDC_DATA_IN);
                                                      MEM_MAP = DDC_DATA_IN;
                                                      RTDSetByte(DDC_DATA_OUT_F3, *MEM_MAP);
                                  break;
                              case 0x07 :
                                  switch (DDC_DATA_IN)
                                  {
                                  case 0x80:
                                      //DDC_DATA_OUT    = P0;
                                                              RTDSetByte(DDC_DATA_OUT_F3, P0);
                                      break;
                                  case 0x90:
                                      //DDC_DATA_OUT    = P1;
                                                              RTDSetByte(DDC_DATA_OUT_F3, P1);
                                      break;
                                  case 0xa0:
                                      //DDC_DATA_OUT    = P2;
                                                              RTDSetByte(DDC_DATA_OUT_F3, P2);
                                      break;
                                  case 0xb0:
                                      //DDC_DATA_OUT    = P3;
                                                              RTDSetByte(DDC_DATA_OUT_F3, P3);
                                      break;                    
              #if(GETSFR)
                                                      default:
                                                          //DDC_DATA_OUT    = GetSFRPort(DDC_DATA_IN);
                                                              RTDSetByte(DDC_DATA_OUT_F3, GetSFRPort(DDC_DATA_IN));
                                                              break;
              #endif
                                  }
                                  
                              }
                          }
                          else
                          {
                              switch (DDC_SUB_IN & 0x0f)
                              {
                              case 0x00 :
                                  //RTD_ADDR_PORT   = ucAddr;
                                  //RTD_DATA_PORT   = DDC_DATA_IN;
                                                      RTDSetByte(ucAddr,DDC_DATA_IN);
                                  break;
                              case 0x01 :
                              case 0x02 :
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 42  

                                  ucAddr  = DDC_DATA_IN;
                                  break;
                              case 0x03 :
                              case 0x06 :
                              case 0x08 :
                                  ucValue = DDC_DATA_IN;
                                  break;
                              case 0x04 :
                                  Data[0] = 4;
                                  Data[1] = ucAddr;
                                  Data[2] = DDC_DATA_IN;
                                  Data[3] = ucValue;
                                  I2CWrite(Data);
                                  break;
                              case 0x05 :
                                  MEM_MAP = DDC_DATA_IN;
              
                                  break;
                              case 0x07 :
                                                  ucAddr = DDC_DATA_IN;
                                  switch (ucAddr)
                                  {
                                  case 0x80 :
                                      //SetPortBit(0, 0, ucValue);  
                                                          P0  = ucValue;
                                      break;
                                  case 0x90 :
                                      //SetPortBit(1, 0, ucValue);  
                                                          P1  = ucValue;
                                      break;
                                  case 0xa0 :
                                      //SetPortBit(2, 0, ucValue);  
                                                          P2  = ucValue;
                                      break;
                                  case 0xb0 :
                                      //SetPortBit(3, 0, ucValue);  
                                                          P3  = ucValue;
                                      break;                    
              #if(GETSFR)
                                                      default:
                                                          SetSFRPort(ucAddr, ucValue);
                                                              break;
              #endif
                                  }
                                  break;
                              }
                          }
                      }
                  }
                  while (1 == ucStop);
              
              #endif
2572   1      
2573   1      }
2574          
2575          
2576          #endif
2577          ////////////////////////////////////////////////////////////////////////////////////////////
2578          //      anson add
2579          ////////////////////////////////////////////////////////////////////////////////////////////
2580          void Set_Spread(void)
2581          {
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 43  

2582   1              RTDSetBit(SPREAD_SPECTRUM_99, 0x00, (stGUD3.SPREAD << 4));
2583   1              RTDSetBit(DCLK_OFFSET_MSB_9B, 0xff, 0x20);
2584   1      }
2585          
2586          void Init_FRecall(void)                         //anson
2587          {
2588   1              stGUD0.CONTRAST         = INIT_EEPROM0[3];
2589   1              stGUD0.BRIGHT           = INIT_EEPROM0[4];
2590   1      //      stGUD0.RTD_R_CONTRAST   = INIT_EEPROM0[5];
2591   1      //      stGUD0.RTD_G_CONTRAST   = INIT_EEPROM0[6];
2592   1      //      stGUD0.RTD_B_CONTRAST   = INIT_EEPROM0[7];
2593   1              stGUD0.RTD_R_BRIGHT     = INIT_EEPROM0[8];
2594   1              stGUD0.RTD_G_BRIGHT     = INIT_EEPROM0[9];
2595   1              stGUD0.RTD_B_BRIGHT     = INIT_EEPROM0[10];
2596   1              
2597   1              stGUD1.FUNCTION         = INIT_EEPROM0[11];
2598   1              stGUD1.INPUT_SOURCE     = INIT_EEPROM0[12];
2599   1              stGUD1.FILTER           = INIT_EEPROM0[13];
2600   1              stGUD1.OSD_POSH         = INIT_EEPROM0[14];
2601   1              stGUD1.OSD_POSV         = INIT_EEPROM0[15];
2602   1              stGUD1.OSD_TIMEOUT      = INIT_EEPROM0[16];
2603   1              stGUD1.OSD_INPUT      = INIT_EEPROM0[17];
2604   1      
2605   1              stGUD3.VOLUME           = INIT_EEPROM1[11];
2606   1              stGUD3.CURR_CHANNEL     = INIT_EEPROM1[12];
2607   1              stGUD3.PREV_CHANNEL     = INIT_EEPROM1[13];
2608   1      
2609   1              I2CWrite(INIT_EEPROM0);
2610   1              Delay_Xms(SET_2404_DELAY);
2611   1              
2612   1      //      I2CWrite(INIT_EEPROM1);         //anson 1223
2613   1      //      Delay_Xms(SET_2404_DELAY);
2614   1      
2615   1              Save_GUD0();
2616   1              Save_GUD3();                                    //anson 05_0303
2617   1      }
2618          
2619          void Init_FACTORY(void)         //anson
2620          {
2621   1              unsigned char   ucTemp1, ucTemp2;
2622   1      
2623   1              // Save the global settings we don't want to reset
2624   1              ucTemp1 = stGUD1.FUNCTION & 0x07;       // Language select
2625   1              ucTemp2 = stGUD1.INPUT_SOURCE & 0x07;   // Source select
2626   1      
2627   1              if (JAPANESS < ucTemp1)
2628   1                      ucTemp1 = ENGLISH;
2629   1      
2630   1              // Reset OSD time-out timer
2631   1              usOSD_Timer = (unsigned int)2 << 9;     // 20 sec
2632   1      
2633   1              // Reset global settings to default
2634   1              Init_FRecall();
2635   1      
2636   1              // Reset OSD time-out timer
2637   1              usOSD_Timer = (unsigned int)stGUD1.OSD_TIMEOUT << 9;
2638   1      
2639   1              // Restore the global settings we don't want to reset
2640   1              stGUD1.FUNCTION     = (stGUD1.FUNCTION & 0xf8) | ucTemp1;
2641   1              stGUD1.INPUT_SOURCE = (stGUD1.INPUT_SOURCE & 0xf8) | ucTemp2;
2642   1              Save_GUD1();
2643   1      
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 44  

2644   1              // Reset brightness and contrast to default
2645   1              Set_Bright_Contrast();
2646   1              SetADC_Gain();                          //anson
2647   1                      
2648   1      #if (AUDIO_TYPE != AUDIO_NONE)
2649   1                      SetVolume();
2650   1      #endif
2651   1      
2652   1              if (SOURCE_VGA == (stGUD1.INPUT_SOURCE & 0x07))
2653   1              {
2654   2                      if (ERROR_INPUT == Auto_Config())   ucMode_Curr = MODE_OSDFORCE;
2655   2              }
2656   1      
2657   1              // Reset OSD position
2658   1              OSD_Position(OSD_ENABLE);
2659   1      
2660   1              // Reset all mode settings to default
2661   1              Init_MUD();
2662   1      
2663   1              // Read default settings for current mode
2664   1              Load_MUD(ucMode_Curr);
2665   1      
2666   1              // Leave current mode and search mode again
2667   1      //      ucMode_Curr = MODE_OSDFORCE;
2668   1      }
2669          
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 45  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com00F3 (BEGIN)
0000         L?0244:
0000 120000      E     LCALL   ?C?ULDIV
0003 8F00        E     MOV     Data+0BH,R7
0005 8E00        E     MOV     Data+0AH,R6
0007 8D00        E     MOV     Data+09H,R5
0009 8C00        E     MOV     Data+08H,R4
000B AB00        E     MOV     R3,Data+0BH
000D AA00        E     MOV     R2,Data+0AH
000F A900        E     MOV     R1,Data+09H
0011 A800        E     MOV     R0,Data+08H
0013 7FF0              MOV     R7,#0F0H
0015 7ED8              MOV     R6,#0D8H
0017 7DEB              MOV     R5,#0EBH
0019 7C13              MOV     R4,#013H
001B 120000      E     LCALL   ?C?ULDIV
001E 8E00        E     MOV     Data+02H,R6
0020 8F00        E     MOV     Data+03H,R7
0022 740E              MOV     A,#0EH
0024         L?0245:
0024 D3                SETB    C
0025         L?0246:
0025 9500        E     SUBB    A,Data+03H
0027 7406              MOV     A,#06H
0029 9500        E     SUBB    A,Data+02H
002B 22                RET     
002C         L?0247:
002C E4                CLR     A
002D 93                MOVC    A,@A+DPTR
002E F500        R     MOV     stGUD0+05H,A
0030 A3                INC     DPTR
0031 E4                CLR     A
0032 93                MOVC    A,@A+DPTR
0033 F500        R     MOV     stGUD0+06H,A
0035 A3                INC     DPTR
0036 E4                CLR     A
0037 93                MOVC    A,@A+DPTR
0038 F500        R     MOV     stGUD0+07H,A
003A A3                INC     DPTR
003B E4                CLR     A
003C 93                MOVC    A,@A+DPTR
003D F500        R     MOV     stGUD1,A
003F A3                INC     DPTR
0040 E4                CLR     A
0041 93                MOVC    A,@A+DPTR
0042 F500        R     MOV     stGUD1+01H,A
0044 A3                INC     DPTR
0045 E4                CLR     A
0046 93                MOVC    A,@A+DPTR
0047 F500        R     MOV     stGUD1+02H,A
0049 A3                INC     DPTR
004A E4                CLR     A
004B 93                MOVC    A,@A+DPTR
004C 750000      R     MOV     stGUD1+03H,#00H
004F F500        R     MOV     stGUD1+04H,A
0051 A3                INC     DPTR
0052 E4                CLR     A
0053 93                MOVC    A,@A+DPTR
0054 F500        R     MOV     stGUD1+05H,A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 46  

0056 A3                INC     DPTR
0057 E4                CLR     A
0058 93                MOVC    A,@A+DPTR
0059 F500        R     MOV     stGUD1+06H,A
005B A3                INC     DPTR
005C E4                CLR     A
005D 93                MOVC    A,@A+DPTR
005E F500        R     MOV     stGUD1+07H,A
0060 22                RET     
0061         L?0248:
0061         L?0249:
0061 7800        E     MOV     R0,#LOW usStdHS
0063 E6                MOV     A,@R0
0064 FE                MOV     R6,A
0065 08                INC     R0
0066 E6                MOV     A,@R0
0067 FB                MOV     R3,A
0068 AA06              MOV     R2,AR6
006A E4                CLR     A
006B F9                MOV     R1,A
006C F8                MOV     R0,A
006D 22                RET     
006E         L?0250:
006E         L?0251:
006E AF00        R     MOV     R7,ucTemp0
0070 E4                CLR     A
0071 FC                MOV     R4,A
0072 FD                MOV     R5,A
0073 FE                MOV     R6,A
0074 AB00        R     MOV     R3,ulRate+03H
0076 AA00        R     MOV     R2,ulRate+02H
0078 A900        R     MOV     R1,ulRate+01H
007A A800        R     MOV     R0,ulRate
007C 020000      E     LJMP    ?C?LMUL
007F         L?0252:
007F         L?0253:
007F FF                MOV     R7,A
0080 E4                CLR     A
0081 33                RLC     A
0082 FE                MOV     R6,A
0083 AD00        E     MOV     R5,Data+06H
0085 7C00              MOV     R4,#00H
0087 120000      E     LCALL   ?C?IMUL
008A 7D64              MOV     R5,#064H
008C 020000      E     LJMP    ?C?UIDIV
008F         L?0254:
008F 7800        R     MOV     R0,#LOW usADC_Clock
0091 E6                MOV     A,@R0
0092 FE                MOV     R6,A
0093 08                INC     R0
0094 E6                MOV     A,@R0
0095 FF                MOV     R7,A
0096         L?0255:
0096 E4                CLR     A
0097 FC                MOV     R4,A
0098 FD                MOV     R5,A
0099 FB                MOV     R3,A
009A 7A60              MOV     R2,#060H
009C F9                MOV     R1,A
009D F8                MOV     R0,A
009E 020000      E     LJMP    ?C?LMUL
00A1         L?0258:
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 47  

00A1         L?0259:
00A1 C294              CLR     bRTD_SCLK
00A3 D294              SETB    bRTD_SCLK
00A5 D295              SETB    bRTD_SCSB
00A7 22                RET     
00A8         L?0260:
00A8 7800        R     MOV     R0,#LOW usADC_Clock
00AA E6                MOV     A,@R0
00AB FE                MOV     R6,A
00AC 08                INC     R0
00AD E6                MOV     A,@R0
00AE FF                MOV     R7,A
00AF E4                CLR     A
00B0 FC                MOV     R4,A
00B1 FD                MOV     R5,A
00B2 7B62              MOV     R3,#062H
00B4 FA                MOV     R2,A
00B5 F9                MOV     R1,A
00B6 F8                MOV     R0,A
00B7 020000      E     LJMP    ?C?LMUL
00BA         L?0261:
00BA         L?0262:
00BA 7B00              MOV     R3,#00H
00BC 7A00        E     MOV     R2,#HIGH Data
00BE 7900        E     MOV     R1,#LOW Data
00C0 22                RET     
00C1         L?0263:
00C1 900000      R     MOV     DPTR,#INIT_EEPROM1+0BH
00C4 E4                CLR     A
00C5 93                MOVC    A,@A+DPTR
00C6 F500        R     MOV     stGUD3,A
00C8 A3                INC     DPTR
00C9 E4                CLR     A
00CA 93                MOVC    A,@A+DPTR
00CB F500        R     MOV     stGUD3+01H,A
00CD A3                INC     DPTR
00CE E4                CLR     A
00CF 93                MOVC    A,@A+DPTR
00D0 F500        R     MOV     stGUD3+02H,A
00D2 22                RET     
00D3         L?0264:
00D3 F500        R     MOV     usIV_Temp+01H,A
00D5 ED                MOV     A,R5
00D6 34FF              ADDC    A,#0FFH
00D8 F500        R     MOV     usIV_Temp,A
00DA 7800        R     MOV     R0,#LOW ucDV_Delay
00DC E6                MOV     A,@R0
00DD 2F                ADD     A,R7
00DE FF                MOV     R7,A
00DF E4                CLR     A
00E0 33                RLC     A
00E1 CF                XCH     A,R7
00E2 22                RET     
00E3         L?0265:
00E3 850000      E     MOV     Data,Data+02H
00E6 850000      E     MOV     Data+01H,Data+03H
00E9         L?0266:
00E9 850000      R     MOV     ucN_Code,ucTemp0
00EC 850000      R     MOV     ucM_Code,ucTemp1
00EF 22                RET     
00F0         L?0269:
00F0 C3                CLR     C
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 48  

00F1 740E              MOV     A,#0EH
00F3 9500        E     SUBB    A,Data+03H
00F5 F500        E     MOV     Data+03H,A
00F7 7406              MOV     A,#06H
00F9 9500        E     SUBB    A,Data+02H
00FB F500        E     MOV     Data+02H,A
00FD 22                RET     
00FE         L?0270:
00FE 74F2              MOV     A,#0F2H
0100 2500        E     ADD     A,Data+03H
0102 F500        E     MOV     Data+03H,A
0104 74F9              MOV     A,#0F9H
0106 3500        E     ADDC    A,Data+02H
0108 F500        E     MOV     Data+02H,A
010A 22                RET     
010B         L?0271:
010B 120000      E     LCALL   ?C?ULDIV
010E E4                CLR     A
010F 7B04              MOV     R3,#04H
0111 FA                MOV     R2,A
0112 F9                MOV     R1,A
0113 F8                MOV     R0,A
0114 020000      E     LJMP    ?C?ULDIV
0117         L?0272:
0117 900000      R     MOV     DPTR,#INIT_EEPROM0+03H
011A E4                CLR     A
011B 93                MOVC    A,@A+DPTR
011C F500        R     MOV     stGUD0,A
011E A3                INC     DPTR
011F E4                CLR     A
0120 93                MOVC    A,@A+DPTR
0121 F500        R     MOV     stGUD0+01H,A
0123 22                RET     
0124         L?0273:
0124 120000      E     LCALL   ?C?ULDIV
0127 8F00        R     MOV     ulRate+03H,R7
0129 8E00        R     MOV     ulRate+02H,R6
012B 8D00        R     MOV     ulRate+01H,R5
012D 8C00        R     MOV     ulRate,R4
012F 22                RET     
0130         L?0276:
0130 750006      E     MOV     Data,#06H
0133 E4                CLR     A
0134 F500        E     MOV     Data+01H,A
0136 750090      E     MOV     Data+02H,#090H
0139 22                RET     
013A         L?0277:
013A         L?0278:
013A 750005      E     MOV     Data,#05H
013D E4                CLR     A
013E F500        E     MOV     Data+01H,A
0140 22                RET     
0141         L?0279:
0141 D3                SETB    C
0142 E500        E     MOV     A,Data+01H
0144 9500        E     SUBB    A,Data+03H
0146 E500        E     MOV     A,Data
0148 9500        E     SUBB    A,Data+02H
014A 22                RET     
014B         L?0280:
014B         L?0281:
014B 13                RRC     A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 49  

014C 13                RRC     A
014D 543F              ANL     A,#03FH
014F 2458              ADD     A,#058H
0151 22                RET     
             ; FUNCTION Com00F3 (END)

             ; FUNCTION SetMute (BEGIN)
                                           ; SOURCE LINE # 19
                                           ; SOURCE LINE # 20
                                           ; SOURCE LINE # 22
0000 20000B      R     JB      val,?C0001
                                           ; SOURCE LINE # 23
                                           ; SOURCE LINE # 24
0003 E4                CLR     A
0004 900000      E     MOV     DPTR,#M512_Port61
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 25
0008 900000      E     MOV     DPTR,#M512_Port64
000B 04                INC     A
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 26
000D 22                RET     
000E         ?C0001:
                                           ; SOURCE LINE # 28
                                           ; SOURCE LINE # 29
000E 900000      E     MOV     DPTR,#M512_Port61
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 30
0014 E4                CLR     A
0015 900000      E     MOV     DPTR,#M512_Port64
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 31
                                           ; SOURCE LINE # 46
0019         ?C0003:
0019 22                RET     
             ; FUNCTION SetMute (END)

             ; FUNCTION SetVolume (BEGIN)
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 53
                                           ; SOURCE LINE # 54
0000 53001F      R     ANL     stGUD3,#01FH
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
0003 120000      R     LCALL   L?0276
                                           ; SOURCE LINE # 95
0006 F500        E     MOV     Data+03H,A
                                           ; SOURCE LINE # 96
0008 750001      E     MOV     Data+04H,#01H
                                           ; SOURCE LINE # 100
000B E500        R     MOV     A,stGUD3
000D 33                RLC     A
000E 33                RLC     A
000F 33                RLC     A
0010 54F8              ANL     A,#0F8H
0012 F500        E     MOV     Data+05H,A
                                           ; SOURCE LINE # 102
0014 E4                CLR     A
0015 F500        E     MOV     Data+06H,A
                                           ; SOURCE LINE # 103
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 50  

0017 7F00        E     MOV     R7,#LOW Data
0019 020000      E     LJMP    _RTDWrite
             ; FUNCTION SetVolume (END)

             ; FUNCTION _WriteGamma (BEGIN)
                                           ; SOURCE LINE # 107
0000 8E00        R     MOV     arrayR,R6
0002 8F00        R     MOV     arrayR+01H,R7
0004 8C00        R     MOV     arrayG,R4
0006 8D00        R     MOV     arrayG+01H,R5
0008 8A00        R     MOV     arrayB,R2
000A 8B00        R     MOV     arrayB+01H,R3
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 109
000C E4                CLR     A
000D F500        R     MOV     n,A
                                           ; SOURCE LINE # 111
000F 7B10              MOV     R3,#010H
0011 7DFB              MOV     R5,#0FBH
0013 7F5D              MOV     R7,#05DH
0015 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 115
0018 C295              CLR     bRTD_SCSB
                                           ; SOURCE LINE # 116
001A 7B01              MOV     R3,#01H
001C E4                CLR     A
001D FD                MOV     R5,A
001E 7F64              MOV     R7,#064H
0020 120000      E     LCALL   _RTDSendAddr
0023         ?C0007:
                                           ; SOURCE LINE # 118
                                           ; SOURCE LINE # 119
0023 E500        R     MOV     A,arrayR+01H
0025 2500        R     ADD     A,n
0027 F582              MOV     DPL,A
0029 E4                CLR     A
002A 3500        R     ADDC    A,arrayR
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 121
002C 120000      R     LCALL   L?0256
002F 70F2              JNZ     ?C0007
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 126
0031 120000      R     LCALL   L?0258
                                           ; SOURCE LINE # 129
0034 C295              CLR     bRTD_SCSB
                                           ; SOURCE LINE # 139
0036 7B01              MOV     R3,#01H
0038 FD                MOV     R5,A
0039 7F65              MOV     R7,#065H
003B 120000      E     LCALL   _RTDSendAddr
003E         ?C0010:
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
003E E500        R     MOV     A,arrayG+01H
0040 2500        R     ADD     A,n
0042 F582              MOV     DPL,A
0044 E4                CLR     A
0045 3500        R     ADDC    A,arrayG
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 144
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 51  

0047 120000      R     LCALL   L?0256
004A 70F2              JNZ     ?C0010
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 147
                                           ; SOURCE LINE # 148
004C 120000      R     LCALL   L?0258
                                           ; SOURCE LINE # 151
004F C295              CLR     bRTD_SCSB
                                           ; SOURCE LINE # 160
0051 7B01              MOV     R3,#01H
0053 FD                MOV     R5,A
0054 7F66              MOV     R7,#066H
0056 120000      E     LCALL   _RTDSendAddr
0059         ?C0013:
                                           ; SOURCE LINE # 162
                                           ; SOURCE LINE # 163
0059 E500        R     MOV     A,arrayB+01H
005B 2500        R     ADD     A,n
005D F582              MOV     DPL,A
005F E4                CLR     A
0060 3500        R     ADDC    A,arrayB
0062 F583              MOV     DPH,A
0064 E4                CLR     A
0065 93                MOVC    A,@A+DPTR
0066 FF                MOV     R7,A
0067 120000      E     LCALL   _RTDSendByte
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
006A 0500        R     INC     n
006C E500        R     MOV     A,n
006E 70E9              JNZ     ?C0013
                                           ; SOURCE LINE # 168
                                           ; SOURCE LINE # 169
                                           ; SOURCE LINE # 170
0070 120000      R     LCALL   L?0259
                                           ; SOURCE LINE # 178
0073 7B04              MOV     R3,#04H
0075 7DEF              MOV     R5,#0EFH
0077 7F5D              MOV     R7,#05DH
0079 020000      E     LJMP    _RTDSetBit
                                           ; SOURCE LINE # 179
007C         L?0256:
007C F583              MOV     DPH,A
007E E4                CLR     A
007F 93                MOVC    A,@A+DPTR
0080 FF                MOV     R7,A
0081 120000      E     LCALL   _RTDSendByte
0084 0500        R     INC     n
0086 E500        R     MOV     A,n
0088 22                RET     
             ; FUNCTION _WriteGamma (END)

             ; FUNCTION _WriteDither (BEGIN)
                                           ; SOURCE LINE # 181
0000 8E00        R     MOV     array,R6
0002 8F00        R     MOV     array+01H,R7
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 184
0004 300006      R     JNB     new_dither,?C0015
                                           ; SOURCE LINE # 185
0007 7B80              MOV     R3,#080H
0009 7DFF              MOV     R5,#0FFH
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 52  

000B 8004              SJMP    ?C0220
000D         ?C0015:
                                           ; SOURCE LINE # 187
000D E4                CLR     A
000E FB                MOV     R3,A
000F 7D7F              MOV     R5,#07FH
0011         ?C0220:
0011 7F5A              MOV     R7,#05AH
0013 120000      E     LCALL   _RTDSetBit
0016         ?C0016:
                                           ; SOURCE LINE # 189
0016 7B68              MOV     R3,#068H
0018 7DB7              MOV     R5,#0B7H
001A 7F5D              MOV     R7,#05DH
001C 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 192
001F C295              CLR     bRTD_SCSB
                                           ; SOURCE LINE # 193
0021 7B01              MOV     R3,#01H
0023 E4                CLR     A
0024 FD                MOV     R5,A
0025 7F67              MOV     R7,#067H
0027 120000      E     LCALL   _RTDSendAddr
                                           ; SOURCE LINE # 195
002A E4                CLR     A
002B F500        R     MOV     n,A
002D         ?C0017:
002D E500        R     MOV     A,array+01H
002F 2500        R     ADD     A,n
0031 F582              MOV     DPL,A
0033 E4                CLR     A
0034 3500        R     ADDC    A,array
0036 F583              MOV     DPH,A
0038 E4                CLR     A
0039 93                MOVC    A,@A+DPTR
003A FF                MOV     R7,A
003B 120000      E     LCALL   _RTDSendByte
003E 0500        R     INC     n
0040 E500        R     MOV     A,n
0042 C3                CLR     C
0043 9408              SUBB    A,#08H
0045 40E6              JC      ?C0017
0047         ?C0018:
                                           ; SOURCE LINE # 197
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
0047 120000      R     LCALL   L?0259
                                           ; SOURCE LINE # 212
004A 7B88              MOV     R3,#088H
004C 7D1F              MOV     R5,#01FH
004E 7F5D              MOV     R7,#05DH
0050 020000      E     LJMP    _RTDSetBit
             ; FUNCTION _WriteDither (END)

             ; FUNCTION _WriteSU_COEF (BEGIN)
                                           ; SOURCE LINE # 215
0000 8E00        R     MOV     arrayH,R6
0002 8F00        R     MOV     arrayH+01H,R7
0004 8C00        R     MOV     arrayV,R4
0006 8D00        R     MOV     arrayV+01H,R5
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 221
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 53  

0008 7B01              MOV     R3,#01H
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
                                           ; SOURCE LINE # 225
000A 120000      R     LCALL   L?0257
000D         ?C0021:
000D E500        R     MOV     A,arrayH+01H
000F 2500        R     ADD     A,n
0011 F582              MOV     DPL,A
0013 E4                CLR     A
0014 3500        R     ADDC    A,arrayH
0016 120000      R     LCALL   L?0267
0019 40F2              JC      ?C0021
001B         ?C0022:
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 229
001B 120000      R     LCALL   L?0259
                                           ; SOURCE LINE # 231
001E 7B03              MOV     R3,#03H
                                           ; SOURCE LINE # 233
                                           ; SOURCE LINE # 234
                                           ; SOURCE LINE # 235
0020 120000      R     LCALL   L?0257
0023         ?C0024:
0023 E500        R     MOV     A,arrayV+01H
0025 2500        R     ADD     A,n
0027 F582              MOV     DPL,A
0029 E4                CLR     A
002A 3500        R     ADDC    A,arrayV
002C 120000      R     LCALL   L?0267
002F 40F2              JC      ?C0024
0031         ?C0025:
                                           ; SOURCE LINE # 237
                                           ; SOURCE LINE # 238
                                           ; SOURCE LINE # 239
0031 120000      R     LCALL   L?0259
                                           ; SOURCE LINE # 262
0034 7BC4              MOV     R3,#0C4H
0036 7DFC              MOV     R5,#0FCH
0038 7F1C              MOV     R7,#01CH
003A 020000      E     LJMP    _RTDSetBit
                                           ; SOURCE LINE # 263
003D         L?0257:
003D 7DFC              MOV     R5,#0FCH
003F 7F1C              MOV     R7,#01CH
0041 120000      E     LCALL   _RTDSetBit
0044 C295              CLR     bRTD_SCSB
0046 7B01              MOV     R3,#01H
0048 E4                CLR     A
0049 FD                MOV     R5,A
004A 7F1D              MOV     R7,#01DH
004C 120000      E     LCALL   _RTDSendAddr
004F E4                CLR     A
0050 F500        R     MOV     n,A
0052 22                RET     
0053         L?0267:
0053 F583              MOV     DPH,A
0055 E4                CLR     A
0056 93                MOVC    A,@A+DPTR
0057 FF                MOV     R7,A
0058 120000      E     LCALL   _RTDSendByte
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 54  

005B 0500        R     INC     n
005D E500        R     MOV     A,n
005F C3                CLR     C
0060 9480              SUBB    A,#080H
0062 22                RET     
             ; FUNCTION _WriteSU_COEF (END)

             ; FUNCTION Set_H_Position (BEGIN)
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 275
0000 7800        R     MOV     R0,#LOW ucH_Min_Margin
0002 E6                MOV     A,@R0
0003 F9                MOV     R1,A
0004 E500        R     MOV     A,stMUD
0006 C3                CLR     C
0007 99                SUBB    A,R1
0008 5015              JNC     ?C0028
                                           ; SOURCE LINE # 276
                                           ; SOURCE LINE # 277
000A E9                MOV     A,R1
000B C3                CLR     C
000C 9500        R     SUBB    A,stMUD
000E FF                MOV     R7,A
000F E4                CLR     A
0010 9400              SUBB    A,#00H
0012 FE                MOV     R6,A
0013 C3                CLR     C
0014 7800        R     MOV     R0,#LOW usIPH_ACT_STA+01H
0016 E6                MOV     A,@R0
0017 9F                SUBB    A,R7
0018 F6                MOV     @R0,A
0019 18                DEC     R0
001A E6                MOV     A,@R0
001B 9E                SUBB    A,R6
001C F6                MOV     @R0,A
                                           ; SOURCE LINE # 278
001D 8900        R     MOV     stMUD,R1
                                           ; SOURCE LINE # 279
001F         ?C0028:
                                           ; SOURCE LINE # 282
001F E500        R     MOV     A,stMUD+02H
0021 13                RRC     A
0022 13                RRC     A
0023 543F              ANL     A,#03FH
0025 7800        R     MOV     R0,#LOW usIPH_ACT_STA+01H
0027 26                ADD     A,@R0
0028 FF                MOV     R7,A
0029 E4                CLR     A
002A 18                DEC     R0
002B 36                ADDC    A,@R0
002C CF                XCH     A,R7
002D 24E0              ADD     A,#0E0H
002F F500        E     MOV     Data+09H,A
0031 EF                MOV     A,R7
0032 34FF              ADDC    A,#0FFH
0034 F500        E     MOV     Data+08H,A
                                           ; SOURCE LINE # 288
0036 7F04              MOV     R7,#04H
0038 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 55  

003B 120000      R     LCALL   L?0277
                                           ; SOURCE LINE # 292
003E 750006      E     MOV     Data+02H,#06H
                                           ; SOURCE LINE # 293
0041 850000      E     MOV     Data+03H,Data+09H
                                           ; SOURCE LINE # 294
0044 E500        E     MOV     A,Data+08H
0046 F500        E     MOV     Data+04H,A
                                           ; SOURCE LINE # 295
0048 E4                CLR     A
0049 F500        E     MOV     Data+05H,A
                                           ; SOURCE LINE # 296
004B 7F00        E     MOV     R7,#LOW Data
004D 120000      E     LCALL   _RTDWrite
                                           ; SOURCE LINE # 301
0050 C3                CLR     C
0051 E500        R     MOV     A,stMUD
0053 7800        R     MOV     R0,#LOW ucH_Min_Margin
0055 96                SUBB    A,@R0
0056 2406              ADD     A,#06H
0058 F500        E     MOV     Data+0CH,A
                                           ; SOURCE LINE # 303
005A FD                MOV     R5,A
005B 7F8D              MOV     R7,#08DH
005D 020000      E     LJMP    _RTDSetByte
             ; FUNCTION Set_H_Position (END)

             ; FUNCTION Set_V_Position (BEGIN)
                                           ; SOURCE LINE # 344
                                           ; SOURCE LINE # 347
                                           ; SOURCE LINE # 356
0000 E4                CLR     A
0001 FB                MOV     R3,A
0002 7D7F              MOV     R5,#07FH
0004 7F31              MOV     R7,#031H
0006 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 359
0009 7800        R     MOV     R0,#LOW ucV_Max_Margin
000B E6                MOV     A,@R0
000C 14                DEC     A
000D FF                MOV     R7,A
000E C3                CLR     C
000F 9500        R     SUBB    A,stMUD+01H
0011 5023              JNC     ?C0030
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 362
0013 E500        R     MOV     A,stMUD+01H
0015 2403              ADD     A,#03H
0017 C3                CLR     C
0018 9F                SUBB    A,R7
0019 FD                MOV     R5,A
001A 7F8C              MOV     R7,#08CH
001C 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 365
001F 7800        R     MOV     R0,#LOW ucV_Max_Margin
0021 E6                MOV     A,@R0
0022 FF                MOV     R7,A
0023 7E00              MOV     R6,#00H
0025 7800        R     MOV     R0,#LOW usIPV_ACT_STA+01H
0027 26                ADD     A,@R0
0028 FD                MOV     R5,A
0029 EE                MOV     A,R6
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 56  

002A 18                DEC     R0
002B 36                ADDC    A,@R0
002C CD                XCH     A,R5
002D 247F              ADD     A,#07FH
                                           ; SOURCE LINE # 366
002F 120000      R     LCALL   L?0264
0032 247F              ADD     A,#07FH
                                           ; SOURCE LINE # 367
0034 801B              SJMP    ?C0221
0036         ?C0030:
                                           ; SOURCE LINE # 369
                                           ; SOURCE LINE # 371
0036 7D03              MOV     R5,#03H
0038 7F8C              MOV     R7,#08CH
003A 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 374
003D AF00        R     MOV     R7,stMUD+01H
003F 7E00              MOV     R6,#00H
0041 EF                MOV     A,R7
0042 7800        R     MOV     R0,#LOW usIPV_ACT_STA+01H
0044 26                ADD     A,@R0
0045 FD                MOV     R5,A
0046 EE                MOV     A,R6
0047 18                DEC     R0
0048 36                ADDC    A,@R0
0049 CD                XCH     A,R5
004A 2480              ADD     A,#080H
                                           ; SOURCE LINE # 375
004C 120000      R     LCALL   L?0264
004F 2480              ADD     A,#080H
0051         ?C0221:
0051 F500        R     MOV     usDV_Temp+01H,A
0053 EF                MOV     A,R7
0054 34FF              ADDC    A,#0FFH
0056 F500        R     MOV     usDV_Temp,A
                                           ; SOURCE LINE # 376
0058         ?C0031:
                                           ; SOURCE LINE # 378
0058 7F02              MOV     R7,#02H
005A 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 380
005D 750004      E     MOV     Data,#04H
                                           ; SOURCE LINE # 381
0060 750001      E     MOV     Data+01H,#01H
                                           ; SOURCE LINE # 382
0063 750038      E     MOV     Data+02H,#038H
                                           ; SOURCE LINE # 383
0066 850000      E     MOV     Data+03H,usDV_Temp+01H
                                           ; SOURCE LINE # 384
0069 750005      E     MOV     Data+04H,#05H
                                           ; SOURCE LINE # 385
006C E4                CLR     A
006D F500        E     MOV     Data+05H,A
                                           ; SOURCE LINE # 386
006F 75000A      E     MOV     Data+06H,#0AH
                                           ; SOURCE LINE # 387
0072 850000      E     MOV     Data+07H,usIV_Temp+01H
                                           ; SOURCE LINE # 388
0075 E500        R     MOV     A,usIV_Temp
0077 F500        E     MOV     Data+08H,A
                                           ; SOURCE LINE # 389
0079 E4                CLR     A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 57  

007A F500        E     MOV     Data+09H,A
                                           ; SOURCE LINE # 390
007C 7F00        E     MOV     R7,#LOW Data
007E 120000      E     LCALL   _RTDWrite
                                           ; SOURCE LINE # 392
0081 7F02              MOV     R7,#02H
0083 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 395
0086 E4                CLR     A
0087 FD                MOV     R5,A
0088 7F01              MOV     R7,#01H
008A 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 396
008D E4                CLR     A
008E FD                MOV     R5,A
008F 7F1F              MOV     R7,#01FH
0091 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 405
0094 300013      E     JNB     bFrameSync,?C0033
0097 300010      E     JNB     bStable,?C0033
                                           ; SOURCE LINE # 406
                                           ; SOURCE LINE # 407
009A E4                CLR     A
009B FD                MOV     R5,A
009C 7F3D              MOV     R7,#03DH
009E 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 408
00A1 7B80              MOV     R3,#080H
00A3 7D7F              MOV     R5,#07FH
00A5 7F31              MOV     R7,#031H
00A7 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 415
00AA         ?C0033:
00AA 22                RET     
             ; FUNCTION Set_V_Position (END)

             ; FUNCTION Set_Clock (BEGIN)
                                           ; SOURCE LINE # 534
                                           ; SOURCE LINE # 535
                                           ; SOURCE LINE # 545
0000 E500        R     MOV     A,stMUD+02H
0002 7800        R     MOV     R0,#LOW usADC_Clock+01H
0004 26                ADD     A,@R0
0005 FF                MOV     R7,A
0006 E4                CLR     A
0007 18                DEC     R0
0008 36                ADDC    A,@R0
0009 CF                XCH     A,R7
000A 2480              ADD     A,#080H
000C F500        R     MOV     usClock+01H,A
000E EF                MOV     A,R7
000F 34FF              ADDC    A,#0FFH
0011 F500        R     MOV     usClock,A
                                           ; SOURCE LINE # 546
0013 FE                MOV     R6,A
0014 AF00        R     MOV     R7,usClock+01H
0016 120000      R     LCALL   L?0255
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
001D 120000      R     LCALL   L?0248
0020 D007              POP     AR7
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 58  

0022 D006              POP     AR6
0024 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 549
0027 7F8E              MOV     R7,#08EH
0029 120000      R     LCALL   L?0274
                                           ; SOURCE LINE # 557
002C 7F3D              MOV     R7,#03DH
002E 120000      R     LCALL   L?0274
                                           ; SOURCE LINE # 558
0031 7D40              MOV     R5,#040H
0033 7F3D              MOV     R7,#03DH
0035 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 559
0038 E4                CLR     A
0039 7800        E     MOV     R0,#LOW ucPE_Max
003B F6                MOV     @R0,A
                                           ; SOURCE LINE # 713
003C 750001      E     MOV     Data,#01H
003F 7500F4      E     MOV     Data+01H,#0F4H
                                           ; SOURCE LINE # 715
0042 F500        R     MOV     ucM_Code,A
                                           ; SOURCE LINE # 716
0044 F500        R     MOV     ucN_Code,A
                                           ; SOURCE LINE # 717
0046 F500        R     MOV     ucResult,A
                                           ; SOURCE LINE # 718
0048 750007      R     MOV     ucTemp0,#07H
004B         ?C0036:
                                           ; SOURCE LINE # 720
                                           ; SOURCE LINE # 724
004B 120000      R     LCALL   L?0250
004E 7B52              MOV     R3,#052H
0050 7A4A              MOV     R2,#04AH
0052 7903              MOV     R1,#03H
0054 7800              MOV     R0,#00H
0056 120000      E     LCALL   ?C?ULDIV
0059 8F00        R     MOV     ucTemp1,R7
                                           ; SOURCE LINE # 726
005B 7402              MOV     A,#02H
005D D3                SETB    C
005E 9500        R     SUBB    A,ucTemp1
0060 5039              JNC     ?C0037
                                           ; SOURCE LINE # 727
                                           ; SOURCE LINE # 728
0062 120000      R     LCALL   L?0250
0065 C007              PUSH    AR7
0067 AF00        R     MOV     R7,ucTemp1
0069 AB07              MOV     R3,AR7
006B E4                CLR     A
006C FA                MOV     R2,A
006D F9                MOV     R1,A
006E F8                MOV     R0,A
006F D007              POP     AR7
                                           ; SOURCE LINE # 731
                                           ; SOURCE LINE # 733
0071 120000      R     LCALL   L?0244
0074 5010              JNC     ?C0038
                                           ; SOURCE LINE # 734
                                           ; SOURCE LINE # 735
0076 C3                CLR     C
0077 7422              MOV     A,#022H
0079 120000      R     LCALL   L?0246
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 59  

007C 4003              JC      ?C0039
                                           ; SOURCE LINE # 736
                                           ; SOURCE LINE # 737
                                           ; SOURCE LINE # 738
                                           ; SOURCE LINE # 739
007E 020000      R     LJMP    ?C0225
                                           ; SOURCE LINE # 740
0081         ?C0039:
                                           ; SOURCE LINE # 742
0081 120000      R     LCALL   L?0270
                                           ; SOURCE LINE # 743
0084 800D              SJMP    ?C0040
0086         ?C0038:
                                           ; SOURCE LINE # 745
                                           ; SOURCE LINE # 746
0086 7401              MOV     A,#01H
0088 120000      R     LCALL   L?0245
008B 5003              JNC     ?C0041
                                           ; SOURCE LINE # 747
                                           ; SOURCE LINE # 748
008D         ?C0223:
                                           ; SOURCE LINE # 749
                                           ; SOURCE LINE # 750
008D 020000      R     LJMP    ?C0225
                                           ; SOURCE LINE # 751
0090         ?C0041:
                                           ; SOURCE LINE # 753
0090 120000      R     LCALL   L?0269
                                           ; SOURCE LINE # 754
0093         ?C0040:
                                           ; SOURCE LINE # 756
0093 120000      R     LCALL   L?0279
0096 4003              JC      ?C0037
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 760
                                           ; SOURCE LINE # 761
0098 120000      R     LCALL   L?0265
                                           ; SOURCE LINE # 762
                                           ; SOURCE LINE # 763
009B         ?C0037:
                                           ; SOURCE LINE # 765
009B 0500        R     INC     ucTemp1
                                           ; SOURCE LINE # 767
009D 7402              MOV     A,#02H
009F D3                SETB    C
00A0 9500        R     SUBB    A,ucTemp1
00A2 503B              JNC     ?C0034
                                           ; SOURCE LINE # 768
                                           ; SOURCE LINE # 769
00A4 120000      R     LCALL   L?0251
00A7 C007              PUSH    AR7
00A9 AF00        R     MOV     R7,ucTemp1
00AB AB07              MOV     R3,AR7
00AD E4                CLR     A
00AE FA                MOV     R2,A
00AF F9                MOV     R1,A
00B0 F8                MOV     R0,A
00B1 D007              POP     AR7
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 774
00B3 120000      R     LCALL   L?0244
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 60  

00B6 500F              JNC     ?C0044
                                           ; SOURCE LINE # 775
                                           ; SOURCE LINE # 776
00B8 C3                CLR     C
00B9 7422              MOV     A,#022H
00BB 120000      R     LCALL   L?0246
00BE 4002              JC      ?C0045
                                           ; SOURCE LINE # 777
                                           ; SOURCE LINE # 778
00C0         ?C0224:
                                           ; SOURCE LINE # 779
                                           ; SOURCE LINE # 780
00C0 800D              SJMP    ?C0225
                                           ; SOURCE LINE # 781
00C2         ?C0045:
                                           ; SOURCE LINE # 783
00C2 120000      R     LCALL   L?0270
                                           ; SOURCE LINE # 784
00C5 8010              SJMP    ?C0046
00C7         ?C0044:
                                           ; SOURCE LINE # 786
                                           ; SOURCE LINE # 787
00C7 D3                SETB    C
00C8 7401              MOV     A,#01H
00CA 120000      R     LCALL   L?0246
00CD 5005              JNC     ?C0047
                                           ; SOURCE LINE # 788
                                           ; SOURCE LINE # 789
00CF         ?C0225:
                                           ; SOURCE LINE # 790
00CF 120000      R     LCALL   L?0266
                                           ; SOURCE LINE # 791
00D2 8017              SJMP    ?C0035
                                           ; SOURCE LINE # 792
00D4         ?C0047:
                                           ; SOURCE LINE # 794
00D4 120000      R     LCALL   L?0269
                                           ; SOURCE LINE # 795
00D7         ?C0046:
                                           ; SOURCE LINE # 797
00D7 120000      R     LCALL   L?0279
00DA 4003              JC      ?C0034
                                           ; SOURCE LINE # 798
                                           ; SOURCE LINE # 799
                                           ; SOURCE LINE # 801
                                           ; SOURCE LINE # 802
00DC 120000      R     LCALL   L?0265
                                           ; SOURCE LINE # 803
                                           ; SOURCE LINE # 804
                                           ; SOURCE LINE # 805
00DF         ?C0034:
                                           ; SOURCE LINE # 806
00DF 0500        R     INC     ucTemp0
00E1 7435              MOV     A,#035H
00E3 C3                CLR     C
00E4 9500        R     SUBB    A,ucTemp0
00E6 4003              JC      $ + 5H
00E8 020000      R     LJMP    ?C0036
00EB         ?C0035:
                                           ; SOURCE LINE # 822
00EB E500        R     MOV     A,usClock+01H
00ED 1500        R     DEC     usClock+01H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 61  

00EF 7002              JNZ     ?C0218
00F1 1500        R     DEC     usClock
00F3         ?C0218:
                                           ; SOURCE LINE # 824
00F3 7F04              MOV     R7,#04H
00F5 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 831
00F8 7D8C              MOV     R5,#08CH
00FA 7FC9              MOV     R7,#0C9H
00FC 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 832
00FF 7D20              MOV     R5,#020H
0101 7FCA              MOV     R7,#0CAH
0103 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 833
0106 7D18              MOV     R5,#018H
0108 7FCB              MOV     R7,#0CBH
010A 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
010D 120000      R     LCALL   L?0277
                                           ; SOURCE LINE # 837
0110 7500D7      E     MOV     Data+02H,#0D7H
                                           ; SOURCE LINE # 838
0113 75000F      E     MOV     Data+03H,#0FH
                                           ; SOURCE LINE # 839
0116 F500        E     MOV     Data+04H,A
                                           ; SOURCE LINE # 840
0118 F500        E     MOV     Data+05H,A
                                           ; SOURCE LINE # 841
011A 7F00        E     MOV     R7,#LOW Data
011C 120000      E     LCALL   _RTDWrite
                                           ; SOURCE LINE # 843
                                           ; SOURCE LINE # 844
011F 120000      R     LCALL   L?0278
                                           ; SOURCE LINE # 845
0122 7500CC      E     MOV     Data+02H,#0CCH
                                           ; SOURCE LINE # 846
0125 E500        R     MOV     A,usClock
0127 F500        E     MOV     Data+03H,A
                                           ; SOURCE LINE # 847
0129 850000      E     MOV     Data+04H,usClock+01H
                                           ; SOURCE LINE # 848
012C 750005      E     MOV     Data+05H,#05H
                                           ; SOURCE LINE # 849
012F E4                CLR     A
0130 F500        E     MOV     Data+06H,A
                                           ; SOURCE LINE # 850
0132 7500DB      E     MOV     Data+07H,#0DBH
                                           ; SOURCE LINE # 851
0135 E500        R     MOV     A,ucM_Code
0137 24FE              ADD     A,#0FEH
0139 F500        E     MOV     Data+08H,A
                                           ; SOURCE LINE # 852
013B E500        R     MOV     A,ucN_Code
013D 24FE              ADD     A,#0FEH
013F F500        E     MOV     Data+09H,A
                                           ; SOURCE LINE # 853
0141 E4                CLR     A
0142 F500        E     MOV     Data+0AH,A
                                           ; SOURCE LINE # 854
0144 7F00        E     MOV     R7,#LOW Data
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 62  

0146 120000      E     LCALL   _RTDWrite
                                           ; SOURCE LINE # 856
0149 120000      E     LCALL   PowerUp_ADC
                                           ; SOURCE LINE # 861
014C 7F0A              MOV     R7,#0AH
014E 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 867
0151 7DFC              MOV     R5,#0FCH
0153 7FC9              MOV     R7,#0C9H
0155 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 868
0158 7D21              MOV     R5,#021H
015A 7FCA              MOV     R7,#0CAH
015C 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 869
015F 7D17              MOV     R5,#017H
0161 7FCB              MOV     R7,#0CBH
0163 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 877
0166 7F01              MOV     R7,#01H
0168 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 879
016B 120000      R     LCALL   L?0254
016E C006              PUSH    AR6
0170 C007              PUSH    AR7
0172 120000      R     LCALL   L?0248
0175 D007              POP     AR7
0177 D006              POP     AR6
0179 120000      R     LCALL   L?0273
                                           ; SOURCE LINE # 888
017C 7800        E     MOV     R0,#LOW ucI_Code
017E E6                MOV     A,@R0
017F 603C              JZ      ?C0049
                                           ; SOURCE LINE # 889
                                           ; SOURCE LINE # 890
0181 30E704            JNB     ACC.7,?C0050
                                           ; SOURCE LINE # 891
0184 7B20              MOV     R3,#020H
0186 8002              SJMP    ?C0222
0188         ?C0050:
                                           ; SOURCE LINE # 893
0188 E4                CLR     A
0189 FB                MOV     R3,A
018A         ?C0222:
018A 7DDF              MOV     R5,#0DFH
018C 7FCA              MOV     R7,#0CAH
018E 120000      E     LCALL   _RTDSetBit
0191         ?C0051:
                                           ; SOURCE LINE # 895
0191 7800        E     MOV     R0,#LOW ucI_Code
0193 E6                MOV     A,@R0
0194 547F              ANL     A,#07FH
0196 F6                MOV     @R0,A
                                           ; SOURCE LINE # 897
0197 5407              ANL     A,#07H
0199 C4                SWAP    A
019A 33                RLC     A
019B 54E0              ANL     A,#0E0H
019D 4418              ORL     A,#018H
019F FD                MOV     R5,A
01A0 7FC9              MOV     R7,#0C9H
01A2 120000      E     LCALL   _RTDSetByte
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 63  

                                           ; SOURCE LINE # 898
01A5 7800        E     MOV     R0,#LOW ucI_Code
01A7 E6                MOV     A,@R0
01A8 5418              ANL     A,#018H
01AA 13                RRC     A
01AB 13                RRC     A
01AC 13                RRC     A
01AD 541F              ANL     A,#01FH
01AF 4404              ORL     A,#04H
01B1 FB                MOV     R3,A
01B2 7DFC              MOV     R5,#0FCH
01B4 7FCA              MOV     R7,#0CAH
01B6 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 899
01B9 7D15              MOV     R5,#015H
                                           ; SOURCE LINE # 900
01BB 8010              SJMP    ?C0226
01BD         ?C0049:
                                           ; SOURCE LINE # 902
                                           ; SOURCE LINE # 903
01BD 7D1C              MOV     R5,#01CH
01BF 7FC9              MOV     R7,#0C9H
01C1 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 904
01C4 7D11              MOV     R5,#011H
01C6 7FCA              MOV     R7,#0CAH
01C8 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 905
01CB 7D16              MOV     R5,#016H
01CD         ?C0226:
01CD 7FCB              MOV     R7,#0CBH
01CF 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 906
01D2         ?C0052:
                                           ; SOURCE LINE # 947
01D2 200005      E     JB      bAutoInProgress,?C0053
                                           ; SOURCE LINE # 948
01D5 7F01              MOV     R7,#01H
01D7 120000      R     LCALL   _Wait_For_Event
01DA         ?C0053:
                                           ; SOURCE LINE # 952
01DA 7800        E     MOV     R0,#LOW ucPE_Level
01DC E6                MOV     A,@R0
01DD 6005              JZ      ?C0054
                                           ; SOURCE LINE # 953
                                           ; SOURCE LINE # 957
01DF 7F02              MOV     R7,#02H
01E1 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 958
01E4         ?C0054:
                                           ; SOURCE LINE # 962
01E4 E4                CLR     A
01E5 FD                MOV     R5,A
01E6 7F01              MOV     R7,#01H
01E8 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 963
01EB E4                CLR     A
01EC FD                MOV     R5,A
01ED 7F1F              MOV     R7,#01FH
01EF 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 967
01F2 30000C      E     JNB     bFrameSync,?C0056
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 64  

01F5 300009      E     JNB     bStable,?C0056
                                           ; SOURCE LINE # 968
01F8 7B20              MOV     R3,#020H
01FA 7DDF              MOV     R5,#0DFH
01FC 7F8E              MOV     R7,#08EH
01FE 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 975
0201         ?C0056:
0201 22                RET     
0202         L?0274:
0202 E4                CLR     A
0203 FB                MOV     R3,A
0204 7DDF              MOV     R5,#0DFH
0206 120000      E     LCALL   _RTDSetBit
0209 22                RET     
             ; FUNCTION Set_Clock (END)

             ; FUNCTION _Set_Phase (BEGIN)
                                           ; SOURCE LINE # 977
0000 8F00        R     MOV     phase,R7
                                           ; SOURCE LINE # 978
                                           ; SOURCE LINE # 982
0002 120000      R     LCALL   L?0254
0005 C006              PUSH    AR6
0007 C007              PUSH    AR7
0009 120000      R     LCALL   L?0249
000C D007              POP     AR7
000E D006              POP     AR6
0010 120000      E     LCALL   ?C?ULDIV
0013 8F00        R     MOV     ulRate+03H,R7
0015 8E00        R     MOV     ulRate+02H,R6
0017 8D00        R     MOV     ulRate+01H,R5
0019 8C00        R     MOV     ulRate,R4
                                           ; SOURCE LINE # 987
001B 53007C      R     ANL     phase,#07CH
                                           ; SOURCE LINE # 990
001E E500        R     MOV     A,phase
0020 543C              ANL     A,#03CH
0022 F500        R     MOV     ucSelect,A
                                           ; SOURCE LINE # 992
0024 E500        R     MOV     A,phase
0026 13                RRC     A
0027 13                RRC     A
0028 543F              ANL     A,#03FH
002A F500        R     MOV     phase,A
                                           ; SOURCE LINE # 993
002C 7404              MOV     A,#04H
002E C3                CLR     C
002F 9500        R     SUBB    A,phase
0031 5006              JNC     ?C0059
0033 741D              MOV     A,#01DH
0035 9500        R     SUBB    A,phase
0037 5004              JNC     ?C0057
0039         ?C0059:
0039 7F80              MOV     R7,#080H
003B 8014              SJMP    ?C0058
003D         ?C0057:
003D 740D              MOV     A,#0DH
003F D3                SETB    C
0040 9500        R     SUBB    A,phase
0042 500B              JNC     ?C0060
0044 7415              MOV     A,#015H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 65  

0046 C3                CLR     C
0047 9500        R     SUBB    A,phase
0049 4004              JC      ?C0060
004B 7F80              MOV     R7,#080H
004D 8002              SJMP    ?C0061
004F         ?C0060:
004F 7F00              MOV     R7,#00H
0051         ?C0061:
0051         ?C0058:
0051 8F00        R     MOV     ucX_Ctrl,R7
                                           ; SOURCE LINE # 994
0053 740C              MOV     A,#0CH
0055 C3                CLR     C
0056 9500        R     SUBB    A,phase
0058 5006              JNC     ?C0064
005A 741D              MOV     A,#01DH
005C 9500        R     SUBB    A,phase
005E 5004              JNC     ?C0062
0060         ?C0064:
0060 7F01              MOV     R7,#01H
0062 8002              SJMP    ?C0063
0064         ?C0062:
0064 7F00              MOV     R7,#00H
0066         ?C0063:
0066 8F00        R     MOV     ucY_Ctrl,R7
                                           ; SOURCE LINE # 999
0068 E500        R     MOV     A,ucSelect
006A 25E0              ADD     A,ACC
006C 4500        R     ORL     A,ucX_Ctrl
006E 4200        R     ORL     ucY_Ctrl,A
                                           ; SOURCE LINE # 1014
0070 E4                CLR     A
0071 7F87              MOV     R7,#087H
0073 7E01              MOV     R6,#01H
0075 FD                MOV     R5,A
0076 FC                MOV     R4,A
0077 AB00        R     MOV     R3,ulRate+03H
0079 AA00        R     MOV     R2,ulRate+02H
007B A900        R     MOV     R1,ulRate+01H
007D A800        R     MOV     R0,ulRate
007F 120000      E     LCALL   ?C?LMUL
0082 7B40              MOV     R3,#040H
0084 7A42              MOV     R2,#042H
0086 790F              MOV     R1,#0FH
0088 7800              MOV     R0,#00H
008A 120000      E     LCALL   ?C?ULDIV
008D 8F00        R     MOV     ucSelect,R7
                                           ; SOURCE LINE # 1018
008F 7420              MOV     A,#020H
0091 C3                CLR     C
0092 9500        R     SUBB    A,ucSelect
0094 4004              JC      ?C0065
0096 7420              MOV     A,#020H
0098 8003              SJMP    ?C0227
009A         ?C0065:
009A C3                CLR     C
009B 7440              MOV     A,#040H
009D         ?C0227:
009D 9500        R     SUBB    A,ucSelect
009F FF                MOV     R7,A
00A0         ?C0066:
00A0 8F00        R     MOV     ucSelect,R7
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 66  

                                           ; SOURCE LINE # 1023
00A2 E500        R     MOV     A,phase
00A4 C3                CLR     C
00A5 9500        R     SUBB    A,ucSelect
00A7 4007              JC      ?C0067
00A9 E500        R     MOV     A,phase
00AB 9500        R     SUBB    A,ucSelect
00AD FF                MOV     R7,A
00AE 8006              SJMP    ?C0068
00B0         ?C0067:
00B0 C3                CLR     C
00B1 E500        R     MOV     A,ucSelect
00B3 9500        R     SUBB    A,phase
00B5 FF                MOV     R7,A
00B6         ?C0068:
00B6 8F00        R     MOV     ucX_Ctrl,R7
                                           ; SOURCE LINE # 1025
00B8 C3                CLR     C
00B9 E500        R     MOV     A,stMUD
00BB 7800        R     MOV     R0,#LOW ucH_Min_Margin
00BD 96                SUBB    A,@R0
00BE 2406              ADD     A,#06H
00C0 F500        E     MOV     Data,A
                                           ; SOURCE LINE # 1027
00C2 E500        R     MOV     A,phase
00C4 2406              ADD     A,#06H
00C6 FF                MOV     R7,A
00C7 E4                CLR     A
00C8 33                RLC     A
00C9 FE                MOV     R6,A
00CA C3                CLR     C
00CB EF                MOV     A,R7
00CC 9500        R     SUBB    A,ucSelect
00CE 7480              MOV     A,#080H
00D0 F8                MOV     R0,A
00D1 6E                XRL     A,R6
00D2 98                SUBB    A,R0
00D3 5006              JNC     ?C0069
00D5 E500        E     MOV     A,Data
00D7 14                DEC     A
00D8 FF                MOV     R7,A
00D9 8002              SJMP    ?C0070
00DB         ?C0069:
00DB AF00        E     MOV     R7,Data
00DD         ?C0070:
00DD 8F00        R     MOV     ucSelect,R7
                                           ; SOURCE LINE # 1032
00DF 7F04              MOV     R7,#04H
00E1 120000      R     LCALL   _Wait_For_Event
                                           ; SOURCE LINE # 1035
00E4 7406              MOV     A,#06H
00E6 C3                CLR     C
00E7 9500        R     SUBB    A,ucX_Ctrl
00E9 500A              JNC     ?C0071
00EB 741A              MOV     A,#01AH
00ED 9500        R     SUBB    A,ucX_Ctrl
00EF 4004              JC      ?C0071
00F1 7D00              MOV     R5,#00H
00F3 8002              SJMP    ?C0072
00F5         ?C0071:
00F5 7D10              MOV     R5,#010H
00F7         ?C0072:
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 67  

00F7 7F4E              MOV     R7,#04EH
00F9 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1037
00FC AD00        R     MOV     R5,ucSelect
00FE 7F8D              MOV     R7,#08DH
0100 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1040
0103 AD00        R     MOV     R5,ucY_Ctrl
0105 7F9F              MOV     R7,#09FH
0107 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1042
010A 7F02              MOV     R7,#02H
010C 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 1044
010F E4                CLR     A
0110 FD                MOV     R5,A
0111 7F01              MOV     R7,#01H
0113 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1045
0116 E4                CLR     A
0117 FD                MOV     R5,A
0118 7F1F              MOV     R7,#01FH
011A 020000      E     LJMP    _RTDSetByte
             ; FUNCTION _Set_Phase (END)

             ; FUNCTION Set_Bright_Contrast (BEGIN)
                                           ; SOURCE LINE # 1053
                                           ; SOURCE LINE # 1054
                                           ; SOURCE LINE # 1056
0000 7464              MOV     A,#064H
0002 C3                CLR     C
0003 9500        R     SUBB    A,stGUD0
0005 5003              JNC     ?C0074
0007 750032      R     MOV     stGUD0,#032H
000A         ?C0074:
                                           ; SOURCE LINE # 1057
000A 7464              MOV     A,#064H
000C C3                CLR     C
000D 9500        R     SUBB    A,stGUD0+02H
000F 5003              JNC     ?C0075
0011 750032      R     MOV     stGUD0+02H,#032H
0014         ?C0075:
                                           ; SOURCE LINE # 1058
0014 7464              MOV     A,#064H
0016 C3                CLR     C
0017 9500        R     SUBB    A,stGUD0+03H
0019 5003              JNC     ?C0076
001B 750032      R     MOV     stGUD0+03H,#032H
001E         ?C0076:
                                           ; SOURCE LINE # 1059
001E 7464              MOV     A,#064H
0020 C3                CLR     C
0021 9500        R     SUBB    A,stGUD0+04H
0023 5003              JNC     ?C0077
0025 750032      R     MOV     stGUD0+04H,#032H
0028         ?C0077:
                                           ; SOURCE LINE # 1061
0028 750009      E     MOV     Data,#09H
                                           ; SOURCE LINE # 1062
002B E4                CLR     A
002C F500        E     MOV     Data+01H,A
                                           ; SOURCE LINE # 1063
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 68  

002E 75005E      E     MOV     Data+02H,#05EH
                                           ; SOURCE LINE # 1074
                                           ; SOURCE LINE # 1075
0031 75007D      E     MOV     Data+03H,#07DH
                                           ; SOURCE LINE # 1076
0034 75007D      E     MOV     Data+04H,#07DH
                                           ; SOURCE LINE # 1077
0037 75007D      E     MOV     Data+05H,#07DH
                                           ; SOURCE LINE # 1078
                                           ; SOURCE LINE # 1080
003A E500        R     MOV     A,stGUD1+01H
003C 5418              ANL     A,#018H
003E 13                RRC     A
003F 13                RRC     A
0040 13                RRC     A
0041 541F              ANL     A,#01FH
0043 14                DEC     A
0044 6012              JZ      ?C0080
0046 14                DEC     A
0047 601A              JZ      ?C0081
0049 2402              ADD     A,#02H
004B 7021              JNZ     ?C0082
                                           ; SOURCE LINE # 1081
                                           ; SOURCE LINE # 1082
004D         ?C0079:
                                           ; SOURCE LINE # 1083
004D 850000      E     MOV     Data+0DH,stGUD4+01H
                                           ; SOURCE LINE # 1084
0050 850000      E     MOV     Data+0EH,stGUD4+02H
                                           ; SOURCE LINE # 1085
0053 850000      E     MOV     Data+0FH,stGUD4
                                           ; SOURCE LINE # 1086
0056 801F              SJMP    ?C0078
                                           ; SOURCE LINE # 1087
0058         ?C0080:
                                           ; SOURCE LINE # 1088
0058 850000      E     MOV     Data+0DH,stGUD4+04H
                                           ; SOURCE LINE # 1089
005B 850000      E     MOV     Data+0EH,stGUD4+05H
                                           ; SOURCE LINE # 1090
005E 850000      E     MOV     Data+0FH,stGUD4+03H
                                           ; SOURCE LINE # 1091
0061 8014              SJMP    ?C0078
                                           ; SOURCE LINE # 1092
0063         ?C0081:
                                           ; SOURCE LINE # 1093
0063 850000      E     MOV     Data+0DH,stGUD4+07H
                                           ; SOURCE LINE # 1094
0066 850000      E     MOV     Data+0EH,stGUD4+08H
                                           ; SOURCE LINE # 1095
0069 850000      E     MOV     Data+0FH,stGUD4+06H
                                           ; SOURCE LINE # 1096
006C 8009              SJMP    ?C0078
                                           ; SOURCE LINE # 1097
006E         ?C0082:
                                           ; SOURCE LINE # 1098
006E 850000      E     MOV     Data+0DH,stGUD0+03H
                                           ; SOURCE LINE # 1099
0071 850000      E     MOV     Data+0EH,stGUD0+04H
                                           ; SOURCE LINE # 1100
0074 850000      E     MOV     Data+0FH,stGUD0+02H
                                           ; SOURCE LINE # 1101
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 69  

                                           ; SOURCE LINE # 1102
0077         ?C0078:
                                           ; SOURCE LINE # 1104
0077 E500        R     MOV     A,stGUD1+01H
0079 5407              ANL     A,#07H
007B 7005              JNZ     ?C0083
                                           ; SOURCE LINE # 1105
007D 750080      E     MOV     Data+06H,#080H
0080 8015              SJMP    ?C0084
0082         ?C0083:
                                           ; SOURCE LINE # 1107
0082 7432              MOV     A,#032H
0084 C3                CLR     C
0085 9500        R     SUBB    A,stGUD0
0087 E500        R     MOV     A,stGUD0
0089 4005              JC      ?C0085
008B 244E              ADD     A,#04EH
008D FF                MOV     R7,A
008E 8005              SJMP    ?C0086
0090         ?C0085:
0090 C3                CLR     C
0091 13                RRC     A
0092 2468              ADD     A,#068H
0094 FF                MOV     R7,A
0095         ?C0086:
0095 8F00        E     MOV     Data+06H,R7
0097         ?C0084:
                                           ; SOURCE LINE # 1114
0097 7432              MOV     A,#032H
0099 C3                CLR     C
009A 9500        E     SUBB    A,Data+0DH
009C E500        E     MOV     A,Data+0DH
009E 4005              JC      ?C0087
00A0 13                RRC     A
00A1 244B              ADD     A,#04BH
00A3 8003              SJMP    ?C0228
00A5         ?C0087:
00A5 120000      R     LCALL   L?0280
00A8         ?C0228:
00A8 120000      R     LCALL   L?0252
00AB         ?C0088:
00AB 8F00        E     MOV     Data+07H,R7
                                           ; SOURCE LINE # 1117
00AD 7432              MOV     A,#032H
00AF C3                CLR     C
00B0 9500        E     SUBB    A,Data+0EH
00B2 E500        E     MOV     A,Data+0EH
00B4 4005              JC      ?C0089
00B6 13                RRC     A
00B7 244B              ADD     A,#04BH
00B9 8003              SJMP    ?C0229
00BB         ?C0089:
00BB 120000      R     LCALL   L?0280
00BE         ?C0229:
00BE 120000      R     LCALL   L?0252
00C1         ?C0090:
00C1 8F00        E     MOV     Data+08H,R7
                                           ; SOURCE LINE # 1120
00C3 7432              MOV     A,#032H
00C5 C3                CLR     C
00C6 9500        E     SUBB    A,Data+0FH
00C8 E500        E     MOV     A,Data+0FH
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 70  

00CA 4005              JC      ?C0091
00CC 13                RRC     A
00CD 244B              ADD     A,#04BH
00CF 8003              SJMP    ?C0230
00D1         ?C0091:
00D1 120000      R     LCALL   L?0281
00D4         ?C0230:
00D4 120000      R     LCALL   L?0253
00D7         ?C0092:
00D7 8F00        E     MOV     Data+06H,R7
                                           ; SOURCE LINE # 1122
00D9 E4                CLR     A
00DA F500        E     MOV     Data+09H,A
                                           ; SOURCE LINE # 1123
00DC 7F00        E     MOV     R7,#LOW Data
00DE 120000      E     LCALL   _RTDWrite
                                           ; SOURCE LINE # 1125
00E1 7464              MOV     A,#064H
00E3 C3                CLR     C
00E4 9500        R     SUBB    A,stGUD0+01H
00E6 5003              JNC     ?C0093
00E8 750032      R     MOV     stGUD0+01H,#032H
00EB         ?C0093:
                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1128
                                           ; SOURCE LINE # 1129
00EB 120000      R     LCALL   L?0276
                                           ; SOURCE LINE # 1137
00EE 750080      E     MOV     Data+03H,#080H
                                           ; SOURCE LINE # 1138
00F1 750001      E     MOV     Data+04H,#01H
                                           ; SOURCE LINE # 1165
00F4 E500        R     MOV     A,stGUD0+01H
00F6 75F0D9            MOV     B,#0D9H
00F9 A4                MUL     AB
00FA FF                MOV     R7,A
00FB AEF0              MOV     R6,B
00FD 7C00              MOV     R4,#00H
00FF 7D64              MOV     R5,#064H
0101 120000      E     LCALL   ?C?UIDIV
0104 EF                MOV     A,R7
0105 2426              ADD     A,#026H
0107 F500        E     MOV     Data+05H,A
                                           ; SOURCE LINE # 1177
0109 E4                CLR     A
010A F500        E     MOV     Data+06H,A
                                           ; SOURCE LINE # 1180
010C 7F00        E     MOV     R7,#LOW Data
010E 020000      E     LJMP    _RTDWrite
             ; FUNCTION Set_Bright_Contrast (END)

             ; FUNCTION Set_Gamma (BEGIN)
                                           ; SOURCE LINE # 1183
                                           ; SOURCE LINE # 1184
                                           ; SOURCE LINE # 1185
0000 E500        R     MOV     A,stGUD1
0002 5460              ANL     A,#060H
0004 24C0              ADD     A,#0C0H
0006 6016              JZ      ?C0097
0008 24E0              ADD     A,#0E0H
000A 6020              JZ      ?C0098
000C 2440              ADD     A,#040H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 71  

000E 702B              JNZ     ?C0099
                                           ; SOURCE LINE # 1186
                                           ; SOURCE LINE # 1187
0010         ?C0096:
                                           ; SOURCE LINE # 1188
0010 7C00        E     MOV     R4,#HIGH GAMMA_1
0012 7D00        E     MOV     R5,#LOW GAMMA_1
0014 AF05              MOV     R7,AR5
0016 AE04              MOV     R6,AR4
0018 7A00        E     MOV     R2,#HIGH GAMMA_1
001A 7B00        E     MOV     R3,#LOW GAMMA_1
                                           ; SOURCE LINE # 1189
001C 801A              SJMP    ?C0232
                                           ; SOURCE LINE # 1190
001E         ?C0097:
                                           ; SOURCE LINE # 1191
001E 7C00        E     MOV     R4,#HIGH GAMMA_2
0020 7D00        E     MOV     R5,#LOW GAMMA_2
0022 AF05              MOV     R7,AR5
0024 AE04              MOV     R6,AR4
0026 7A00        E     MOV     R2,#HIGH GAMMA_2
0028 7B00        E     MOV     R3,#LOW GAMMA_2
002A         ?C0231:
                                           ; SOURCE LINE # 1192
002A 800C              SJMP    ?C0232
                                           ; SOURCE LINE # 1193
002C         ?C0098:
                                           ; SOURCE LINE # 1194
002C 7C00        E     MOV     R4,#HIGH GAMMA_3
002E 7D00        E     MOV     R5,#LOW GAMMA_3
0030 AF05              MOV     R7,AR5
0032 AE04              MOV     R6,AR4
0034 7A00        E     MOV     R2,#HIGH GAMMA_3
0036 7B00        E     MOV     R3,#LOW GAMMA_3
0038         ?C0232:
0038 020000      R     LJMP    _WriteGamma
                                           ; SOURCE LINE # 1195
                                           ; SOURCE LINE # 1196
003B         ?C0099:
                                           ; SOURCE LINE # 1197
003B E4                CLR     A
003C FB                MOV     R3,A
003D 7DEB              MOV     R5,#0EBH
003F 7F5D              MOV     R7,#05DH
0041 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 1198
                                           ; SOURCE LINE # 1199
                                           ; SOURCE LINE # 1200
0044         ?C0100:
0044 22                RET     
             ; FUNCTION Set_Gamma (END)

             ; FUNCTION Set_Dithering (BEGIN)
                                           ; SOURCE LINE # 1202
                                           ; SOURCE LINE # 1203
                                           ; SOURCE LINE # 1215
0000 7E00        E     MOV     R6,#HIGH DITHER_1
0002 7F00        E     MOV     R7,#LOW DITHER_1
0004 C200        R     CLR     ?_WriteDither?BIT
0006 120000      R     LCALL   _WriteDither
                                           ; SOURCE LINE # 1221
0009 E4                CLR     A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 72  

000A FB                MOV     R3,A
000B 7D97              MOV     R5,#097H
000D 7F5D              MOV     R7,#05DH
000F 020000      E     LJMP    _RTDSetBit
             ; FUNCTION Set_Dithering (END)

             ; FUNCTION Sharpness (BEGIN)
                                           ; SOURCE LINE # 1226
                                           ; SOURCE LINE # 1227
                                           ; SOURCE LINE # 1228
0000 7800        E     MOV     R0,#LOW ucMode_Curr
0002 E6                MOV     A,@R0
0003 6054              JZ      ?C0111
0005 F4                CPL     A
0006 6051              JZ      ?C0111
                                           ; SOURCE LINE # 1229
                                           ; SOURCE LINE # 1232
0008 7DC4              MOV     R5,#0C4H
000A 7F1B              MOV     R7,#01BH
000C 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1234
000F E500        R     MOV     A,stGUD1+02H
0011 14                DEC     A
0012 6010              JZ      ?C0105
0014 14                DEC     A
0015 6013              JZ      ?C0106
0017 14                DEC     A
0018 6027              JZ      ?C0109
001A 2403              ADD     A,#03H
001C 7029              JNZ     ?C0110
                                           ; SOURCE LINE # 1235
                                           ; SOURCE LINE # 1236
001E         ?C0104:
                                           ; SOURCE LINE # 1237
001E 7C00        E     MOV     R4,#HIGH SU_COEF_1
0020 7D00        E     MOV     R5,#LOW SU_COEF_1
                                           ; SOURCE LINE # 1238
0022 8027              SJMP    ?C0237
                                           ; SOURCE LINE # 1239
0024         ?C0105:
                                           ; SOURCE LINE # 1240
0024 7C00        E     MOV     R4,#HIGH SU_COEF_2
0026 7D00        E     MOV     R5,#LOW SU_COEF_2
0028         ?C0233:
                                           ; SOURCE LINE # 1241
0028 8021              SJMP    ?C0237
                                           ; SOURCE LINE # 1242
002A         ?C0106:
                                           ; SOURCE LINE # 1243
002A 7800        R     MOV     R0,#LOW usIPH_ACT_WID+01H
002C E6                MOV     A,@R0
002D B4000B            CJNE    A,#00H,?C0107
0030 18                DEC     R0
0031 E6                MOV     A,@R0
0032 B40506            CJNE    A,#05H,?C0107
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0035 7C00        E     MOV     R4,#HIGH SU_COEF_7
0037 7D00        E     MOV     R5,#LOW SU_COEF_7
0039         ?C0234:
                                           ; SOURCE LINE # 1246
0039 8010              SJMP    ?C0237
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 73  

003B         ?C0107:
                                           ; SOURCE LINE # 1248
                                           ; SOURCE LINE # 1249
003B 7C00        E     MOV     R4,#HIGH SU_COEF_3
003D 7D00        E     MOV     R5,#LOW SU_COEF_3
003F         ?C0235:
                                           ; SOURCE LINE # 1250
                                           ; SOURCE LINE # 1252
003F 800A              SJMP    ?C0237
                                           ; SOURCE LINE # 1253
0041         ?C0109:
                                           ; SOURCE LINE # 1254
0041 7C00        E     MOV     R4,#HIGH SU_COEF_4
0043 7D00        E     MOV     R5,#LOW SU_COEF_4
0045         ?C0236:
                                           ; SOURCE LINE # 1255
0045 8004              SJMP    ?C0237
                                           ; SOURCE LINE # 1256
0047         ?C0110:
                                           ; SOURCE LINE # 1257
0047 7C00        E     MOV     R4,#HIGH SU_COEF_5
0049 7D00        E     MOV     R5,#LOW SU_COEF_5
004B         ?C0237:
004B AF05              MOV     R7,AR5
004D AE04              MOV     R6,AR4
004F 120000      R     LCALL   _WriteSU_COEF
                                           ; SOURCE LINE # 1258
                                           ; SOURCE LINE # 1259
0052         ?C0103:
                                           ; SOURCE LINE # 1261
0052 7DC7              MOV     R5,#0C7H
0054 7F1B              MOV     R7,#01BH
0056 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1262
                                           ; SOURCE LINE # 1263
0059         ?C0111:
0059 22                RET     
             ; FUNCTION Sharpness (END)

             ; FUNCTION _Set_Contrast_Gain (BEGIN)
                                           ; SOURCE LINE # 1268
;---- Variable 'ColorValue' assigned to Register 'R5' ----
;---- Variable 'ContrastValue' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1269
                                           ; SOURCE LINE # 1270
0000 EF                MOV     A,R7
0001 C3                CLR     C
0002 942D              SUBB    A,#02DH
0004 402D              JC      ?C0112
                                           ; SOURCE LINE # 1271
                                           ; SOURCE LINE # 1272
0006 ED                MOV     A,R5
0007 30E716            JNB     ACC.7,?C0113
                                           ; SOURCE LINE # 1273
                                           ; SOURCE LINE # 1274
000A 53057F            ANL     AR5,#07FH
                                           ; SOURCE LINE # 1275
000D ED                MOV     A,R5
000E 2F                ADD     A,R7
000F 24D3              ADD     A,#0D3H
0011 FD                MOV     R5,A
                                           ; SOURCE LINE # 1276
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 74  

0012 D3                SETB    C
0013 947F              SUBB    A,#07FH
0015 4004              JC      ?C0114
                                           ; SOURCE LINE # 1277
0017 7DFF              MOV     R5,#0FFH
0019 803B              SJMP    ?C0119
001B         ?C0114:
                                           ; SOURCE LINE # 1279
001B 430580            ORL     AR5,#080H
                                           ; SOURCE LINE # 1280
001E 8036              SJMP    ?C0119
0020         ?C0113:
                                           ; SOURCE LINE # 1282
                                           ; SOURCE LINE # 1283
0020 EF                MOV     A,R7
0021 24D3              ADD     A,#0D3H
0023 FE                MOV     R6,A
0024 ED                MOV     A,R5
0025 D3                SETB    C
0026 9E                SUBB    A,R6
0027 4005              JC      ?C0117
                                           ; SOURCE LINE # 1284
0029 ED                MOV     A,R5
002A 9E                SUBB    A,R6
002B FD                MOV     R5,A
002C 8028              SJMP    ?C0119
002E         ?C0117:
                                           ; SOURCE LINE # 1286
002E C3                CLR     C
002F EE                MOV     A,R6
0030 9D                SUBB    A,R5
                                           ; SOURCE LINE # 1287
                                           ; SOURCE LINE # 1288
0031 8018              SJMP    ?C0238
0033         ?C0112:
                                           ; SOURCE LINE # 1290
                                           ; SOURCE LINE # 1291
0033 ED                MOV     A,R5
0034 30E719            JNB     ACC.7,?C0120
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1293
0037 53057F            ANL     AR5,#07FH
                                           ; SOURCE LINE # 1294
003A C3                CLR     C
003B 742D              MOV     A,#02DH
003D 9F                SUBB    A,R7
003E FE                MOV     R6,A
003F D3                SETB    C
0040 9D                SUBB    A,R5
0041 4005              JC      ?C0121
                                           ; SOURCE LINE # 1295
0043 EE                MOV     A,R6
0044 9D                SUBB    A,R5
0045 FD                MOV     R5,A
0046 800E              SJMP    ?C0119
0048         ?C0121:
                                           ; SOURCE LINE # 1297
0048 C3                CLR     C
0049 ED                MOV     A,R5
004A 9E                SUBB    A,R6
004B         ?C0238:
004B 4480              ORL     A,#080H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 75  

004D FD                MOV     R5,A
                                           ; SOURCE LINE # 1299
004E 8006              SJMP    ?C0119
0050         ?C0120:
                                           ; SOURCE LINE # 1301
0050 C3                CLR     C
0051 742D              MOV     A,#02DH
0053 9F                SUBB    A,R7
0054 2D                ADD     A,R5
0055 FD                MOV     R5,A
                                           ; SOURCE LINE # 1302
0056         ?C0119:
                                           ; SOURCE LINE # 1304
0056 AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 1305
0058         ?C0124:
0058 22                RET     
             ; FUNCTION _Set_Contrast_Gain (END)

             ; FUNCTION _SetColorGainOffset (BEGIN)
                                           ; SOURCE LINE # 1309
0000 8F00        R     MOV     addr,R7
0002 8D00        R     MOV     parameter,R5
0004 8B00        R     MOV     bios,R3
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1311
0006 E500        R     MOV     A,bios
0008 30E715            JNB     ACC.7,?C0125
                                           ; SOURCE LINE # 1312
                                           ; SOURCE LINE # 1313
000B 53007F      R     ANL     bios,#07FH
                                           ; SOURCE LINE # 1314
000E E500        R     MOV     A,parameter
0010 C3                CLR     C
0011 9500        R     SUBB    A,bios
0013 4007              JC      ?C0126
0015 E500        R     MOV     A,parameter
0017 9500        R     SUBB    A,bios
0019 FD                MOV     R5,A
001A 8020              SJMP    ?C0239
001C         ?C0126:
001C 7D00              MOV     R5,#00H
001E         ?C0127:
                                           ; SOURCE LINE # 1315
001E 801C              SJMP    ?C0239
0020         ?C0125:
                                           ; SOURCE LINE # 1317
                                           ; SOURCE LINE # 1318
0020 C3                CLR     C
0021 74FF              MOV     A,#0FFH
0023 9500        R     SUBB    A,bios
0025 FF                MOV     R7,A
0026 E500        R     MOV     A,parameter
0028 C3                CLR     C
0029 9F                SUBB    A,R7
002A 4006              JC      ?C0129
002C 7E00              MOV     R6,#00H
002E 7FFF              MOV     R7,#0FFH
0030 8008              SJMP    ?C0130
0032         ?C0129:
0032 E500        R     MOV     A,parameter
0034 2500        R     ADD     A,bios
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 76  

0036 FF                MOV     R7,A
0037 E4                CLR     A
0038 33                RLC     A
0039 FE                MOV     R6,A
003A         ?C0130:
003A AD07              MOV     R5,AR7
003C         ?C0239:
003C AF00        R     MOV     R7,addr
003E 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1319
                                           ; SOURCE LINE # 1320
0041         ?C0131:
0041 22                RET     
             ; FUNCTION _SetColorGainOffset (END)

             ; FUNCTION SetADC_Gain (BEGIN)
                                           ; SOURCE LINE # 1322
                                           ; SOURCE LINE # 1323
                                           ; SOURCE LINE # 1336
0000 750032      R     MOV     ucTempContrast,#032H
                                           ; SOURCE LINE # 1337
0003 120000      R     LCALL   L?0260
0006 C006              PUSH    AR6
0008 C007              PUSH    AR7
000A 120000      R     LCALL   L?0249
000D D007              POP     AR7
000F D006              POP     AR6
0011 120000      R     LCALL   L?0271
;---- Variable 'ucRate1' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1338
;---- Variable 'ucRed' assigned to Register 'R3' ----
0014 E4                CLR     A
0015 F500        R     MOV     ucGreen,A
0017 F500        R     MOV     ucBlue,A
                                           ; SOURCE LINE # 1341
0019 746E              MOV     A,#06EH
001B C3                CLR     C
001C 9F                SUBB    A,R7
001D 500A              JNC     ?C0132
                                           ; SOURCE LINE # 1342
                                           ; SOURCE LINE # 1343
001F 7B9D              MOV     R3,#09DH
                                           ; SOURCE LINE # 1344
0021 75009C      R     MOV     ucGreen,#09CH
                                           ; SOURCE LINE # 1345
0024 75009B      R     MOV     ucBlue,#09BH
                                           ; SOURCE LINE # 1346
0027 8056              SJMP    ?C0133
0029         ?C0132:
                                           ; SOURCE LINE # 1347
0029 7464              MOV     A,#064H
002B C3                CLR     C
002C 9F                SUBB    A,R7
002D 500A              JNC     ?C0134
                                           ; SOURCE LINE # 1348
                                           ; SOURCE LINE # 1349
002F 7B8A              MOV     R3,#08AH
                                           ; SOURCE LINE # 1350
0031 75008C      R     MOV     ucGreen,#08CH
                                           ; SOURCE LINE # 1351
0034 75008A      R     MOV     ucBlue,#08AH
                                           ; SOURCE LINE # 1353
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 77  

0037 8046              SJMP    ?C0133
0039         ?C0134:
                                           ; SOURCE LINE # 1354
0039 745A              MOV     A,#05AH
003B C3                CLR     C
003C 9F                SUBB    A,R7
003D 500A              JNC     ?C0136
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1356
003F 7B01              MOV     R3,#01H
                                           ; SOURCE LINE # 1357
0041 750001      R     MOV     ucGreen,#01H
                                           ; SOURCE LINE # 1358
0044 750002      R     MOV     ucBlue,#02H
                                           ; SOURCE LINE # 1360
0047 8036              SJMP    ?C0133
0049         ?C0136:
                                           ; SOURCE LINE # 1361
0049 7446              MOV     A,#046H
004B C3                CLR     C
004C 9F                SUBB    A,R7
004D 500A              JNC     ?C0138
                                           ; SOURCE LINE # 1362
                                           ; SOURCE LINE # 1363
004F 7B06              MOV     R3,#06H
                                           ; SOURCE LINE # 1364
0051 750005      R     MOV     ucGreen,#05H
                                           ; SOURCE LINE # 1365
0054 750005      R     MOV     ucBlue,#05H
                                           ; SOURCE LINE # 1367
0057 8026              SJMP    ?C0133
0059         ?C0138:
                                           ; SOURCE LINE # 1368
0059 7430              MOV     A,#030H
005B C3                CLR     C
005C 9F                SUBB    A,R7
005D 5008              JNC     ?C0140
                                           ; SOURCE LINE # 1369
                                           ; SOURCE LINE # 1370
005F E4                CLR     A
0060 FB                MOV     R3,A
                                           ; SOURCE LINE # 1371
0061 F500        R     MOV     ucGreen,A
                                           ; SOURCE LINE # 1372
0063 F500        R     MOV     ucBlue,A
                                           ; SOURCE LINE # 1373
0065 8018              SJMP    ?C0133
0067         ?C0140:
                                           ; SOURCE LINE # 1374
0067 7426              MOV     A,#026H
0069 C3                CLR     C
006A 9F                SUBB    A,R7
006B 500A              JNC     ?C0142
                                           ; SOURCE LINE # 1375
                                           ; SOURCE LINE # 1376
006D 7B08              MOV     R3,#08H
                                           ; SOURCE LINE # 1377
006F 750009      R     MOV     ucGreen,#09H
                                           ; SOURCE LINE # 1378
0072 750008      R     MOV     ucBlue,#08H
                                           ; SOURCE LINE # 1380
0075 8008              SJMP    ?C0133
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 78  

0077         ?C0142:
                                           ; SOURCE LINE # 1382
                                           ; SOURCE LINE # 1383
0077 7B02              MOV     R3,#02H
                                           ; SOURCE LINE # 1384
0079 750005      R     MOV     ucGreen,#05H
                                           ; SOURCE LINE # 1385
007C 750004      R     MOV     ucBlue,#04H
                                           ; SOURCE LINE # 1386
007F         ?C0133:
                                           ; SOURCE LINE # 1391
007F 7464              MOV     A,#064H
0081 C3                CLR     C
0082 9500        R     SUBB    A,stGUD0
0084 5003              JNC     ?C0144
0086 750032      R     MOV     stGUD0,#032H
0089         ?C0144:
                                           ; SOURCE LINE # 1392
0089 AF00        R     MOV     R7,stGUD0
008B 7E00              MOV     R6,#00H
008D 7C00              MOV     R4,#00H
008F 7D09              MOV     R5,#09H
0091 120000      E     LCALL   ?C?IMUL
0094 0D                INC     R5
0095 120000      E     LCALL   ?C?UIDIV
0098 8F00        R     MOV     ucTempContrast,R7
                                           ; SOURCE LINE # 1394
009A AD03              MOV     R5,AR3
009C 120000      R     LCALL   _Set_Contrast_Gain
009F AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 1395
00A1 AD00        R     MOV     R5,ucGreen
00A3 AF00        R     MOV     R7,ucTempContrast
00A5 120000      R     LCALL   _Set_Contrast_Gain
00A8 8F00        R     MOV     ucGreen,R7
                                           ; SOURCE LINE # 1396
00AA AD00        R     MOV     R5,ucBlue
00AC AF00        R     MOV     R7,ucTempContrast
00AE 120000      R     LCALL   _Set_Contrast_Gain
00B1 8F00        R     MOV     ucBlue,R7
                                           ; SOURCE LINE # 1405
00B3 AD00        R     MOV     R5,stGUD2
00B5 7FE0              MOV     R7,#0E0H
00B7 120000      R     LCALL   _SetColorGainOffset
                                           ; SOURCE LINE # 1408
00BA AB00        R     MOV     R3,ucGreen
00BC AD00        R     MOV     R5,stGUD2+01H
00BE 7FE1              MOV     R7,#0E1H
00C0 120000      R     LCALL   _SetColorGainOffset
                                           ; SOURCE LINE # 1413
00C3 AB00        R     MOV     R3,ucBlue
00C5 AD00        R     MOV     R5,stGUD2+02H
00C7 7FE2              MOV     R7,#0E2H
00C9 020000      R     LJMP    _SetColorGainOffset
             ; FUNCTION SetADC_Gain (END)

             ; FUNCTION SetADC_Offset (BEGIN)
                                           ; SOURCE LINE # 1419
                                           ; SOURCE LINE # 1420
                                           ; SOURCE LINE # 1432
0000 E4                CLR     A
0001 F500        R     MOV     ucRed,A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 79  

0003 F500        R     MOV     ucBlue,A
0005 F500        R     MOV     ucGreen,A
                                           ; SOURCE LINE # 1433
0007 120000      R     LCALL   L?0260
000A C006              PUSH    AR6
000C C007              PUSH    AR7
000E 120000      R     LCALL   L?0249
0011 D007              POP     AR7
0013 D006              POP     AR6
0015 120000      R     LCALL   L?0271
;---- Variable 'ucRate' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1436
0018 746E              MOV     A,#06EH
001A C3                CLR     C
001B 9F                SUBB    A,R7
001C 500B              JNC     ?C0146
                                           ; SOURCE LINE # 1437
                                           ; SOURCE LINE # 1438
001E 75000A      R     MOV     ucRed,#0AH
                                           ; SOURCE LINE # 1439
0021 75000B      R     MOV     ucGreen,#0BH
                                           ; SOURCE LINE # 1440
0024 75000B      R     MOV     ucBlue,#0BH
                                           ; SOURCE LINE # 1441
0027 8037              SJMP    ?C0147
0029         ?C0146:
                                           ; SOURCE LINE # 1442
0029 745A              MOV     A,#05AH
002B C3                CLR     C
002C 9F                SUBB    A,R7
002D 500B              JNC     ?C0148
                                           ; SOURCE LINE # 1443
                                           ; SOURCE LINE # 1444
002F 750005      R     MOV     ucRed,#05H
                                           ; SOURCE LINE # 1445
0032 750007      R     MOV     ucGreen,#07H
                                           ; SOURCE LINE # 1446
0035 750005      R     MOV     ucBlue,#05H
                                           ; SOURCE LINE # 1447
0038 8026              SJMP    ?C0147
003A         ?C0148:
                                           ; SOURCE LINE # 1448
003A 743C              MOV     A,#03CH
003C C3                CLR     C
003D 9F                SUBB    A,R7
003E 5009              JNC     ?C0150
                                           ; SOURCE LINE # 1449
                                           ; SOURCE LINE # 1450
0040 E4                CLR     A
0041 F500        R     MOV     ucRed,A
                                           ; SOURCE LINE # 1451
0043 F500        R     MOV     ucGreen,A
                                           ; SOURCE LINE # 1452
0045 F500        R     MOV     ucBlue,A
                                           ; SOURCE LINE # 1453
0047 8017              SJMP    ?C0147
0049         ?C0150:
                                           ; SOURCE LINE # 1454
0049 7430              MOV     A,#030H
004B C3                CLR     C
004C 9F                SUBB    A,R7
004D 5008              JNC     ?C0152
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 80  

                                           ; SOURCE LINE # 1455
                                           ; SOURCE LINE # 1456
004F 750081      R     MOV     ucRed,#081H
                                           ; SOURCE LINE # 1457
0052 E4                CLR     A
0053 F500        R     MOV     ucGreen,A
                                           ; SOURCE LINE # 1458
                                           ; SOURCE LINE # 1459
0055 8006              SJMP    ?C0240
0057         ?C0152:
                                           ; SOURCE LINE # 1461
                                           ; SOURCE LINE # 1462
0057 E4                CLR     A
0058 F500        R     MOV     ucRed,A
                                           ; SOURCE LINE # 1463
005A 750081      R     MOV     ucGreen,#081H
                                           ; SOURCE LINE # 1464
005D         ?C0240:
005D 750081      R     MOV     ucBlue,#081H
                                           ; SOURCE LINE # 1465
0060         ?C0147:
                                           ; SOURCE LINE # 1485
0060 AB00        R     MOV     R3,ucRed
0062 AD00        R     MOV     R5,stGUD2+03H
0064 7FE3              MOV     R7,#0E3H
0066 120000      R     LCALL   _SetColorGainOffset
                                           ; SOURCE LINE # 1488
0069 AB00        R     MOV     R3,ucGreen
006B AD00        R     MOV     R5,stGUD2+04H
006D 7FE4              MOV     R7,#0E4H
006F 120000      R     LCALL   _SetColorGainOffset
                                           ; SOURCE LINE # 1493
0072 AB00        R     MOV     R3,ucBlue
0074 AD00        R     MOV     R5,stGUD2+05H
0076 7FE5              MOV     R7,#0E5H
0078 020000      R     LJMP    _SetColorGainOffset
             ; FUNCTION SetADC_Offset (END)

             ; FUNCTION SetADC_GainOffset (BEGIN)
                                           ; SOURCE LINE # 1499
                                           ; SOURCE LINE # 1500
                                           ; SOURCE LINE # 1501
0000 120000      R     LCALL   SetADC_Gain
                                           ; SOURCE LINE # 1502
0003 020000      R     LJMP    SetADC_Offset
             ; FUNCTION SetADC_GainOffset (END)

             ; FUNCTION _Wait_For_Event (BEGIN)
                                           ; SOURCE LINE # 1552
0000 8F00        R     MOV     event,R7
                                           ; SOURCE LINE # 1553
                                           ; SOURCE LINE # 1554
0002 750050      R     MOV     ucDelayCnt,#050H
                                           ; SOURCE LINE # 1555
0005 750018      R     MOV     ucProtect,#018H
                                           ; SOURCE LINE # 1557
0008 E4                CLR     A
0009 FD                MOV     R5,A
000A 7F1F              MOV     R7,#01FH
000C 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 1559
000F C200        E     CLR     bNotify_Timer1_Int
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 81  

                                           ; SOURCE LINE # 1561
0011 E4                CLR     A
0012 F500        E     MOV     Data,A
                                           ; SOURCE LINE # 1562
0014 F500        E     MOV     Data+01H,A
                                           ; SOURCE LINE # 1563
0016 D28E              SETB    TR1
0018         ?C0158:
                                           ; SOURCE LINE # 1565
                                           ; SOURCE LINE # 1566
0018 30001E      E     JNB     bNotify_Timer1_Int,?C0159
                                           ; SOURCE LINE # 1567
                                           ; SOURCE LINE # 1568
001B C200        E     CLR     bNotify_Timer1_Int
                                           ; SOURCE LINE # 1570
001D E500        E     MOV     A,Data+01H
001F 5403              ANL     A,#03H
0021 6008              JZ      ?C0160
                                           ; SOURCE LINE # 1571
                                           ; SOURCE LINE # 1572
0023 E4                CLR     A
0024 F500        E     MOV     Data+01H,A
                                           ; SOURCE LINE # 1573
0026 750018      R     MOV     ucProtect,#018H
                                           ; SOURCE LINE # 1574
0029 8006              SJMP    ?C0161
002B         ?C0160:
                                           ; SOURCE LINE # 1575
002B E500        R     MOV     A,ucProtect
002D 6002              JZ      ?C0161
                                           ; SOURCE LINE # 1576
                                           ; SOURCE LINE # 1577
002F 1500        R     DEC     ucProtect
                                           ; SOURCE LINE # 1578
0031         ?C0161:
                                           ; SOURCE LINE # 1580
0031 1500        R     DEC     ucDelayCnt
0033 E500        R     MOV     A,ucDelayCnt
0035 6002              JZ      ?C0159
0037 D28E              SETB    TR1
                                           ; SOURCE LINE # 1581
0039         ?C0159:
                                           ; SOURCE LINE # 1584
0039 7B01              MOV     R3,#01H
003B 7D01              MOV     R5,#01H
003D 7F1F              MOV     R7,#01FH
003F 120000      E     LCALL   _RTDRead
                                           ; SOURCE LINE # 1587
0042 E500        E     MOV     A,Data
0044 6007              JZ      ?C0164
                                           ; SOURCE LINE # 1588
0046 E4                CLR     A
0047 FD                MOV     R5,A
0048 7F1F              MOV     R7,#01FH
004A 120000      E     LCALL   _RTDSetByte
004D         ?C0164:
                                           ; SOURCE LINE # 1591
004D E500        E     MOV     A,Data
004F 5403              ANL     A,#03H
0051 4200        E     ORL     Data+01H,A
                                           ; SOURCE LINE # 1592
0053 E500        R     MOV     A,event
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 82  

0055 5200        E     ANL     Data,A
                                           ; SOURCE LINE # 1594
                                           ; SOURCE LINE # 1595
0057 E500        E     MOV     A,Data
0059 7004              JNZ     ?C0166
005B E500        R     MOV     A,ucDelayCnt
005D 70B9              JNZ     ?C0158
                                           ; SOURCE LINE # 1596
005F         ?C0166:
005F 22                RET     
             ; FUNCTION _Wait_For_Event (END)

             ; FUNCTION Save_GUD0 (BEGIN)
                                           ; SOURCE LINE # 1663
                                           ; SOURCE LINE # 1664
                                           ; SOURCE LINE # 1665
0000 75000B      E     MOV     Data,#0BH
                                           ; SOURCE LINE # 1666
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1667
0006 7500E0      E     MOV     Data+02H,#0E0H
                                           ; SOURCE LINE # 1668
0009 850000      E     MOV     Data+03H,stGUD0
                                           ; SOURCE LINE # 1669
000C 850000      E     MOV     Data+04H,stGUD0+01H
                                           ; SOURCE LINE # 1670
000F 850000      E     MOV     Data+05H,stGUD0+02H
                                           ; SOURCE LINE # 1671
0012 850000      E     MOV     Data+06H,stGUD0+03H
                                           ; SOURCE LINE # 1672
0015 850000      E     MOV     Data+07H,stGUD0+04H
                                           ; SOURCE LINE # 1673
0018 850000      E     MOV     Data+08H,stGUD0+05H
                                           ; SOURCE LINE # 1674
001B 850000      E     MOV     Data+09H,stGUD0+06H
                                           ; SOURCE LINE # 1675
001E 850000      E     MOV     Data+0AH,stGUD0+07H
                                           ; SOURCE LINE # 1676
0021 120000      R     LCALL   L?0261
0024 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1678
0027 7F10              MOV     R7,#010H
0029 020000      E     LJMP    _Delay_Xms
             ; FUNCTION Save_GUD0 (END)

             ; FUNCTION Load_GUD0 (BEGIN)
                                           ; SOURCE LINE # 1681
                                           ; SOURCE LINE # 1682
                                           ; SOURCE LINE # 1683
0000 7B08              MOV     R3,#08H
0002 7DE0              MOV     R5,#0E0H
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1685
0009 850000      R     MOV     stGUD0,Data
                                           ; SOURCE LINE # 1686
000C 850000      R     MOV     stGUD0+01H,Data+01H
                                           ; SOURCE LINE # 1687
000F 850000      R     MOV     stGUD0+02H,Data+02H
                                           ; SOURCE LINE # 1688
0012 850000      R     MOV     stGUD0+03H,Data+03H
                                           ; SOURCE LINE # 1689
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 83  

0015 850000      R     MOV     stGUD0+04H,Data+04H
                                           ; SOURCE LINE # 1690
0018 850000      R     MOV     stGUD0+05H,Data+05H
                                           ; SOURCE LINE # 1691
001B 850000      R     MOV     stGUD0+06H,Data+06H
                                           ; SOURCE LINE # 1692
001E 850000      R     MOV     stGUD0+07H,Data+07H
                                           ; SOURCE LINE # 1693
0021 22                RET     
             ; FUNCTION Load_GUD0 (END)

             ; FUNCTION Save_GUD1 (BEGIN)
                                           ; SOURCE LINE # 1695
                                           ; SOURCE LINE # 1696
                                           ; SOURCE LINE # 1697
0000 75000A      E     MOV     Data,#0AH
                                           ; SOURCE LINE # 1698
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1699
0006 7500E8      E     MOV     Data+02H,#0E8H
                                           ; SOURCE LINE # 1700
0009 850000      E     MOV     Data+03H,stGUD1
                                           ; SOURCE LINE # 1701
000C 850000      E     MOV     Data+04H,stGUD1+01H
                                           ; SOURCE LINE # 1702
000F 850000      E     MOV     Data+05H,stGUD1+02H
                                           ; SOURCE LINE # 1703
0012 850000      E     MOV     Data+06H,stGUD1+04H
                                           ; SOURCE LINE # 1704
0015 850000      E     MOV     Data+07H,stGUD1+05H
                                           ; SOURCE LINE # 1705
0018 850000      E     MOV     Data+08H,stGUD1+06H
                                           ; SOURCE LINE # 1706
001B 850000      E     MOV     Data+09H,stGUD1+07H
                                           ; SOURCE LINE # 1707
001E E4                CLR     A
001F F500        E     MOV     Data+0AH,A
                                           ; SOURCE LINE # 1708
0021 FB                MOV     R3,A
0022 7A00        E     MOV     R2,#HIGH Data
0024 7900        E     MOV     R1,#LOW Data
0026 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1710
0029 7F10              MOV     R7,#010H
002B 020000      E     LJMP    _Delay_Xms
             ; FUNCTION Save_GUD1 (END)

             ; FUNCTION Load_GUD1 (BEGIN)
                                           ; SOURCE LINE # 1713
                                           ; SOURCE LINE # 1714
                                           ; SOURCE LINE # 1715
0000 7B07              MOV     R3,#07H
0002 7DE8              MOV     R5,#0E8H
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1717
0009 850000      R     MOV     stGUD1,Data
                                           ; SOURCE LINE # 1718
000C 850000      R     MOV     stGUD1+01H,Data+01H
                                           ; SOURCE LINE # 1719
000F 850000      R     MOV     stGUD1+02H,Data+02H
                                           ; SOURCE LINE # 1720
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 84  

0012 750000      R     MOV     stGUD1+03H,#00H
0015 850000      R     MOV     stGUD1+04H,Data+03H
                                           ; SOURCE LINE # 1721
0018 850000      R     MOV     stGUD1+05H,Data+04H
                                           ; SOURCE LINE # 1722
001B 850000      R     MOV     stGUD1+06H,Data+05H
                                           ; SOURCE LINE # 1723
001E 850000      R     MOV     stGUD1+07H,Data+06H
                                           ; SOURCE LINE # 1725
0021 22                RET     
             ; FUNCTION Load_GUD1 (END)

             ; FUNCTION Save_GUD2 (BEGIN)
                                           ; SOURCE LINE # 1727
                                           ; SOURCE LINE # 1728
                                           ; SOURCE LINE # 1729
0000 750009      E     MOV     Data,#09H
                                           ; SOURCE LINE # 1730
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1731
0006 7500F0      E     MOV     Data+02H,#0F0H
                                           ; SOURCE LINE # 1732
0009 850000      E     MOV     Data+03H,stGUD2
                                           ; SOURCE LINE # 1733
000C 850000      E     MOV     Data+04H,stGUD2+01H
                                           ; SOURCE LINE # 1734
000F 850000      E     MOV     Data+05H,stGUD2+02H
                                           ; SOURCE LINE # 1735
0012 850000      E     MOV     Data+06H,stGUD2+03H
                                           ; SOURCE LINE # 1736
0015 850000      E     MOV     Data+07H,stGUD2+04H
                                           ; SOURCE LINE # 1737
0018 850000      E     MOV     Data+08H,stGUD2+05H
                                           ; SOURCE LINE # 1739
001B 120000      R     LCALL   L?0261
001E 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1740
0021 7F10              MOV     R7,#010H
0023 020000      E     LJMP    _Delay_Xms
             ; FUNCTION Save_GUD2 (END)

             ; FUNCTION Load_GUD2 (BEGIN)
                                           ; SOURCE LINE # 1743
                                           ; SOURCE LINE # 1744
                                           ; SOURCE LINE # 1745
0000 7B06              MOV     R3,#06H
0002 7DF0              MOV     R5,#0F0H
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1747
0009 850000      R     MOV     stGUD2,Data
                                           ; SOURCE LINE # 1748
000C 850000      R     MOV     stGUD2+01H,Data+01H
                                           ; SOURCE LINE # 1749
000F 850000      R     MOV     stGUD2+02H,Data+02H
                                           ; SOURCE LINE # 1750
0012 850000      R     MOV     stGUD2+03H,Data+03H
                                           ; SOURCE LINE # 1751
0015 850000      R     MOV     stGUD2+04H,Data+04H
                                           ; SOURCE LINE # 1752
0018 850000      R     MOV     stGUD2+05H,Data+05H
                                           ; SOURCE LINE # 1753
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 85  

001B 22                RET     
             ; FUNCTION Load_GUD2 (END)

             ; FUNCTION Save_GUD3 (BEGIN)
                                           ; SOURCE LINE # 1755
                                           ; SOURCE LINE # 1756
                                           ; SOURCE LINE # 1757
0000 750007      E     MOV     Data,#07H
                                           ; SOURCE LINE # 1758
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1759
0006 7500F8      E     MOV     Data+02H,#0F8H
                                           ; SOURCE LINE # 1760
0009 850000      E     MOV     Data+03H,stGUD3
                                           ; SOURCE LINE # 1761
000C 850000      E     MOV     Data+04H,stGUD3+01H
                                           ; SOURCE LINE # 1762
000F 850000      E     MOV     Data+05H,stGUD3+02H
                                           ; SOURCE LINE # 1763
0012 850000      E     MOV     Data+06H,stGUD3+03H
                                           ; SOURCE LINE # 1765
0015 120000      R     LCALL   L?0262
0018 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1766
001B 7F10              MOV     R7,#010H
001D 020000      E     LJMP    _Delay_Xms
             ; FUNCTION Save_GUD3 (END)

             ; FUNCTION Load_GUD3 (BEGIN)
                                           ; SOURCE LINE # 1769
                                           ; SOURCE LINE # 1770
                                           ; SOURCE LINE # 1771
0000 7B04              MOV     R3,#04H
0002 7DF8              MOV     R5,#0F8H
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1773
0009 850000      R     MOV     stGUD3,Data
                                           ; SOURCE LINE # 1774
000C 850000      R     MOV     stGUD3+01H,Data+01H
                                           ; SOURCE LINE # 1775
000F 850000      R     MOV     stGUD3+02H,Data+02H
                                           ; SOURCE LINE # 1776
0012 850000      R     MOV     stGUD3+03H,Data+03H
                                           ; SOURCE LINE # 1777
0015 22                RET     
             ; FUNCTION Load_GUD3 (END)

             ; FUNCTION Save_GUD4 (BEGIN)
                                           ; SOURCE LINE # 1779
                                           ; SOURCE LINE # 1780
                                           ; SOURCE LINE # 1781
0000 75000C      E     MOV     Data,#0CH
                                           ; SOURCE LINE # 1782
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1783
0006 7500D0      E     MOV     Data+02H,#0D0H
                                           ; SOURCE LINE # 1784
0009 850000      E     MOV     Data+03H,stGUD4
                                           ; SOURCE LINE # 1785
000C 850000      E     MOV     Data+04H,stGUD4+01H
                                           ; SOURCE LINE # 1786
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 86  

000F 850000      E     MOV     Data+05H,stGUD4+02H
                                           ; SOURCE LINE # 1787
0012 850000      E     MOV     Data+06H,stGUD4+03H
                                           ; SOURCE LINE # 1788
0015 850000      E     MOV     Data+07H,stGUD4+04H
                                           ; SOURCE LINE # 1789
0018 850000      E     MOV     Data+08H,stGUD4+05H
                                           ; SOURCE LINE # 1790
001B 850000      E     MOV     Data+09H,stGUD4+06H
                                           ; SOURCE LINE # 1791
001E 850000      E     MOV     Data+0AH,stGUD4+07H
                                           ; SOURCE LINE # 1792
0021 850000      E     MOV     Data+0BH,stGUD4+08H
                                           ; SOURCE LINE # 1793
0024 120000      R     LCALL   L?0262
0027 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1795
002A 7F10              MOV     R7,#010H
002C 020000      E     LJMP    _Delay_Xms
             ; FUNCTION Save_GUD4 (END)

             ; FUNCTION Load_GUD4 (BEGIN)
                                           ; SOURCE LINE # 1798
                                           ; SOURCE LINE # 1799
                                           ; SOURCE LINE # 1800
0000 7B09              MOV     R3,#09H
0002 7DD0              MOV     R5,#0D0H
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1802
0009 850000      R     MOV     stGUD4,Data
                                           ; SOURCE LINE # 1803
000C 850000      R     MOV     stGUD4+01H,Data+01H
                                           ; SOURCE LINE # 1804
000F 850000      R     MOV     stGUD4+02H,Data+02H
                                           ; SOURCE LINE # 1805
0012 850000      R     MOV     stGUD4+03H,Data+03H
                                           ; SOURCE LINE # 1806
0015 850000      R     MOV     stGUD4+04H,Data+04H
                                           ; SOURCE LINE # 1807
0018 850000      R     MOV     stGUD4+05H,Data+05H
                                           ; SOURCE LINE # 1808
001B 850000      R     MOV     stGUD4+06H,Data+06H
                                           ; SOURCE LINE # 1809
001E 850000      R     MOV     stGUD4+07H,Data+07H
                                           ; SOURCE LINE # 1810
0021 850000      R     MOV     stGUD4+08H,Data+08H
                                           ; SOURCE LINE # 1811
0024 22                RET     
             ; FUNCTION Load_GUD4 (END)

             ; FUNCTION _Save_MUD (BEGIN)
                                           ; SOURCE LINE # 1814
;---- Variable 'mode_num' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1815
                                           ; SOURCE LINE # 1816
0000 EF                MOV     A,R7
0001 602F              JZ      ?C0179
0003 7440              MOV     A,#040H
0005 C3                CLR     C
0006 9F                SUBB    A,R7
0007 4029              JC      ?C0179
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 87  

0009         ?C0177:
                                           ; SOURCE LINE # 1818
0009 750007      E     MOV     Data,#07H
                                           ; SOURCE LINE # 1819
000C 7500AC      E     MOV     Data+01H,#0ACH
                                           ; SOURCE LINE # 1820
000F EF                MOV     A,R7
0010 14                DEC     A
0011 FF                MOV     R7,A
0012 25E0              ADD     A,ACC
0014 25E0              ADD     A,ACC
0016 F500        E     MOV     Data+02H,A
                                           ; SOURCE LINE # 1821
0018 850000      E     MOV     Data+03H,stMUD
                                           ; SOURCE LINE # 1822
001B 850000      E     MOV     Data+04H,stMUD+01H
                                           ; SOURCE LINE # 1823
001E 850000      E     MOV     Data+05H,stMUD+02H
                                           ; SOURCE LINE # 1824
0021 E500        R     MOV     A,stMUD+03H
0023 547C              ANL     A,#07CH
0025 F500        E     MOV     Data+06H,A
                                           ; SOURCE LINE # 1825
0027 120000      R     LCALL   L?0262
002A 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1827
002D 7F10              MOV     R7,#010H
002F 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 1828
0032         ?C0179:
0032 22                RET     
             ; FUNCTION _Save_MUD (END)

             ; FUNCTION _Load_MUD (BEGIN)
                                           ; SOURCE LINE # 1830
;---- Variable 'mode_num' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1831
                                           ; SOURCE LINE # 1832
0000 EF                MOV     A,R7
0001 6023              JZ      ?C0182
0003 7440              MOV     A,#040H
0005 C3                CLR     C
0006 9F                SUBB    A,R7
0007 401D              JC      ?C0182
0009         ?C0180:
                                           ; SOURCE LINE # 1834
0009 EF                MOV     A,R7
000A 14                DEC     A
000B 25E0              ADD     A,ACC
000D 25E0              ADD     A,ACC
000F FD                MOV     R5,A
0010 7B04              MOV     R3,#04H
0012 7FAC              MOV     R7,#0ACH
0014 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 1836
0017 850000      R     MOV     stMUD,Data
                                           ; SOURCE LINE # 1837
001A 850000      R     MOV     stMUD+01H,Data+01H
                                           ; SOURCE LINE # 1838
001D 850000      R     MOV     stMUD+02H,Data+02H
                                           ; SOURCE LINE # 1839
0020 E500        E     MOV     A,Data+03H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 88  

0022 547C              ANL     A,#07CH
0024 F500        R     MOV     stMUD+03H,A
                                           ; SOURCE LINE # 1843
0026         ?C0182:
0026 22                RET     
             ; FUNCTION _Load_MUD (END)

             ; FUNCTION Init_GUD (BEGIN)
                                           ; SOURCE LINE # 1845
                                           ; SOURCE LINE # 1846
                                           ; SOURCE LINE # 1847
                                           ; SOURCE LINE # 1848
0000 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 1849
0003 A3                INC     DPTR
0004 E4                CLR     A
0005 93                MOVC    A,@A+DPTR
0006 F500        R     MOV     stGUD0+02H,A
                                           ; SOURCE LINE # 1850
0008 A3                INC     DPTR
0009 E4                CLR     A
000A 93                MOVC    A,@A+DPTR
000B F500        R     MOV     stGUD0+03H,A
                                           ; SOURCE LINE # 1851
000D A3                INC     DPTR
000E E4                CLR     A
000F 93                MOVC    A,@A+DPTR
0010 F500        R     MOV     stGUD0+04H,A
                                           ; SOURCE LINE # 1852
0012 A3                INC     DPTR
                                           ; SOURCE LINE # 1853
                                           ; SOURCE LINE # 1854
                                           ; SOURCE LINE # 1856
                                           ; SOURCE LINE # 1857
                                           ; SOURCE LINE # 1858
                                           ; SOURCE LINE # 1859
                                           ; SOURCE LINE # 1860
                                           ; SOURCE LINE # 1861
                                           ; SOURCE LINE # 1862
0013 120000      R     LCALL   L?0247
                                           ; SOURCE LINE # 1864
0016 900000      R     MOV     DPTR,#INIT_EEPROM1+03H
0019 E4                CLR     A
001A 93                MOVC    A,@A+DPTR
001B F500        R     MOV     stGUD2,A
                                           ; SOURCE LINE # 1865
001D A3                INC     DPTR
001E E4                CLR     A
001F 93                MOVC    A,@A+DPTR
0020 F500        R     MOV     stGUD2+01H,A
                                           ; SOURCE LINE # 1866
0022 A3                INC     DPTR
0023 E4                CLR     A
0024 93                MOVC    A,@A+DPTR
0025 F500        R     MOV     stGUD2+02H,A
                                           ; SOURCE LINE # 1867
0027 A3                INC     DPTR
0028 E4                CLR     A
0029 93                MOVC    A,@A+DPTR
002A F500        R     MOV     stGUD2+03H,A
                                           ; SOURCE LINE # 1868
002C A3                INC     DPTR
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 89  

002D E4                CLR     A
002E 93                MOVC    A,@A+DPTR
002F F500        R     MOV     stGUD2+04H,A
                                           ; SOURCE LINE # 1869
0031 A3                INC     DPTR
0032 E4                CLR     A
0033 93                MOVC    A,@A+DPTR
0034 F500        R     MOV     stGUD2+05H,A
                                           ; SOURCE LINE # 1871
                                           ; SOURCE LINE # 1872
                                           ; SOURCE LINE # 1873
0036 120000      R     LCALL   L?0263
                                           ; SOURCE LINE # 1874
0039 A3                INC     DPTR
003A E4                CLR     A
003B 93                MOVC    A,@A+DPTR
003C F500        R     MOV     stGUD3+03H,A
                                           ; SOURCE LINE # 1876
003E 900000      R     MOV     DPTR,#INIT_EEPROM2+03H
0041 E4                CLR     A
0042 93                MOVC    A,@A+DPTR
0043 F500        R     MOV     stGUD4,A
                                           ; SOURCE LINE # 1877
0045 A3                INC     DPTR
0046 E4                CLR     A
0047 93                MOVC    A,@A+DPTR
0048 F500        R     MOV     stGUD4+01H,A
                                           ; SOURCE LINE # 1878
004A A3                INC     DPTR
004B E4                CLR     A
004C 93                MOVC    A,@A+DPTR
004D F500        R     MOV     stGUD4+02H,A
                                           ; SOURCE LINE # 1879
004F A3                INC     DPTR
0050 E4                CLR     A
0051 93                MOVC    A,@A+DPTR
0052 F500        R     MOV     stGUD4+03H,A
                                           ; SOURCE LINE # 1880
0054 A3                INC     DPTR
0055 E4                CLR     A
0056 93                MOVC    A,@A+DPTR
0057 F500        R     MOV     stGUD4+04H,A
                                           ; SOURCE LINE # 1881
0059 A3                INC     DPTR
005A E4                CLR     A
005B 93                MOVC    A,@A+DPTR
005C F500        R     MOV     stGUD4+05H,A
                                           ; SOURCE LINE # 1882
005E A3                INC     DPTR
005F E4                CLR     A
0060 93                MOVC    A,@A+DPTR
0061 F500        R     MOV     stGUD4+06H,A
                                           ; SOURCE LINE # 1883
0063 A3                INC     DPTR
0064 E4                CLR     A
0065 93                MOVC    A,@A+DPTR
0066 F500        R     MOV     stGUD4+07H,A
                                           ; SOURCE LINE # 1884
0068 A3                INC     DPTR
0069 E4                CLR     A
006A 93                MOVC    A,@A+DPTR
006B F500        R     MOV     stGUD4+08H,A
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 90  

                                           ; SOURCE LINE # 1887
006D 7A00        R     MOV     R2,#HIGH INIT_EEPROM0
006F 7900        R     MOV     R1,#LOW INIT_EEPROM0
                                           ; SOURCE LINE # 1888
0071 120000      R     LCALL   L?0275
0074 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 1890
0077 7A00        R     MOV     R2,#HIGH INIT_EEPROM1
0079 7900        R     MOV     R1,#LOW INIT_EEPROM1
                                           ; SOURCE LINE # 1891
007B 120000      R     LCALL   L?0275
007E 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 1893
0081 7BFF              MOV     R3,#0FFH
0083 7A00        R     MOV     R2,#HIGH INIT_EEPROM2
0085 7900        R     MOV     R1,#LOW INIT_EEPROM2
0087 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1894
008A 7F10              MOV     R7,#010H
008C 020000      E     LJMP    _Delay_Xms
                                           ; SOURCE LINE # 1898
008F         L?0275:
008F 7BFF              MOV     R3,#0FFH
0091 120000      E     LCALL   _I2CWrite
0094 7F10              MOV     R7,#010H
0096 22                RET     
             ; FUNCTION Init_GUD (END)

             ; FUNCTION Init_MUD (BEGIN)
                                           ; SOURCE LINE # 1900
                                           ; SOURCE LINE # 1901
                                           ; SOURCE LINE # 1905
0000 75000B      E     MOV     Data,#0BH
                                           ; SOURCE LINE # 1906
0003 7500AE      E     MOV     Data+01H,#0AEH
                                           ; SOURCE LINE # 1907
0006 E4                CLR     A
0007 F500        E     MOV     Data+02H,A
                                           ; SOURCE LINE # 1908
0009 7500FF      E     MOV     Data+03H,#0FFH
                                           ; SOURCE LINE # 1909
000C 7500FF      E     MOV     Data+04H,#0FFH
                                           ; SOURCE LINE # 1910
000F 7500FF      E     MOV     Data+05H,#0FFH
                                           ; SOURCE LINE # 1911
0012 7500FF      E     MOV     Data+06H,#0FFH
                                           ; SOURCE LINE # 1912
0015 7500FF      E     MOV     Data+07H,#0FFH
                                           ; SOURCE LINE # 1913
0018 7500FF      E     MOV     Data+08H,#0FFH
                                           ; SOURCE LINE # 1914
001B 7500FF      E     MOV     Data+09H,#0FFH
                                           ; SOURCE LINE # 1915
001E 7500FF      E     MOV     Data+0AH,#0FFH
                                           ; SOURCE LINE # 1916
0021 FB                MOV     R3,A
0022 7A00        E     MOV     R2,#HIGH Data
0024 7900        E     MOV     R1,#LOW Data
0026 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 1917
0029 7F10              MOV     R7,#010H
002B 120000      E     LCALL   _Delay_Xms
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 91  

                                           ; SOURCE LINE # 1944
002E 750007      E     MOV     Data,#07H
                                           ; SOURCE LINE # 1945
0031 7500AC      E     MOV     Data+01H,#0ACH
                                           ; SOURCE LINE # 1946
0034 E4                CLR     A
0035 F500        E     MOV     Data+02H,A
                                           ; SOURCE LINE # 1947
0037 750080      E     MOV     Data+03H,#080H
                                           ; SOURCE LINE # 1948
003A 750080      E     MOV     Data+04H,#080H
                                           ; SOURCE LINE # 1949
003D 750080      E     MOV     Data+05H,#080H
                                           ; SOURCE LINE # 1950
0040 750001      E     MOV     Data+06H,#01H
                                           ; SOURCE LINE # 1952
0043 F500        R     MOV     ucModeIdx,A
0045         ?C0186:
                                           ; SOURCE LINE # 1954
                                           ; SOURCE LINE # 1955
0045 E500        R     MOV     A,ucModeIdx
0047 25E0              ADD     A,ACC
0049 25E0              ADD     A,ACC
004B F500        E     MOV     Data+02H,A
                                           ; SOURCE LINE # 1956
004D 0500        R     INC     ucModeIdx
                                           ; SOURCE LINE # 1958
004F E500        R     MOV     A,ucModeIdx
0051 24C2              ADD     A,#0C2H
0053 6020              JZ      ?C0190
0055 14                DEC     A
0056 602B              JZ      ?C0191
0058 24FE              ADD     A,#0FEH
005A 600E              JZ      ?C0189
005C 04                INC     A
005D 7030              JNZ     ?C0187
                                           ; SOURCE LINE # 1959
                                           ; SOURCE LINE # 1960
005F         ?C0188:
                                           ; SOURCE LINE # 1961
005F 7500BC      E     MOV     Data+03H,#0BCH
                                           ; SOURCE LINE # 1962
0062 7500E5      E     MOV     Data+04H,#0E5H
                                           ; SOURCE LINE # 1963
0065 7500E4      E     MOV     Data+05H,#0E4H
                                           ; SOURCE LINE # 1964
                                           ; SOURCE LINE # 1965
0068 8022              SJMP    ?C0242
                                           ; SOURCE LINE # 1966
006A         ?C0189:
                                           ; SOURCE LINE # 1967
006A 7500B1      E     MOV     Data+03H,#0B1H
                                           ; SOURCE LINE # 1968
006D 7500DF      E     MOV     Data+04H,#0DFH
                                           ; SOURCE LINE # 1969
0070 7500E5      E     MOV     Data+05H,#0E5H
                                           ; SOURCE LINE # 1970
0073         ?C0241:
                                           ; SOURCE LINE # 1971
0073 8017              SJMP    ?C0242
                                           ; SOURCE LINE # 1986
0075         ?C0190:
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 92  

                                           ; SOURCE LINE # 1987
0075 750095      E     MOV     Data+03H,#095H
                                           ; SOURCE LINE # 1988
0078 7500C7      E     MOV     Data+04H,#0C7H
                                           ; SOURCE LINE # 1989
007B 7500C8      E     MOV     Data+05H,#0C8H
                                           ; SOURCE LINE # 1990
007E 75007F      E     MOV     Data+06H,#07FH
                                           ; SOURCE LINE # 1991
0081 800C              SJMP    ?C0187
                                           ; SOURCE LINE # 1992
0083         ?C0191:
                                           ; SOURCE LINE # 1993
0083 750082      E     MOV     Data+03H,#082H
                                           ; SOURCE LINE # 1994
0086 7500C7      E     MOV     Data+04H,#0C7H
                                           ; SOURCE LINE # 1995
0089 7500C2      E     MOV     Data+05H,#0C2H
                                           ; SOURCE LINE # 1996
008C         ?C0242:
008C 750080      E     MOV     Data+06H,#080H
                                           ; SOURCE LINE # 1997
                                           ; SOURCE LINE # 1999
008F         ?C0187:
                                           ; SOURCE LINE # 2001
008F 120000      R     LCALL   L?0262
0092 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 2002
0095 7F10              MOV     R7,#010H
0097 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 2003
                                           ; SOURCE LINE # 2004
009A 7440              MOV     A,#040H
009C D3                SETB    C
009D 9500        R     SUBB    A,ucModeIdx
009F 50A4              JNC     ?C0186
                                           ; SOURCE LINE # 2005
00A1 22                RET     
             ; FUNCTION Init_MUD (END)

             ; FUNCTION Check_EEPROM (BEGIN)
                                           ; SOURCE LINE # 2007
                                           ; SOURCE LINE # 2008
                                           ; SOURCE LINE # 2009
0000 7B02              MOV     R3,#02H
0002 7DFE              MOV     R5,#0FEH
0004 7FAE              MOV     R7,#0AEH
0006 120000      E     LCALL   _I2CRead
                                           ; SOURCE LINE # 2011
0009 900000      R     MOV     DPTR,#INIT_EEPROM1+011H
000C E4                CLR     A
000D 93                MOVC    A,@A+DPTR
000E B50007      E     CJNE    A,Data,?C0194
0011 A3                INC     DPTR
0012 E4                CLR     A
0013 93                MOVC    A,@A+DPTR
0014 6500        E     XRL     A,Data+01H
0016 600B              JZ      ?C0193
0018         ?C0194:
                                           ; SOURCE LINE # 2012
                                           ; SOURCE LINE # 2013
0018 7F10              MOV     R7,#010H
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 93  

001A 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 2015
001D 120000      R     LCALL   Init_GUD
                                           ; SOURCE LINE # 2016
0020 020000      R     LJMP    Init_MUD
                                           ; SOURCE LINE # 2017
0023         ?C0193:
                                           ; SOURCE LINE # 2019
                                           ; SOURCE LINE # 2020
0023 120000      R     LCALL   Load_GUD0
                                           ; SOURCE LINE # 2021
0026 120000      R     LCALL   Load_GUD1
                                           ; SOURCE LINE # 2022
0029 120000      R     LCALL   Load_GUD2
                                           ; SOURCE LINE # 2023
002C 120000      R     LCALL   Load_GUD3
                                           ; SOURCE LINE # 2024
002F 120000      R     LCALL   Load_GUD4
                                           ; SOURCE LINE # 2025
                                           ; SOURCE LINE # 2026
0032         ?C0196:
0032 22                RET     
             ; FUNCTION Check_EEPROM (END)

             ; FUNCTION Free_Background (BEGIN)
                                           ; SOURCE LINE # 2028
                                           ; SOURCE LINE # 2029
                                           ; SOURCE LINE # 2030
0000 7E00        E     MOV     R6,#HIGH FreeV
0002 7F00        E     MOV     R7,#LOW FreeV
0004 120000      E     LCALL   _RTDCodeW
                                           ; SOURCE LINE # 2033
0007 200010      E     JB      bPanel_Status,?C0197
                                           ; SOURCE LINE # 2034
                                           ; SOURCE LINE # 2036
000A E4                CLR     A
000B FD                MOV     R5,A
000C 7F21              MOV     R7,#021H
000E 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 2037
0011 7B01              MOV     R3,#01H
0013 7DFD              MOV     R5,#0FDH
0015 7F20              MOV     R7,#020H
0017 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2038
001A         ?C0197:
                                           ; SOURCE LINE # 2040
001A E4                CLR     A
001B FB                MOV     R3,A
001C 7DFE              MOV     R5,#0FEH
001E 7F04              MOV     R7,#04H
0020 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2043
0023 E500        R     MOV     A,stGUD1+01H
0025 5407              ANL     A,#07H
0027 FF                MOV     R7,A
0028 BF0504            CJNE    R7,#05H,?C0198
002B 7B10              MOV     R3,#010H
002D 8002              SJMP    ?C0199
002F         ?C0198:
002F 7B00              MOV     R3,#00H
0031         ?C0199:
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 94  

0031 7D0F              MOV     R5,#0FH
0033 7F21              MOV     R7,#021H
0035 020000      E     LJMP    _RTDSetBit
             ; FUNCTION Free_Background (END)

             ; FUNCTION Reset_Mode (BEGIN)
                                           ; SOURCE LINE # 2049
                                           ; SOURCE LINE # 2050
                                           ; SOURCE LINE # 2051
0000 750078      R     MOV     ucTimeout,#078H
                                           ; SOURCE LINE # 2054
0003 900000      E     MOV     DPTR,#M512_Port51
0006 7401              MOV     A,#01H
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2060
0009 7D40              MOV     R5,#040H
000B 7F02              MOV     R7,#02H
000D 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 2068
0010 7D0F              MOV     R5,#0FH
0012 7F99              MOV     R7,#099H
                                           ; SOURCE LINE # 2075
0014 120000      R     LCALL   L?0268
0017 FB                MOV     R3,A
0018 7DDF              MOV     R5,#0DFH
001A 7F8E              MOV     R7,#08EH
001C 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2078
001F E4                CLR     A
0020 FB                MOV     R3,A
0021 7D7F              MOV     R5,#07FH
0023 7F31              MOV     R7,#031H
0025 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2082
0028 E4                CLR     A
0029 FB                MOV     R3,A
002A 7DFC              MOV     R5,#0FCH
002C 7FFF              MOV     R7,#0FFH
002E 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2085
0031 E4                CLR     A
0032 FD                MOV     R5,A
0033 7F01              MOV     R7,#01H
0035 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 2086
0038 E4                CLR     A
0039 FD                MOV     R5,A
003A 7F1F              MOV     R7,#01FH
003C 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 2087
003F E4                CLR     A
0040 FD                MOV     R5,A
0041 7F3D              MOV     R7,#03DH
0043 120000      E     LCALL   _RTDSetByte
                                           ; SOURCE LINE # 2091
0046 120000      R     LCALL   Free_Background
                                           ; SOURCE LINE # 2093
0049 7E00        E     MOV     R6,#HIGH OSD_Reset
004B 7F00        E     MOV     R7,#LOW OSD_Reset
004D 120000      E     LCALL   _RTDOSDW
                                           ; SOURCE LINE # 2094
0050 7DFE              MOV     R5,#0FEH
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 95  

0052 7F6D              MOV     R7,#06DH
                                           ; SOURCE LINE # 2097
0054 120000      R     LCALL   L?0268
0057 FB                MOV     R3,A
0058 7DDF              MOV     R5,#0DFH
005A 7F3D              MOV     R7,#03DH
005C 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2099
005F 7D40              MOV     R5,#040H
0061 7F3D              MOV     R7,#03DH
0063 120000      E     LCALL   _RTDSetByte
0066         ?C0203:
                                           ; SOURCE LINE # 2101
                                           ; SOURCE LINE # 2102
0066 7B01              MOV     R3,#01H
0068 7D01              MOV     R5,#01H
006A 7F3D              MOV     R7,#03DH
006C 120000      E     LCALL   _RTDRead
                                           ; SOURCE LINE # 2103
006F 7F01              MOV     R7,#01H
0071 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 2105
0074 1500        R     DEC     ucTimeout
0076 E500        R     MOV     A,ucTimeout
0078 6005              JZ      ?C0202
007A E500        E     MOV     A,Data
007C 20E6E7            JB      ACC.6,?C0203
007F         ?C0202:
                                           ; SOURCE LINE # 2106
007F E4                CLR     A
0080 7800        E     MOV     R0,#LOW ucPE_Max
0082 F6                MOV     @R0,A
                                           ; SOURCE LINE # 2107
0083 7800        E     MOV     R0,#LOW ucPE_Level
0085 F6                MOV     @R0,A
                                           ; SOURCE LINE # 2111
0086 7800        E     MOV     R0,#LOW ucMode_Curr
0088 F6                MOV     @R0,A
                                           ; SOURCE LINE # 2112
0089 7800        E     MOV     R0,#LOW ucMode_Found
008B 76FF              MOV     @R0,#0FFH
                                           ; SOURCE LINE # 2114
008D 7800        E     MOV     R0,#LOW ucMode_Times
008F F6                MOV     @R0,A
                                           ; SOURCE LINE # 2115
0090 7800        E     MOV     R0,#LOW ucAV_Mode
0092 F6                MOV     @R0,A
                                           ; SOURCE LINE # 2116
0093 C200        E     CLR     bStable
                                           ; SOURCE LINE # 2117
0095 D200        E     SETB    bReload
                                           ; SOURCE LINE # 2118
0097 C200        E     CLR     bFrameSync
                                           ; SOURCE LINE # 2119
0099 7800        E     MOV     R0,#LOW ucPE_Max
009B F6                MOV     @R0,A
                                           ; SOURCE LINE # 2120
009C 7800        E     MOV     R0,#LOW ucI_Code
009E F6                MOV     @R0,A
                                           ; SOURCE LINE # 2121
009F C200        E     CLR     bOverSpec
                                           ; SOURCE LINE # 2123
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 96  

00A1 7800        E     MOV     R0,#LOW ucInputSrc
00A3 E6                MOV     A,@R0
00A4 FF                MOV     R7,A
00A5 6402              XRL     A,#02H
00A7 600A              JZ      ?C0206
00A9 EF                MOV     A,R7
00AA 6403              XRL     A,#03H
00AC 6005              JZ      ?C0206
00AE EF                MOV     A,R7
00AF 6405              XRL     A,#05H
00B1 7034              JNZ     ?C0210
00B3         ?C0206:
                                           ; SOURCE LINE # 2124
                                           ; SOURCE LINE # 2125
00B3 7E00        E     MOV     R6,#HIGH VIDEO_INI
00B5 7F00        E     MOV     R7,#LOW VIDEO_INI
00B7 120000      E     LCALL   _RTDCodeW
                                           ; SOURCE LINE # 2126
00BA 7800        E     MOV     R0,#LOW ucInputSrc
00BC E6                MOV     A,@R0
00BD 7BFF              MOV     R3,#0FFH
00BF B40306            CJNE    A,#03H,?C0207
00C2 7A00        E     MOV     R2,#HIGH SV_DETECT
00C4 7900        E     MOV     R1,#LOW SV_DETECT
00C6 8004              SJMP    ?C0208
00C8         ?C0207:
00C8 7A00        E     MOV     R2,#HIGH AV_DETECT
00CA 7900        E     MOV     R1,#LOW AV_DETECT
00CC         ?C0208:
00CC 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 2128
00CF 7800        E     MOV     R0,#LOW ucInputSrc
00D1 E6                MOV     A,@R0
00D2 B40512            CJNE    A,#05H,?C0210
                                           ; SOURCE LINE # 2129
                                           ; SOURCE LINE # 2131
00D5 7BFF              MOV     R3,#0FFH
00D7 7A00        E     MOV     R2,#HIGH TV_SOURCE_SEL
00D9 7900        E     MOV     R1,#LOW TV_SOURCE_SEL
00DB 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 2132
00DE 7BFF              MOV     R3,#0FFH
00E0 7A00        E     MOV     R2,#HIGH TV_SCAN_GAIN
00E2 7900        E     MOV     R1,#LOW TV_SCAN_GAIN
00E4 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 2133
                                           ; SOURCE LINE # 2134
                                           ; SOURCE LINE # 2143
00E7         ?C0210:
00E7 22                RET     
00E8         L?0268:
00E8 E4                CLR     A
00E9 FB                MOV     R3,A
00EA 120000      E     LCALL   _RTDSetBit
00ED E4                CLR     A
00EE 22                RET     
             ; FUNCTION Reset_Mode (END)

             ; FUNCTION RTD_Test (BEGIN)
                                           ; SOURCE LINE # 2412
                                           ; SOURCE LINE # 2413
                                           ; SOURCE LINE # 2573
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 97  

0000 22                RET     
             ; FUNCTION RTD_Test (END)

             ; FUNCTION Set_Spread (BEGIN)
                                           ; SOURCE LINE # 2580
                                           ; SOURCE LINE # 2581
                                           ; SOURCE LINE # 2582
0000 E500        R     MOV     A,stGUD3+04H
0002 C4                SWAP    A
0003 54F0              ANL     A,#0F0H
0005 FB                MOV     R3,A
0006 E4                CLR     A
0007 FD                MOV     R5,A
0008 7F99              MOV     R7,#099H
000A 120000      E     LCALL   _RTDSetBit
                                           ; SOURCE LINE # 2583
000D 7B20              MOV     R3,#020H
000F 7DFF              MOV     R5,#0FFH
0011 7F9B              MOV     R7,#09BH
0013 020000      E     LJMP    _RTDSetBit
             ; FUNCTION Set_Spread (END)

             ; FUNCTION Init_FRecall (BEGIN)
                                           ; SOURCE LINE # 2586
                                           ; SOURCE LINE # 2587
                                           ; SOURCE LINE # 2588
                                           ; SOURCE LINE # 2589
0000 120000      R     LCALL   L?0272
                                           ; SOURCE LINE # 2593
0003 900000      R     MOV     DPTR,#INIT_EEPROM0+08H
                                           ; SOURCE LINE # 2594
                                           ; SOURCE LINE # 2595
                                           ; SOURCE LINE # 2597
                                           ; SOURCE LINE # 2598
                                           ; SOURCE LINE # 2599
                                           ; SOURCE LINE # 2600
                                           ; SOURCE LINE # 2601
                                           ; SOURCE LINE # 2602
                                           ; SOURCE LINE # 2603
0006 120000      R     LCALL   L?0247
                                           ; SOURCE LINE # 2605
                                           ; SOURCE LINE # 2606
                                           ; SOURCE LINE # 2607
0009 120000      R     LCALL   L?0263
                                           ; SOURCE LINE # 2609
000C 7BFF              MOV     R3,#0FFH
000E 7A00        R     MOV     R2,#HIGH INIT_EEPROM0
0010 7900        R     MOV     R1,#LOW INIT_EEPROM0
0012 120000      E     LCALL   _I2CWrite
                                           ; SOURCE LINE # 2610
0015 7F10              MOV     R7,#010H
0017 120000      E     LCALL   _Delay_Xms
                                           ; SOURCE LINE # 2615
001A 120000      R     LCALL   Save_GUD0
                                           ; SOURCE LINE # 2616
001D 020000      R     LJMP    Save_GUD3
             ; FUNCTION Init_FRecall (END)

             ; FUNCTION Init_FACTORY (BEGIN)
                                           ; SOURCE LINE # 2619
                                           ; SOURCE LINE # 2620
                                           ; SOURCE LINE # 2624
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 98  

0000 E500        R     MOV     A,stGUD1
0002 5407              ANL     A,#07H
0004 F500        R     MOV     ucTemp1,A
                                           ; SOURCE LINE # 2625
0006 E500        R     MOV     A,stGUD1+01H
0008 5407              ANL     A,#07H
000A F500        R     MOV     ucTemp2,A
                                           ; SOURCE LINE # 2627
000C 7407              MOV     A,#07H
000E C3                CLR     C
000F 9500        R     SUBB    A,ucTemp1
0011 5003              JNC     ?C0214
                                           ; SOURCE LINE # 2628
0013 E4                CLR     A
0014 F500        R     MOV     ucTemp1,A
0016         ?C0214:
                                           ; SOURCE LINE # 2631
0016 7800        E     MOV     R0,#LOW usOSD_Timer
0018 7604              MOV     @R0,#04H
001A 08                INC     R0
001B 7600              MOV     @R0,#00H
                                           ; SOURCE LINE # 2634
001D 120000      R     LCALL   Init_FRecall
                                           ; SOURCE LINE # 2637
0020 E500        R     MOV     A,stGUD1+06H
0022 F8                MOV     R0,A
0023 E4                CLR     A
0024 7900        E     MOV     R1,#LOW usOSD_Timer+01H
0026 F7                MOV     @R1,A
0027 E8                MOV     A,R0
0028 25E0              ADD     A,ACC
002A 19                DEC     R1
002B F7                MOV     @R1,A
                                           ; SOURCE LINE # 2640
002C E500        R     MOV     A,stGUD1
002E 54F8              ANL     A,#0F8H
0030 4500        R     ORL     A,ucTemp1
0032 F500        R     MOV     stGUD1,A
                                           ; SOURCE LINE # 2641
0034 E500        R     MOV     A,stGUD1+01H
0036 54F8              ANL     A,#0F8H
0038 4500        R     ORL     A,ucTemp2
003A F500        R     MOV     stGUD1+01H,A
                                           ; SOURCE LINE # 2642
003C 120000      R     LCALL   Save_GUD1
                                           ; SOURCE LINE # 2645
003F 120000      R     LCALL   Set_Bright_Contrast
                                           ; SOURCE LINE # 2646
0042 120000      R     LCALL   SetADC_Gain
                                           ; SOURCE LINE # 2649
0045 120000      R     LCALL   SetVolume
                                           ; SOURCE LINE # 2652
0048 E500        R     MOV     A,stGUD1+01H
004A 5407              ANL     A,#07H
004C 700A              JNZ     ?C0215
                                           ; SOURCE LINE # 2653
                                           ; SOURCE LINE # 2654
004E 120000      E     LCALL   Auto_Config
0051 BFFC04            CJNE    R7,#0FCH,?C0215
0054 7800        E     MOV     R0,#LOW ucMode_Curr
0056 76FE              MOV     @R0,#0FEH
                                           ; SOURCE LINE # 2655
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 99  

0058         ?C0215:
                                           ; SOURCE LINE # 2658
0058 7F01              MOV     R7,#01H
005A 120000      E     LCALL   _OSD_Position
                                           ; SOURCE LINE # 2661
005D 120000      R     LCALL   Init_MUD
                                           ; SOURCE LINE # 2664
0060 7800        E     MOV     R0,#LOW ucMode_Curr
0062 E6                MOV     A,@R0
0063 FF                MOV     R7,A
0064 020000      R     LJMP    _Load_MUD
             ; FUNCTION Init_FACTORY (END)

C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 100 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


LP_GLOBAL_USER_DATA1 . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
ucI_Code . . . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
RGB_MODE_USER_DATA . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  H_POSITION . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  V_POSITION . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CLOCK. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  PHASE. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
LP_GLOBAL_USER_DATA2 . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
PowerUp_ADC. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LP_GLOBAL_USER_DATA3 . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
GLOBAL_USER_DATA0. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  CONTRAST . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  BRIGHT . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  RTD_R_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  RTD_G_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  RTD_B_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  RTD_R_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  RTD_G_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  RTD_B_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
_OSD_Position. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
usADC_Clock. . . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    0000H  2
LP_GLOABL_USER_DATA4 . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
GLOBAL_USER_DATA1. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  FUNCTION . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  INPUT_SOURCE . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  FILTER . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  OSD_POSH . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  OSD_POSV . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  OSD_TIMEOUT. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  OSD_INPUT. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
Save_GUD0. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
GLOBAL_USER_DATA2. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  AD_R_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  AD_G_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  AD_B_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  AD_R_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  AD_G_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  AD_B_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
bNotify_Timer1_Int . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
Save_GUD1. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
GLOBAL_USER_DATA3. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  VOLUME . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CURR_CHANNEL . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  PREV_CHANNEL . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  TV_SETTING . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  SPREAD . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
Save_GUD2. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
GLOBAL_USER_DATA4. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  C1_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  C1_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  C1_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  C2_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  C2_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  C2_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  C3_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 101 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  C3_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  C3_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
Save_GUD3. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Save_GUD4. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_RTDOSDW . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Check_EEPROM . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
bOverSpec. . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
_RTDSetByte. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Set_H_Position . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
INIT_EEPROM0 . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0000H  19
Init_FACTORY . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucTemp1. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucTemp2. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
INIT_EEPROM1 . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0013H  19
bAutoInProgress. . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
INIT_EEPROM2 . . . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0026H  19
Init_FRecall . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_WriteSU_COEF. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  arrayH . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  arrayV . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0002H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
ucInputSrc . . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
LP_VIDEO_MODE_USER_DATA. . . . . . . .  TYPEDEF  -----  PTR      -----  3
_RTDSetBit . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
UartData . . . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0002H  4
VIDEO_MODE_USER_DATA . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  4
  VBRIGHT. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VCONTRAST. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VSATURATION. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  VHUE . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
_I2CRead . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Set_V_Position . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  usIV_Temp. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  usDV_Temp. . . . . . . . . . . . . .  AUTO     DATA   U_INT    0002H  2
_RTDCodeW. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_Set_Contrast_Gain . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ContrastValue. . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ColorValue . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
TV_SOURCE_SEL. . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
Set_Bright_Contrast. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_Load_MUD. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mode_num . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SetVolume. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_I2CWrite. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Set_Dithering. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
usStdHS. . . . . . . . . . . . . . . .  EXTERN   IDATA  U_INT    -----  2
TV_SCAN_GAIN . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
AV_DETECT. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
usOSD_Timer. . . . . . . . . . . . . .  EXTERN   IDATA  U_INT    -----  2
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
_Save_MUD. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  mode_num . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SU_COEF_1. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
SU_COEF_2. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 102 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SU_COEF_3. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
VIDEO_INI. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
SU_COEF_4. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
SU_COEF_5. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
Sharpness. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
bReload. . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
bPanel_Status. . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
SU_COEF_7. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
ucMode_Found . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
bStable. . . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
SetADC_Offset. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucRed. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucBlue . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  ucGreen. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  ucRate . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
SetADC_GainOffset. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
SV_DETECT. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
ucDV_Delay . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0006H  1
ucMode_Times . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
_RTDRead . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
usIPH_ACT_WID. . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    0007H  2
ucPE_Level . . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
SetMute. . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  val. . . . . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
OSD_Reset. . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
usIPH_ACT_STA. . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    0009H  2
stMUD. . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   0000H  4
UartNum. . . . . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   000BH  1
_WriteDither . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  array. . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  new_dither . . . . . . . . . . . . .  AUTO     DATA   BIT      0000H  1
  n. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
usIPV_ACT_LEN. . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    000CH  2
DITHER_1 . . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
_WriteGamma. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  arrayR . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0000H  2
  arrayG . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0002H  2
  arrayB . . . . . . . . . . . . . . .  AUTO     DATA   PTR      0004H  2
  n. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0006H  1
M512_Port51. . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
Auto_Config. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_RTDSendAddr . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
M512_Port61. . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
Init_GUD . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
SetADC_Gain. . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucTempContrast . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucRate1. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  ucRed. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  ucGreen. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  ucBlue . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
ucAV_Mode. . . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
M512_Port64. . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_RTDWrite. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
bRTD_SCSB. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
FreeV. . . . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
usIPV_ACT_STA. . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    000EH  2
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 103 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


bRTD_SCLK. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
Init_MUD . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucModeIdx. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
usDH_Total . . . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    0010H  2
_RGB_MODE_USER_DATA. . . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  H_POSITION . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  V_POSITION . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CLOCK. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  PHASE. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
ucMode_Curr. . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
_GLOBAL_USER_DATA0 . . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  CONTRAST . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  BRIGHT . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  RTD_R_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  RTD_G_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  RTD_B_CONTRAST . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  RTD_R_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  RTD_G_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  RTD_B_BRIGHT . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
_Set_Phase . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  phase. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucX_Ctrl . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  ucY_Ctrl . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  ucSelect . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  ulRate . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0004H  4
_GLOBAL_USER_DATA1 . . . . . . . . . .  * TAG *  -----  STRUCT   -----  8
  FUNCTION . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  INPUT_SOURCE . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  FILTER . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  OSD_POSH . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  OSD_POSV . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  OSD_TIMEOUT. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  OSD_INPUT. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
_GLOBAL_USER_DATA2 . . . . . . . . . .  * TAG *  -----  STRUCT   -----  6
  AD_R_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  AD_G_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  AD_B_GAIN. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  AD_R_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  AD_G_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  AD_B_OFFSET. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
_GLOBAL_USER_DATA3 . . . . . . . . . .  * TAG *  -----  STRUCT   -----  5
  VOLUME . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CURR_CHANNEL . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  PREV_CHANNEL . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  TV_SETTING . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  SPREAD . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
_GLOBAL_USER_DATA4 . . . . . . . . . .  * TAG *  -----  STRUCT   -----  9
  C1_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  C1_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  C1_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  C2_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  C2_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  C2_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  C3_R . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  C3_G . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  C3_B . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
_Wait_For_Event. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 104 

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  event. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucDelayCnt . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  ucProtect. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
ucH_Min_Margin . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0012H  1
Free_Background. . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ucH_Max_Margin . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0013H  1
usDV_Total . . . . . . . . . . . . . .  PUBLIC   IDATA  U_INT    0014H  2
_Delay_Xms . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
RTD_Test . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Reset_Mode . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucTimeout. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
_RTDSendByte . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
bFrameSync . . . . . . . . . . . . . .  EXTERN   DATA   BIT      -----  1
Set_Spread . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Load_GUD0. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Set_Gamma. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Load_GUD1. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Load_GUD2. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
GAMMA_1. . . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
ucPE_Max . . . . . . . . . . . . . . .  EXTERN   IDATA  U_CHAR   -----  1
Load_GUD3. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
GAMMA_2. . . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
Load_GUD4. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ucV_Min_Margin . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0016H  1
GAMMA_3. . . . . . . . . . . . . . . .  EXTERN   CODE   ARRAY    -----  -----
ucV_Max_Margin . . . . . . . . . . . .  PUBLIC   IDATA  U_CHAR   0017H  1
stGUD0 . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   0004H  8
stGUD1 . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   000CH  8
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
stGUD2 . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   0014H  6
Data . . . . . . . . . . . . . . . . .  EXTERN   DATA   ARRAY    -----  16
Set_Clock. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ucM_Code . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  ucN_Code . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  ucTemp0. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
  ucTemp1. . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
  ucResult . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0004H  1
  usClock. . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0005H  2
  ulRate . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0007H  4
stGUD3 . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   001AH  5
_VIDEO_MODE_USER_DATA. . . . . . . . .  * TAG *  -----  STRUCT   -----  4
  VBRIGHT. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VCONTRAST. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VSATURATION. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  VHUE . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
LP_RGB_MODE_USER_DATA. . . . . . . . .  TYPEDEF  -----  PTR      -----  3
_SetColorGainOffset. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  addr . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  parameter. . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0001H  1
  bios . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
stGUD4 . . . . . . . . . . . . . . . .  PUBLIC   DATA   STRUCT   001FH  9
LP_GLOBAL_USER_DATA0 . . . . . . . . .  TYPEDEF  -----  PTR      -----  3


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4088    ----
   CONSTANT SIZE    =     57    ----
C51 COMPILER V7.06   LCD_FUNC                                                              11/21/2005 13:47:27 PAGE 105 

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      54
   IDATA SIZE       =     24    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
